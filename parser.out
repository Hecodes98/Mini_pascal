Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    OBJECT
    LBRACKET
    FILE
    PACKED
    ABSOLUTE
    RECORD
    IMPLEMENTATION
    LONG
    GOTO
    REINTRODUCE
    NIL
    OF
    INTERFACE
    LABEL
    AMPERSANT
    BREAK
    WITH
    SHR
    REPEAT
    PLUSPLUS
    RBLOCK
    INHERITED
    OPERATOR
    SHL
    UNTIL
    UNIT
    CLRSCR
    CASE
    SET
    ARRAY
    ASM
    WRITE
    INLINE
    TYPE
    CONST
    CONSTRUCTOR
    STRING
    IN
    LBLOCK
    MINUSMINUS
    SELF
    FLOAT
    DISTINT
    DESTRUCTOR
    HASHTAG
    RBRACKET

Grammar

Rule 0     S' -> program
Rule 1     program -> declaration_list
Rule 2     declaration_list -> declaration_list declaration
Rule 3     declaration_list -> declaration
Rule 4     declaration -> header_declaration
Rule 5     declaration -> var_declaration
Rule 6     declaration -> function_declaration
Rule 7     declaration -> procedure_declaration
Rule 8     header_declaration -> PROGRAM ID SEMICOLON
Rule 9     header_declaration -> USES ID header_declaration_3 SEMICOLON
Rule 10    header_declaration_3 -> COMMA ID header_declaration_3
Rule 11    header_declaration_3 -> empty
Rule 12    var_declaration -> VAR var_declaration_2
Rule 13    var_declaration_2 -> ID var_declaration_3 COLON type_specifier SEMICOLON var_declaration_4
Rule 14    var_declaration_3 -> COMMA ID var_declaration_3
Rule 15    var_declaration_3 -> empty
Rule 16    var_declaration_4 -> var_declaration_2
Rule 17    var_declaration_4 -> empty
Rule 18    empty -> <empty>
Rule 19    math -> factor mathi
Rule 20    mathi -> type_op_math factor mathi
Rule 21    mathi -> empty
Rule 22    factor -> LPAREN math RPAREN
Rule 23    factor -> NUMBER
Rule 24    factor -> ID
Rule 25    type_specifier -> INTEGER
Rule 26    type_specifier -> REAL
Rule 27    type_specifier -> CHAR
Rule 28    type_specifier -> BOOLEAN
Rule 29    type_specifier -> DOUBLE
Rule 30    procedure_declaration -> BEGIN instruction END DOT
Rule 31    instruction -> asignation instruction
Rule 32    instruction -> writing instruction
Rule 33    instruction -> cycles instruction
Rule 34    instruction -> callFunctions instruction
Rule 35    instruction -> empty
Rule 36    callFunctions -> ID LPAREN params RPAREN
Rule 37    params -> math params2
Rule 38    params2 -> COMMA math
Rule 39    params2 -> empty
Rule 40    instruction_one_line -> asignation
Rule 41    instruction_one_line -> writing
Rule 42    instruction_one_line -> cycles
Rule 43    id_text_l -> callFunctions COMMA id_text_l
Rule 44    id_text_l -> ID COMMA id_text_l
Rule 45    id_text_l -> empty
Rule 46    id_text_r -> COMMA callFunctions id_text_r
Rule 47    id_text_r -> COMMA ID id_text_r
Rule 48    id_text_r -> empty
Rule 49    writing -> WRITELN LPAREN id_text_l TEXT id_text_r RPAREN SEMICOLON
Rule 50    writing -> WRITELN LPAREN id_num RPAREN SEMICOLON
Rule 51    writing -> READLN LPAREN ID RPAREN SEMICOLON
Rule 52    writing -> READLN LPAREN RPAREN SEMICOLON
Rule 53    writing -> READLN SEMICOLON
Rule 54    writing -> WRITELN SEMICOLON
Rule 55    asignation -> ID EQUAL callFunctions SEMICOLON
Rule 56    asignation -> ID EQUAL math SEMICOLON
Rule 57    asignation -> ID EQUAL boolean SEMICOLON
Rule 58    asignation -> ID EQUAL TEXT SEMICOLON
Rule 59    asignation_for -> ID EQUAL id_num
Rule 60    cycles -> type_cycle
Rule 61    type_cycle -> while
Rule 62    type_cycle -> if
Rule 63    type_cycle -> for
Rule 64    type_cycle -> cycles instruction
Rule 65    while -> WHILE internexpression op_cycle DO otherBegin
Rule 66    if -> IF internexpression op_cycle THEN otherBegin_if
Rule 67    if -> IF internexpression op_cycle THEN instruction_one_line
Rule 68    if -> IF internexpression op_cycle THEN otherBegin_if ELSE otherBegin
Rule 69    if -> IF internexpression op_cycle THEN otherBegin_if ELSE instruction_one_line
Rule 70    if -> IF internexpression op_cycle THEN instruction_one_line ELSE otherBegin
Rule 71    if -> IF internexpression op_cycle THEN instruction_one_line ELSE instruction_one_line
Rule 72    for -> FOR asignation_for TO id_num DO otherBegin
Rule 73    for -> FOR asignation_for DOWNTO id_num DO otherBegin
Rule 74    op_cycle -> op_logic internexpression op_cycle
Rule 75    op_cycle -> empty
Rule 76    internexpression -> parentheses
Rule 77    internexpression -> expression
Rule 78    parentheses -> LPAREN expression RPAREN
Rule 79    expression -> math type_op math
Rule 80    expression -> ID
Rule 81    expression -> math ISEQUAL boolean
Rule 82    expression -> boolean ISEQUAL math
Rule 83    expression -> expression2
Rule 84    expression2 -> TEXT type_op TEXT
Rule 85    expression2 -> TEXT type_op ID
Rule 86    type_op -> LESSEQUAL
Rule 87    type_op -> LESS
Rule 88    type_op -> GREATER
Rule 89    type_op -> GREATEREQUAL
Rule 90    type_op -> DEQUAL
Rule 91    type_op -> ISEQUAL
Rule 92    type_op_math -> PLUS
Rule 93    type_op_math -> MINUS
Rule 94    type_op_math -> TIMES
Rule 95    type_op_math -> DIVIDE
Rule 96    type_op_math -> MOD
Rule 97    op_logic -> AND
Rule 98    op_logic -> OR
Rule 99    op_logic -> XOR
Rule 100   op_logic -> NOT
Rule 101   id_num -> NUMBER
Rule 102   id_num -> ID
Rule 103   boolean -> TRUE
Rule 104   boolean -> FALSE
Rule 105   otherBegin -> BEGIN instruction END SEMICOLON instruction
Rule 106   otherBegin_if -> BEGIN instruction END instruction
Rule 107   Begin_function -> var_declaration BEGIN instruction END SEMICOLON instruction
Rule 108   Begin_function -> BEGIN instruction END SEMICOLON instruction
Rule 109   function_declaration -> FUNCTION ID LPAREN fun_param RPAREN COLON type_specifier SEMICOLON Begin_function
Rule 110   function_declaration -> PROCEDURE ID LPAREN fun_param RPAREN SEMICOLON Begin_function
Rule 111   function_declaration -> PROCEDURE ID SEMICOLON Begin_function
Rule 112   fun_param -> ID fun_param_2 COLON type_specifier fun_param
Rule 113   fun_param -> SEMICOLON ID fun_param_2 COLON type_specifier fun_param
Rule 114   fun_param -> empty
Rule 115   fun_param_2 -> COMMA ID fun_param_2
Rule 116   fun_param_2 -> empty

Terminals, with rules where they appear

ABSOLUTE             : 
AMPERSANT            : 
AND                  : 97
ARRAY                : 
ASM                  : 
BEGIN                : 30 105 106 107 108
BOOLEAN              : 28
BREAK                : 
CASE                 : 
CHAR                 : 27
CLRSCR               : 
COLON                : 13 109 112 113
COMMA                : 10 14 38 43 44 46 47 115
CONST                : 
CONSTRUCTOR          : 
DEQUAL               : 90
DESTRUCTOR           : 
DISTINT              : 
DIVIDE               : 95
DO                   : 65 72 73
DOT                  : 30
DOUBLE               : 29
DOWNTO               : 73
ELSE                 : 68 69 70 71
END                  : 30 105 106 107 108
EQUAL                : 55 56 57 58 59
FALSE                : 104
FILE                 : 
FLOAT                : 
FOR                  : 72 73
FUNCTION             : 109
GOTO                 : 
GREATER              : 88
GREATEREQUAL         : 89
HASHTAG              : 
ID                   : 8 9 10 13 14 24 36 44 47 51 55 56 57 58 59 80 85 102 109 110 111 112 113 115
IF                   : 66 67 68 69 70 71
IMPLEMENTATION       : 
IN                   : 
INHERITED            : 
INLINE               : 
INTEGER              : 25
INTERFACE            : 
ISEQUAL              : 81 82 91
LABEL                : 
LBLOCK               : 
LBRACKET             : 
LESS                 : 87
LESSEQUAL            : 86
LONG                 : 
LPAREN               : 22 36 49 50 51 52 78 109 110
MINUS                : 93
MINUSMINUS           : 
MOD                  : 96
NIL                  : 
NOT                  : 100
NUMBER               : 23 101
OBJECT               : 
OF                   : 
OPERATOR             : 
OR                   : 98
PACKED               : 
PLUS                 : 92
PLUSPLUS             : 
PROCEDURE            : 110 111
PROGRAM              : 8
RBLOCK               : 
RBRACKET             : 
READLN               : 51 52 53
REAL                 : 26
RECORD               : 
REINTRODUCE          : 
REPEAT               : 
RPAREN               : 22 36 49 50 51 52 78 109 110
SELF                 : 
SEMICOLON            : 8 9 13 49 50 51 52 53 54 55 56 57 58 105 107 108 109 110 111 113
SET                  : 
SHL                  : 
SHR                  : 
STRING               : 
TEXT                 : 49 58 84 84 85
THEN                 : 66 67 68 69 70 71
TIMES                : 94
TO                   : 72
TRUE                 : 103
TYPE                 : 
UNIT                 : 
UNTIL                : 
USES                 : 9
VAR                  : 12
WHILE                : 65
WITH                 : 
WRITE                : 
WRITELN              : 49 50 54
XOR                  : 99
error                : 

Nonterminals, with rules where they appear

Begin_function       : 109 110 111
asignation           : 31 40
asignation_for       : 72 73
boolean              : 57 81 82
callFunctions        : 34 43 46 55
cycles               : 33 42 64
declaration          : 2 3
declaration_list     : 1 2
empty                : 11 15 17 21 35 39 45 48 75 114 116
expression           : 77 78
expression2          : 83
factor               : 19 20
for                  : 63
fun_param            : 109 110 112 113
fun_param_2          : 112 113 115
function_declaration : 6
header_declaration   : 4
header_declaration_3 : 9 10
id_num               : 50 59 72 73
id_text_l            : 43 44 49
id_text_r            : 46 47 49
if                   : 62
instruction          : 30 31 32 33 34 64 105 105 106 106 107 107 108 108
instruction_one_line : 67 69 70 71 71
internexpression     : 65 66 67 68 69 70 71 74
math                 : 22 37 38 56 79 79 81 82
mathi                : 19 20
op_cycle             : 65 66 67 68 69 70 71 74
op_logic             : 74
otherBegin           : 65 68 70 72 73
otherBegin_if        : 66 68 69
params               : 36
params2              : 37
parentheses          : 76
procedure_declaration : 7
program              : 0
type_cycle           : 60
type_op              : 79 84 85
type_op_math         : 20
type_specifier       : 13 109 112 113
var_declaration      : 5 107
var_declaration_2    : 12 16
var_declaration_3    : 13 14
var_declaration_4    : 13
while                : 61
writing              : 32 41

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . declaration_list
    (2) declaration_list -> . declaration_list declaration
    (3) declaration_list -> . declaration
    (4) declaration -> . header_declaration
    (5) declaration -> . var_declaration
    (6) declaration -> . function_declaration
    (7) declaration -> . procedure_declaration
    (8) header_declaration -> . PROGRAM ID SEMICOLON
    (9) header_declaration -> . USES ID header_declaration_3 SEMICOLON
    (12) var_declaration -> . VAR var_declaration_2
    (109) function_declaration -> . FUNCTION ID LPAREN fun_param RPAREN COLON type_specifier SEMICOLON Begin_function
    (110) function_declaration -> . PROCEDURE ID LPAREN fun_param RPAREN SEMICOLON Begin_function
    (111) function_declaration -> . PROCEDURE ID SEMICOLON Begin_function
    (30) procedure_declaration -> . BEGIN instruction END DOT

    PROGRAM         shift and go to state 2
    USES            shift and go to state 3
    VAR             shift and go to state 9
    FUNCTION        shift and go to state 1
    PROCEDURE       shift and go to state 10
    BEGIN           shift and go to state 4

    header_declaration             shift and go to state 7
    function_declaration           shift and go to state 11
    procedure_declaration          shift and go to state 12
    declaration_list               shift and go to state 13
    var_declaration                shift and go to state 5
    program                        shift and go to state 6
    declaration                    shift and go to state 8

state 1

    (109) function_declaration -> FUNCTION . ID LPAREN fun_param RPAREN COLON type_specifier SEMICOLON Begin_function

    ID              shift and go to state 14


state 2

    (8) header_declaration -> PROGRAM . ID SEMICOLON

    ID              shift and go to state 15


state 3

    (9) header_declaration -> USES . ID header_declaration_3 SEMICOLON

    ID              shift and go to state 16


state 4

    (30) procedure_declaration -> BEGIN . instruction END DOT
    (31) instruction -> . asignation instruction
    (32) instruction -> . writing instruction
    (33) instruction -> . cycles instruction
    (34) instruction -> . callFunctions instruction
    (35) instruction -> . empty
    (55) asignation -> . ID EQUAL callFunctions SEMICOLON
    (56) asignation -> . ID EQUAL math SEMICOLON
    (57) asignation -> . ID EQUAL boolean SEMICOLON
    (58) asignation -> . ID EQUAL TEXT SEMICOLON
    (49) writing -> . WRITELN LPAREN id_text_l TEXT id_text_r RPAREN SEMICOLON
    (50) writing -> . WRITELN LPAREN id_num RPAREN SEMICOLON
    (51) writing -> . READLN LPAREN ID RPAREN SEMICOLON
    (52) writing -> . READLN LPAREN RPAREN SEMICOLON
    (53) writing -> . READLN SEMICOLON
    (54) writing -> . WRITELN SEMICOLON
    (60) cycles -> . type_cycle
    (36) callFunctions -> . ID LPAREN params RPAREN
    (18) empty -> .
    (61) type_cycle -> . while
    (62) type_cycle -> . if
    (63) type_cycle -> . for
    (64) type_cycle -> . cycles instruction
    (65) while -> . WHILE internexpression op_cycle DO otherBegin
    (66) if -> . IF internexpression op_cycle THEN otherBegin_if
    (67) if -> . IF internexpression op_cycle THEN instruction_one_line
    (68) if -> . IF internexpression op_cycle THEN otherBegin_if ELSE otherBegin
    (69) if -> . IF internexpression op_cycle THEN otherBegin_if ELSE instruction_one_line
    (70) if -> . IF internexpression op_cycle THEN instruction_one_line ELSE otherBegin
    (71) if -> . IF internexpression op_cycle THEN instruction_one_line ELSE instruction_one_line
    (72) for -> . FOR asignation_for TO id_num DO otherBegin
    (73) for -> . FOR asignation_for DOWNTO id_num DO otherBegin

    ID              shift and go to state 24
    WRITELN         shift and go to state 23
    READLN          shift and go to state 29
    END             reduce using rule 18 (empty -> .)
    WHILE           shift and go to state 17
    IF              shift and go to state 25
    FOR             shift and go to state 22

    instruction                    shift and go to state 27
    if                             shift and go to state 20
    for                            shift and go to state 26
    writing                        shift and go to state 18
    callFunctions                  shift and go to state 19
    asignation                     shift and go to state 28
    type_cycle                     shift and go to state 30
    while                          shift and go to state 31
    empty                          shift and go to state 21
    cycles                         shift and go to state 32

state 5

    (5) declaration -> var_declaration .

    PROGRAM         reduce using rule 5 (declaration -> var_declaration .)
    USES            reduce using rule 5 (declaration -> var_declaration .)
    VAR             reduce using rule 5 (declaration -> var_declaration .)
    FUNCTION        reduce using rule 5 (declaration -> var_declaration .)
    PROCEDURE       reduce using rule 5 (declaration -> var_declaration .)
    BEGIN           reduce using rule 5 (declaration -> var_declaration .)
    $end            reduce using rule 5 (declaration -> var_declaration .)


state 6

    (0) S' -> program .



state 7

    (4) declaration -> header_declaration .

    PROGRAM         reduce using rule 4 (declaration -> header_declaration .)
    USES            reduce using rule 4 (declaration -> header_declaration .)
    VAR             reduce using rule 4 (declaration -> header_declaration .)
    FUNCTION        reduce using rule 4 (declaration -> header_declaration .)
    PROCEDURE       reduce using rule 4 (declaration -> header_declaration .)
    BEGIN           reduce using rule 4 (declaration -> header_declaration .)
    $end            reduce using rule 4 (declaration -> header_declaration .)


state 8

    (3) declaration_list -> declaration .

    PROGRAM         reduce using rule 3 (declaration_list -> declaration .)
    USES            reduce using rule 3 (declaration_list -> declaration .)
    VAR             reduce using rule 3 (declaration_list -> declaration .)
    FUNCTION        reduce using rule 3 (declaration_list -> declaration .)
    PROCEDURE       reduce using rule 3 (declaration_list -> declaration .)
    BEGIN           reduce using rule 3 (declaration_list -> declaration .)
    $end            reduce using rule 3 (declaration_list -> declaration .)


state 9

    (12) var_declaration -> VAR . var_declaration_2
    (13) var_declaration_2 -> . ID var_declaration_3 COLON type_specifier SEMICOLON var_declaration_4

    ID              shift and go to state 34

    var_declaration_2              shift and go to state 33

state 10

    (110) function_declaration -> PROCEDURE . ID LPAREN fun_param RPAREN SEMICOLON Begin_function
    (111) function_declaration -> PROCEDURE . ID SEMICOLON Begin_function

    ID              shift and go to state 35


state 11

    (6) declaration -> function_declaration .

    PROGRAM         reduce using rule 6 (declaration -> function_declaration .)
    USES            reduce using rule 6 (declaration -> function_declaration .)
    VAR             reduce using rule 6 (declaration -> function_declaration .)
    FUNCTION        reduce using rule 6 (declaration -> function_declaration .)
    PROCEDURE       reduce using rule 6 (declaration -> function_declaration .)
    BEGIN           reduce using rule 6 (declaration -> function_declaration .)
    $end            reduce using rule 6 (declaration -> function_declaration .)


state 12

    (7) declaration -> procedure_declaration .

    PROGRAM         reduce using rule 7 (declaration -> procedure_declaration .)
    USES            reduce using rule 7 (declaration -> procedure_declaration .)
    VAR             reduce using rule 7 (declaration -> procedure_declaration .)
    FUNCTION        reduce using rule 7 (declaration -> procedure_declaration .)
    PROCEDURE       reduce using rule 7 (declaration -> procedure_declaration .)
    BEGIN           reduce using rule 7 (declaration -> procedure_declaration .)
    $end            reduce using rule 7 (declaration -> procedure_declaration .)


state 13

    (1) program -> declaration_list .
    (2) declaration_list -> declaration_list . declaration
    (4) declaration -> . header_declaration
    (5) declaration -> . var_declaration
    (6) declaration -> . function_declaration
    (7) declaration -> . procedure_declaration
    (8) header_declaration -> . PROGRAM ID SEMICOLON
    (9) header_declaration -> . USES ID header_declaration_3 SEMICOLON
    (12) var_declaration -> . VAR var_declaration_2
    (109) function_declaration -> . FUNCTION ID LPAREN fun_param RPAREN COLON type_specifier SEMICOLON Begin_function
    (110) function_declaration -> . PROCEDURE ID LPAREN fun_param RPAREN SEMICOLON Begin_function
    (111) function_declaration -> . PROCEDURE ID SEMICOLON Begin_function
    (30) procedure_declaration -> . BEGIN instruction END DOT

    $end            reduce using rule 1 (program -> declaration_list .)
    PROGRAM         shift and go to state 2
    USES            shift and go to state 3
    VAR             shift and go to state 9
    FUNCTION        shift and go to state 1
    PROCEDURE       shift and go to state 10
    BEGIN           shift and go to state 4

    header_declaration             shift and go to state 7
    function_declaration           shift and go to state 11
    procedure_declaration          shift and go to state 12
    var_declaration                shift and go to state 5
    declaration                    shift and go to state 36

state 14

    (109) function_declaration -> FUNCTION ID . LPAREN fun_param RPAREN COLON type_specifier SEMICOLON Begin_function

    LPAREN          shift and go to state 37


state 15

    (8) header_declaration -> PROGRAM ID . SEMICOLON

    SEMICOLON       shift and go to state 38


state 16

    (9) header_declaration -> USES ID . header_declaration_3 SEMICOLON
    (10) header_declaration_3 -> . COMMA ID header_declaration_3
    (11) header_declaration_3 -> . empty
    (18) empty -> .

    COMMA           shift and go to state 39
    SEMICOLON       reduce using rule 18 (empty -> .)

    header_declaration_3           shift and go to state 40
    empty                          shift and go to state 41

state 17

    (65) while -> WHILE . internexpression op_cycle DO otherBegin
    (76) internexpression -> . parentheses
    (77) internexpression -> . expression
    (78) parentheses -> . LPAREN expression RPAREN
    (79) expression -> . math type_op math
    (80) expression -> . ID
    (81) expression -> . math ISEQUAL boolean
    (82) expression -> . boolean ISEQUAL math
    (83) expression -> . expression2
    (19) math -> . factor mathi
    (103) boolean -> . TRUE
    (104) boolean -> . FALSE
    (84) expression2 -> . TEXT type_op TEXT
    (85) expression2 -> . TEXT type_op ID
    (22) factor -> . LPAREN math RPAREN
    (23) factor -> . NUMBER
    (24) factor -> . ID

    LPAREN          shift and go to state 49
    ID              shift and go to state 53
    TRUE            shift and go to state 46
    FALSE           shift and go to state 45
    TEXT            shift and go to state 48
    NUMBER          shift and go to state 44

    parentheses                    shift and go to state 42
    internexpression               shift and go to state 43
    factor                         shift and go to state 50
    boolean                        shift and go to state 47
    expression2                    shift and go to state 51
    expression                     shift and go to state 52
    math                           shift and go to state 54

state 18

    (32) instruction -> writing . instruction
    (31) instruction -> . asignation instruction
    (32) instruction -> . writing instruction
    (33) instruction -> . cycles instruction
    (34) instruction -> . callFunctions instruction
    (35) instruction -> . empty
    (55) asignation -> . ID EQUAL callFunctions SEMICOLON
    (56) asignation -> . ID EQUAL math SEMICOLON
    (57) asignation -> . ID EQUAL boolean SEMICOLON
    (58) asignation -> . ID EQUAL TEXT SEMICOLON
    (49) writing -> . WRITELN LPAREN id_text_l TEXT id_text_r RPAREN SEMICOLON
    (50) writing -> . WRITELN LPAREN id_num RPAREN SEMICOLON
    (51) writing -> . READLN LPAREN ID RPAREN SEMICOLON
    (52) writing -> . READLN LPAREN RPAREN SEMICOLON
    (53) writing -> . READLN SEMICOLON
    (54) writing -> . WRITELN SEMICOLON
    (60) cycles -> . type_cycle
    (36) callFunctions -> . ID LPAREN params RPAREN
    (18) empty -> .
    (61) type_cycle -> . while
    (62) type_cycle -> . if
    (63) type_cycle -> . for
    (64) type_cycle -> . cycles instruction
    (65) while -> . WHILE internexpression op_cycle DO otherBegin
    (66) if -> . IF internexpression op_cycle THEN otherBegin_if
    (67) if -> . IF internexpression op_cycle THEN instruction_one_line
    (68) if -> . IF internexpression op_cycle THEN otherBegin_if ELSE otherBegin
    (69) if -> . IF internexpression op_cycle THEN otherBegin_if ELSE instruction_one_line
    (70) if -> . IF internexpression op_cycle THEN instruction_one_line ELSE otherBegin
    (71) if -> . IF internexpression op_cycle THEN instruction_one_line ELSE instruction_one_line
    (72) for -> . FOR asignation_for TO id_num DO otherBegin
    (73) for -> . FOR asignation_for DOWNTO id_num DO otherBegin

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WRITELN resolved as shift
  ! shift/reduce conflict for READLN resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
    ID              shift and go to state 24
    WRITELN         shift and go to state 23
    READLN          shift and go to state 29
    END             reduce using rule 18 (empty -> .)
    ELSE            reduce using rule 18 (empty -> .)
    PROGRAM         reduce using rule 18 (empty -> .)
    USES            reduce using rule 18 (empty -> .)
    VAR             reduce using rule 18 (empty -> .)
    FUNCTION        reduce using rule 18 (empty -> .)
    PROCEDURE       reduce using rule 18 (empty -> .)
    BEGIN           reduce using rule 18 (empty -> .)
    $end            reduce using rule 18 (empty -> .)
    WHILE           shift and go to state 17
    IF              shift and go to state 25
    FOR             shift and go to state 22

  ! ID              [ reduce using rule 18 (empty -> .) ]
  ! WRITELN         [ reduce using rule 18 (empty -> .) ]
  ! READLN          [ reduce using rule 18 (empty -> .) ]
  ! WHILE           [ reduce using rule 18 (empty -> .) ]
  ! IF              [ reduce using rule 18 (empty -> .) ]
  ! FOR             [ reduce using rule 18 (empty -> .) ]

    instruction                    shift and go to state 55
    if                             shift and go to state 20
    for                            shift and go to state 26
    writing                        shift and go to state 18
    callFunctions                  shift and go to state 19
    asignation                     shift and go to state 28
    type_cycle                     shift and go to state 30
    while                          shift and go to state 31
    empty                          shift and go to state 21
    cycles                         shift and go to state 32

state 19

    (34) instruction -> callFunctions . instruction
    (31) instruction -> . asignation instruction
    (32) instruction -> . writing instruction
    (33) instruction -> . cycles instruction
    (34) instruction -> . callFunctions instruction
    (35) instruction -> . empty
    (55) asignation -> . ID EQUAL callFunctions SEMICOLON
    (56) asignation -> . ID EQUAL math SEMICOLON
    (57) asignation -> . ID EQUAL boolean SEMICOLON
    (58) asignation -> . ID EQUAL TEXT SEMICOLON
    (49) writing -> . WRITELN LPAREN id_text_l TEXT id_text_r RPAREN SEMICOLON
    (50) writing -> . WRITELN LPAREN id_num RPAREN SEMICOLON
    (51) writing -> . READLN LPAREN ID RPAREN SEMICOLON
    (52) writing -> . READLN LPAREN RPAREN SEMICOLON
    (53) writing -> . READLN SEMICOLON
    (54) writing -> . WRITELN SEMICOLON
    (60) cycles -> . type_cycle
    (36) callFunctions -> . ID LPAREN params RPAREN
    (18) empty -> .
    (61) type_cycle -> . while
    (62) type_cycle -> . if
    (63) type_cycle -> . for
    (64) type_cycle -> . cycles instruction
    (65) while -> . WHILE internexpression op_cycle DO otherBegin
    (66) if -> . IF internexpression op_cycle THEN otherBegin_if
    (67) if -> . IF internexpression op_cycle THEN instruction_one_line
    (68) if -> . IF internexpression op_cycle THEN otherBegin_if ELSE otherBegin
    (69) if -> . IF internexpression op_cycle THEN otherBegin_if ELSE instruction_one_line
    (70) if -> . IF internexpression op_cycle THEN instruction_one_line ELSE otherBegin
    (71) if -> . IF internexpression op_cycle THEN instruction_one_line ELSE instruction_one_line
    (72) for -> . FOR asignation_for TO id_num DO otherBegin
    (73) for -> . FOR asignation_for DOWNTO id_num DO otherBegin

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WRITELN resolved as shift
  ! shift/reduce conflict for READLN resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
    ID              shift and go to state 24
    WRITELN         shift and go to state 23
    READLN          shift and go to state 29
    END             reduce using rule 18 (empty -> .)
    ELSE            reduce using rule 18 (empty -> .)
    PROGRAM         reduce using rule 18 (empty -> .)
    USES            reduce using rule 18 (empty -> .)
    VAR             reduce using rule 18 (empty -> .)
    FUNCTION        reduce using rule 18 (empty -> .)
    PROCEDURE       reduce using rule 18 (empty -> .)
    BEGIN           reduce using rule 18 (empty -> .)
    $end            reduce using rule 18 (empty -> .)
    WHILE           shift and go to state 17
    IF              shift and go to state 25
    FOR             shift and go to state 22

  ! ID              [ reduce using rule 18 (empty -> .) ]
  ! WRITELN         [ reduce using rule 18 (empty -> .) ]
  ! READLN          [ reduce using rule 18 (empty -> .) ]
  ! WHILE           [ reduce using rule 18 (empty -> .) ]
  ! IF              [ reduce using rule 18 (empty -> .) ]
  ! FOR             [ reduce using rule 18 (empty -> .) ]

    instruction                    shift and go to state 56
    if                             shift and go to state 20
    for                            shift and go to state 26
    writing                        shift and go to state 18
    callFunctions                  shift and go to state 19
    asignation                     shift and go to state 28
    type_cycle                     shift and go to state 30
    while                          shift and go to state 31
    empty                          shift and go to state 21
    cycles                         shift and go to state 32

state 20

    (62) type_cycle -> if .

    END             reduce using rule 62 (type_cycle -> if .)
    ID              reduce using rule 62 (type_cycle -> if .)
    WRITELN         reduce using rule 62 (type_cycle -> if .)
    READLN          reduce using rule 62 (type_cycle -> if .)
    WHILE           reduce using rule 62 (type_cycle -> if .)
    IF              reduce using rule 62 (type_cycle -> if .)
    FOR             reduce using rule 62 (type_cycle -> if .)
    ELSE            reduce using rule 62 (type_cycle -> if .)
    PROGRAM         reduce using rule 62 (type_cycle -> if .)
    USES            reduce using rule 62 (type_cycle -> if .)
    VAR             reduce using rule 62 (type_cycle -> if .)
    FUNCTION        reduce using rule 62 (type_cycle -> if .)
    PROCEDURE       reduce using rule 62 (type_cycle -> if .)
    BEGIN           reduce using rule 62 (type_cycle -> if .)
    $end            reduce using rule 62 (type_cycle -> if .)


state 21

    (35) instruction -> empty .

    END             reduce using rule 35 (instruction -> empty .)
    ID              reduce using rule 35 (instruction -> empty .)
    WRITELN         reduce using rule 35 (instruction -> empty .)
    READLN          reduce using rule 35 (instruction -> empty .)
    WHILE           reduce using rule 35 (instruction -> empty .)
    IF              reduce using rule 35 (instruction -> empty .)
    FOR             reduce using rule 35 (instruction -> empty .)
    ELSE            reduce using rule 35 (instruction -> empty .)
    PROGRAM         reduce using rule 35 (instruction -> empty .)
    USES            reduce using rule 35 (instruction -> empty .)
    VAR             reduce using rule 35 (instruction -> empty .)
    FUNCTION        reduce using rule 35 (instruction -> empty .)
    PROCEDURE       reduce using rule 35 (instruction -> empty .)
    BEGIN           reduce using rule 35 (instruction -> empty .)
    $end            reduce using rule 35 (instruction -> empty .)


state 22

    (72) for -> FOR . asignation_for TO id_num DO otherBegin
    (73) for -> FOR . asignation_for DOWNTO id_num DO otherBegin
    (59) asignation_for -> . ID EQUAL id_num

    ID              shift and go to state 58

    asignation_for                 shift and go to state 57

state 23

    (49) writing -> WRITELN . LPAREN id_text_l TEXT id_text_r RPAREN SEMICOLON
    (50) writing -> WRITELN . LPAREN id_num RPAREN SEMICOLON
    (54) writing -> WRITELN . SEMICOLON

    LPAREN          shift and go to state 60
    SEMICOLON       shift and go to state 59


state 24

    (55) asignation -> ID . EQUAL callFunctions SEMICOLON
    (56) asignation -> ID . EQUAL math SEMICOLON
    (57) asignation -> ID . EQUAL boolean SEMICOLON
    (58) asignation -> ID . EQUAL TEXT SEMICOLON
    (36) callFunctions -> ID . LPAREN params RPAREN

    EQUAL           shift and go to state 62
    LPAREN          shift and go to state 61


state 25

    (66) if -> IF . internexpression op_cycle THEN otherBegin_if
    (67) if -> IF . internexpression op_cycle THEN instruction_one_line
    (68) if -> IF . internexpression op_cycle THEN otherBegin_if ELSE otherBegin
    (69) if -> IF . internexpression op_cycle THEN otherBegin_if ELSE instruction_one_line
    (70) if -> IF . internexpression op_cycle THEN instruction_one_line ELSE otherBegin
    (71) if -> IF . internexpression op_cycle THEN instruction_one_line ELSE instruction_one_line
    (76) internexpression -> . parentheses
    (77) internexpression -> . expression
    (78) parentheses -> . LPAREN expression RPAREN
    (79) expression -> . math type_op math
    (80) expression -> . ID
    (81) expression -> . math ISEQUAL boolean
    (82) expression -> . boolean ISEQUAL math
    (83) expression -> . expression2
    (19) math -> . factor mathi
    (103) boolean -> . TRUE
    (104) boolean -> . FALSE
    (84) expression2 -> . TEXT type_op TEXT
    (85) expression2 -> . TEXT type_op ID
    (22) factor -> . LPAREN math RPAREN
    (23) factor -> . NUMBER
    (24) factor -> . ID

    LPAREN          shift and go to state 49
    ID              shift and go to state 53
    TRUE            shift and go to state 46
    FALSE           shift and go to state 45
    TEXT            shift and go to state 48
    NUMBER          shift and go to state 44

    parentheses                    shift and go to state 42
    internexpression               shift and go to state 63
    factor                         shift and go to state 50
    boolean                        shift and go to state 47
    expression2                    shift and go to state 51
    expression                     shift and go to state 52
    math                           shift and go to state 54

state 26

    (63) type_cycle -> for .

    END             reduce using rule 63 (type_cycle -> for .)
    ID              reduce using rule 63 (type_cycle -> for .)
    WRITELN         reduce using rule 63 (type_cycle -> for .)
    READLN          reduce using rule 63 (type_cycle -> for .)
    WHILE           reduce using rule 63 (type_cycle -> for .)
    IF              reduce using rule 63 (type_cycle -> for .)
    FOR             reduce using rule 63 (type_cycle -> for .)
    ELSE            reduce using rule 63 (type_cycle -> for .)
    PROGRAM         reduce using rule 63 (type_cycle -> for .)
    USES            reduce using rule 63 (type_cycle -> for .)
    VAR             reduce using rule 63 (type_cycle -> for .)
    FUNCTION        reduce using rule 63 (type_cycle -> for .)
    PROCEDURE       reduce using rule 63 (type_cycle -> for .)
    BEGIN           reduce using rule 63 (type_cycle -> for .)
    $end            reduce using rule 63 (type_cycle -> for .)


state 27

    (30) procedure_declaration -> BEGIN instruction . END DOT

    END             shift and go to state 64


state 28

    (31) instruction -> asignation . instruction
    (31) instruction -> . asignation instruction
    (32) instruction -> . writing instruction
    (33) instruction -> . cycles instruction
    (34) instruction -> . callFunctions instruction
    (35) instruction -> . empty
    (55) asignation -> . ID EQUAL callFunctions SEMICOLON
    (56) asignation -> . ID EQUAL math SEMICOLON
    (57) asignation -> . ID EQUAL boolean SEMICOLON
    (58) asignation -> . ID EQUAL TEXT SEMICOLON
    (49) writing -> . WRITELN LPAREN id_text_l TEXT id_text_r RPAREN SEMICOLON
    (50) writing -> . WRITELN LPAREN id_num RPAREN SEMICOLON
    (51) writing -> . READLN LPAREN ID RPAREN SEMICOLON
    (52) writing -> . READLN LPAREN RPAREN SEMICOLON
    (53) writing -> . READLN SEMICOLON
    (54) writing -> . WRITELN SEMICOLON
    (60) cycles -> . type_cycle
    (36) callFunctions -> . ID LPAREN params RPAREN
    (18) empty -> .
    (61) type_cycle -> . while
    (62) type_cycle -> . if
    (63) type_cycle -> . for
    (64) type_cycle -> . cycles instruction
    (65) while -> . WHILE internexpression op_cycle DO otherBegin
    (66) if -> . IF internexpression op_cycle THEN otherBegin_if
    (67) if -> . IF internexpression op_cycle THEN instruction_one_line
    (68) if -> . IF internexpression op_cycle THEN otherBegin_if ELSE otherBegin
    (69) if -> . IF internexpression op_cycle THEN otherBegin_if ELSE instruction_one_line
    (70) if -> . IF internexpression op_cycle THEN instruction_one_line ELSE otherBegin
    (71) if -> . IF internexpression op_cycle THEN instruction_one_line ELSE instruction_one_line
    (72) for -> . FOR asignation_for TO id_num DO otherBegin
    (73) for -> . FOR asignation_for DOWNTO id_num DO otherBegin

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WRITELN resolved as shift
  ! shift/reduce conflict for READLN resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
    ID              shift and go to state 24
    WRITELN         shift and go to state 23
    READLN          shift and go to state 29
    END             reduce using rule 18 (empty -> .)
    ELSE            reduce using rule 18 (empty -> .)
    PROGRAM         reduce using rule 18 (empty -> .)
    USES            reduce using rule 18 (empty -> .)
    VAR             reduce using rule 18 (empty -> .)
    FUNCTION        reduce using rule 18 (empty -> .)
    PROCEDURE       reduce using rule 18 (empty -> .)
    BEGIN           reduce using rule 18 (empty -> .)
    $end            reduce using rule 18 (empty -> .)
    WHILE           shift and go to state 17
    IF              shift and go to state 25
    FOR             shift and go to state 22

  ! ID              [ reduce using rule 18 (empty -> .) ]
  ! WRITELN         [ reduce using rule 18 (empty -> .) ]
  ! READLN          [ reduce using rule 18 (empty -> .) ]
  ! WHILE           [ reduce using rule 18 (empty -> .) ]
  ! IF              [ reduce using rule 18 (empty -> .) ]
  ! FOR             [ reduce using rule 18 (empty -> .) ]

    instruction                    shift and go to state 65
    if                             shift and go to state 20
    for                            shift and go to state 26
    writing                        shift and go to state 18
    callFunctions                  shift and go to state 19
    asignation                     shift and go to state 28
    type_cycle                     shift and go to state 30
    while                          shift and go to state 31
    empty                          shift and go to state 21
    cycles                         shift and go to state 32

state 29

    (51) writing -> READLN . LPAREN ID RPAREN SEMICOLON
    (52) writing -> READLN . LPAREN RPAREN SEMICOLON
    (53) writing -> READLN . SEMICOLON

    LPAREN          shift and go to state 67
    SEMICOLON       shift and go to state 66


state 30

    (60) cycles -> type_cycle .

    END             reduce using rule 60 (cycles -> type_cycle .)
    ID              reduce using rule 60 (cycles -> type_cycle .)
    WRITELN         reduce using rule 60 (cycles -> type_cycle .)
    READLN          reduce using rule 60 (cycles -> type_cycle .)
    WHILE           reduce using rule 60 (cycles -> type_cycle .)
    IF              reduce using rule 60 (cycles -> type_cycle .)
    FOR             reduce using rule 60 (cycles -> type_cycle .)
    ELSE            reduce using rule 60 (cycles -> type_cycle .)
    PROGRAM         reduce using rule 60 (cycles -> type_cycle .)
    USES            reduce using rule 60 (cycles -> type_cycle .)
    VAR             reduce using rule 60 (cycles -> type_cycle .)
    FUNCTION        reduce using rule 60 (cycles -> type_cycle .)
    PROCEDURE       reduce using rule 60 (cycles -> type_cycle .)
    BEGIN           reduce using rule 60 (cycles -> type_cycle .)
    $end            reduce using rule 60 (cycles -> type_cycle .)


state 31

    (61) type_cycle -> while .

    END             reduce using rule 61 (type_cycle -> while .)
    ID              reduce using rule 61 (type_cycle -> while .)
    WRITELN         reduce using rule 61 (type_cycle -> while .)
    READLN          reduce using rule 61 (type_cycle -> while .)
    WHILE           reduce using rule 61 (type_cycle -> while .)
    IF              reduce using rule 61 (type_cycle -> while .)
    FOR             reduce using rule 61 (type_cycle -> while .)
    ELSE            reduce using rule 61 (type_cycle -> while .)
    PROGRAM         reduce using rule 61 (type_cycle -> while .)
    USES            reduce using rule 61 (type_cycle -> while .)
    VAR             reduce using rule 61 (type_cycle -> while .)
    FUNCTION        reduce using rule 61 (type_cycle -> while .)
    PROCEDURE       reduce using rule 61 (type_cycle -> while .)
    BEGIN           reduce using rule 61 (type_cycle -> while .)
    $end            reduce using rule 61 (type_cycle -> while .)


state 32

    (33) instruction -> cycles . instruction
    (64) type_cycle -> cycles . instruction
    (31) instruction -> . asignation instruction
    (32) instruction -> . writing instruction
    (33) instruction -> . cycles instruction
    (34) instruction -> . callFunctions instruction
    (35) instruction -> . empty
    (55) asignation -> . ID EQUAL callFunctions SEMICOLON
    (56) asignation -> . ID EQUAL math SEMICOLON
    (57) asignation -> . ID EQUAL boolean SEMICOLON
    (58) asignation -> . ID EQUAL TEXT SEMICOLON
    (49) writing -> . WRITELN LPAREN id_text_l TEXT id_text_r RPAREN SEMICOLON
    (50) writing -> . WRITELN LPAREN id_num RPAREN SEMICOLON
    (51) writing -> . READLN LPAREN ID RPAREN SEMICOLON
    (52) writing -> . READLN LPAREN RPAREN SEMICOLON
    (53) writing -> . READLN SEMICOLON
    (54) writing -> . WRITELN SEMICOLON
    (60) cycles -> . type_cycle
    (36) callFunctions -> . ID LPAREN params RPAREN
    (18) empty -> .
    (61) type_cycle -> . while
    (62) type_cycle -> . if
    (63) type_cycle -> . for
    (64) type_cycle -> . cycles instruction
    (65) while -> . WHILE internexpression op_cycle DO otherBegin
    (66) if -> . IF internexpression op_cycle THEN otherBegin_if
    (67) if -> . IF internexpression op_cycle THEN instruction_one_line
    (68) if -> . IF internexpression op_cycle THEN otherBegin_if ELSE otherBegin
    (69) if -> . IF internexpression op_cycle THEN otherBegin_if ELSE instruction_one_line
    (70) if -> . IF internexpression op_cycle THEN instruction_one_line ELSE otherBegin
    (71) if -> . IF internexpression op_cycle THEN instruction_one_line ELSE instruction_one_line
    (72) for -> . FOR asignation_for TO id_num DO otherBegin
    (73) for -> . FOR asignation_for DOWNTO id_num DO otherBegin

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WRITELN resolved as shift
  ! shift/reduce conflict for READLN resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
    ID              shift and go to state 24
    WRITELN         shift and go to state 23
    READLN          shift and go to state 29
    END             reduce using rule 18 (empty -> .)
    ELSE            reduce using rule 18 (empty -> .)
    PROGRAM         reduce using rule 18 (empty -> .)
    USES            reduce using rule 18 (empty -> .)
    VAR             reduce using rule 18 (empty -> .)
    FUNCTION        reduce using rule 18 (empty -> .)
    PROCEDURE       reduce using rule 18 (empty -> .)
    BEGIN           reduce using rule 18 (empty -> .)
    $end            reduce using rule 18 (empty -> .)
    WHILE           shift and go to state 17
    IF              shift and go to state 25
    FOR             shift and go to state 22

  ! ID              [ reduce using rule 18 (empty -> .) ]
  ! WRITELN         [ reduce using rule 18 (empty -> .) ]
  ! READLN          [ reduce using rule 18 (empty -> .) ]
  ! WHILE           [ reduce using rule 18 (empty -> .) ]
  ! IF              [ reduce using rule 18 (empty -> .) ]
  ! FOR             [ reduce using rule 18 (empty -> .) ]

    instruction                    shift and go to state 68
    if                             shift and go to state 20
    for                            shift and go to state 26
    writing                        shift and go to state 18
    callFunctions                  shift and go to state 19
    asignation                     shift and go to state 28
    type_cycle                     shift and go to state 30
    while                          shift and go to state 31
    empty                          shift and go to state 21
    cycles                         shift and go to state 32

state 33

    (12) var_declaration -> VAR var_declaration_2 .

    PROGRAM         reduce using rule 12 (var_declaration -> VAR var_declaration_2 .)
    USES            reduce using rule 12 (var_declaration -> VAR var_declaration_2 .)
    VAR             reduce using rule 12 (var_declaration -> VAR var_declaration_2 .)
    FUNCTION        reduce using rule 12 (var_declaration -> VAR var_declaration_2 .)
    PROCEDURE       reduce using rule 12 (var_declaration -> VAR var_declaration_2 .)
    BEGIN           reduce using rule 12 (var_declaration -> VAR var_declaration_2 .)
    $end            reduce using rule 12 (var_declaration -> VAR var_declaration_2 .)


state 34

    (13) var_declaration_2 -> ID . var_declaration_3 COLON type_specifier SEMICOLON var_declaration_4
    (14) var_declaration_3 -> . COMMA ID var_declaration_3
    (15) var_declaration_3 -> . empty
    (18) empty -> .

    COMMA           shift and go to state 70
    COLON           reduce using rule 18 (empty -> .)

    var_declaration_3              shift and go to state 69
    empty                          shift and go to state 71

state 35

    (110) function_declaration -> PROCEDURE ID . LPAREN fun_param RPAREN SEMICOLON Begin_function
    (111) function_declaration -> PROCEDURE ID . SEMICOLON Begin_function

    LPAREN          shift and go to state 73
    SEMICOLON       shift and go to state 72


state 36

    (2) declaration_list -> declaration_list declaration .

    PROGRAM         reduce using rule 2 (declaration_list -> declaration_list declaration .)
    USES            reduce using rule 2 (declaration_list -> declaration_list declaration .)
    VAR             reduce using rule 2 (declaration_list -> declaration_list declaration .)
    FUNCTION        reduce using rule 2 (declaration_list -> declaration_list declaration .)
    PROCEDURE       reduce using rule 2 (declaration_list -> declaration_list declaration .)
    BEGIN           reduce using rule 2 (declaration_list -> declaration_list declaration .)
    $end            reduce using rule 2 (declaration_list -> declaration_list declaration .)


state 37

    (109) function_declaration -> FUNCTION ID LPAREN . fun_param RPAREN COLON type_specifier SEMICOLON Begin_function
    (112) fun_param -> . ID fun_param_2 COLON type_specifier fun_param
    (113) fun_param -> . SEMICOLON ID fun_param_2 COLON type_specifier fun_param
    (114) fun_param -> . empty
    (18) empty -> .

    ID              shift and go to state 76
    SEMICOLON       shift and go to state 74
    RPAREN          reduce using rule 18 (empty -> .)

    fun_param                      shift and go to state 75
    empty                          shift and go to state 77

state 38

    (8) header_declaration -> PROGRAM ID SEMICOLON .

    PROGRAM         reduce using rule 8 (header_declaration -> PROGRAM ID SEMICOLON .)
    USES            reduce using rule 8 (header_declaration -> PROGRAM ID SEMICOLON .)
    VAR             reduce using rule 8 (header_declaration -> PROGRAM ID SEMICOLON .)
    FUNCTION        reduce using rule 8 (header_declaration -> PROGRAM ID SEMICOLON .)
    PROCEDURE       reduce using rule 8 (header_declaration -> PROGRAM ID SEMICOLON .)
    BEGIN           reduce using rule 8 (header_declaration -> PROGRAM ID SEMICOLON .)
    $end            reduce using rule 8 (header_declaration -> PROGRAM ID SEMICOLON .)


state 39

    (10) header_declaration_3 -> COMMA . ID header_declaration_3

    ID              shift and go to state 78


state 40

    (9) header_declaration -> USES ID header_declaration_3 . SEMICOLON

    SEMICOLON       shift and go to state 79


state 41

    (11) header_declaration_3 -> empty .

    SEMICOLON       reduce using rule 11 (header_declaration_3 -> empty .)


state 42

    (76) internexpression -> parentheses .

    AND             reduce using rule 76 (internexpression -> parentheses .)
    OR              reduce using rule 76 (internexpression -> parentheses .)
    XOR             reduce using rule 76 (internexpression -> parentheses .)
    NOT             reduce using rule 76 (internexpression -> parentheses .)
    DO              reduce using rule 76 (internexpression -> parentheses .)
    THEN            reduce using rule 76 (internexpression -> parentheses .)


state 43

    (65) while -> WHILE internexpression . op_cycle DO otherBegin
    (74) op_cycle -> . op_logic internexpression op_cycle
    (75) op_cycle -> . empty
    (97) op_logic -> . AND
    (98) op_logic -> . OR
    (99) op_logic -> . XOR
    (100) op_logic -> . NOT
    (18) empty -> .

    AND             shift and go to state 80
    OR              shift and go to state 85
    XOR             shift and go to state 81
    NOT             shift and go to state 83
    DO              reduce using rule 18 (empty -> .)

    empty                          shift and go to state 86
    op_cycle                       shift and go to state 84
    op_logic                       shift and go to state 82

state 44

    (23) factor -> NUMBER .

    PLUS            reduce using rule 23 (factor -> NUMBER .)
    MINUS           reduce using rule 23 (factor -> NUMBER .)
    TIMES           reduce using rule 23 (factor -> NUMBER .)
    DIVIDE          reduce using rule 23 (factor -> NUMBER .)
    MOD             reduce using rule 23 (factor -> NUMBER .)
    AND             reduce using rule 23 (factor -> NUMBER .)
    OR              reduce using rule 23 (factor -> NUMBER .)
    XOR             reduce using rule 23 (factor -> NUMBER .)
    NOT             reduce using rule 23 (factor -> NUMBER .)
    DO              reduce using rule 23 (factor -> NUMBER .)
    THEN            reduce using rule 23 (factor -> NUMBER .)
    RPAREN          reduce using rule 23 (factor -> NUMBER .)
    ISEQUAL         reduce using rule 23 (factor -> NUMBER .)
    LESSEQUAL       reduce using rule 23 (factor -> NUMBER .)
    LESS            reduce using rule 23 (factor -> NUMBER .)
    GREATER         reduce using rule 23 (factor -> NUMBER .)
    GREATEREQUAL    reduce using rule 23 (factor -> NUMBER .)
    DEQUAL          reduce using rule 23 (factor -> NUMBER .)
    SEMICOLON       reduce using rule 23 (factor -> NUMBER .)
    COMMA           reduce using rule 23 (factor -> NUMBER .)


state 45

    (104) boolean -> FALSE .

    ISEQUAL         reduce using rule 104 (boolean -> FALSE .)
    AND             reduce using rule 104 (boolean -> FALSE .)
    OR              reduce using rule 104 (boolean -> FALSE .)
    XOR             reduce using rule 104 (boolean -> FALSE .)
    NOT             reduce using rule 104 (boolean -> FALSE .)
    DO              reduce using rule 104 (boolean -> FALSE .)
    THEN            reduce using rule 104 (boolean -> FALSE .)
    RPAREN          reduce using rule 104 (boolean -> FALSE .)
    SEMICOLON       reduce using rule 104 (boolean -> FALSE .)


state 46

    (103) boolean -> TRUE .

    ISEQUAL         reduce using rule 103 (boolean -> TRUE .)
    AND             reduce using rule 103 (boolean -> TRUE .)
    OR              reduce using rule 103 (boolean -> TRUE .)
    XOR             reduce using rule 103 (boolean -> TRUE .)
    NOT             reduce using rule 103 (boolean -> TRUE .)
    DO              reduce using rule 103 (boolean -> TRUE .)
    THEN            reduce using rule 103 (boolean -> TRUE .)
    RPAREN          reduce using rule 103 (boolean -> TRUE .)
    SEMICOLON       reduce using rule 103 (boolean -> TRUE .)


state 47

    (82) expression -> boolean . ISEQUAL math

    ISEQUAL         shift and go to state 87


state 48

    (84) expression2 -> TEXT . type_op TEXT
    (85) expression2 -> TEXT . type_op ID
    (86) type_op -> . LESSEQUAL
    (87) type_op -> . LESS
    (88) type_op -> . GREATER
    (89) type_op -> . GREATEREQUAL
    (90) type_op -> . DEQUAL
    (91) type_op -> . ISEQUAL

    LESSEQUAL       shift and go to state 94
    LESS            shift and go to state 90
    GREATER         shift and go to state 89
    GREATEREQUAL    shift and go to state 88
    DEQUAL          shift and go to state 91
    ISEQUAL         shift and go to state 92

    type_op                        shift and go to state 93

state 49

    (78) parentheses -> LPAREN . expression RPAREN
    (22) factor -> LPAREN . math RPAREN
    (79) expression -> . math type_op math
    (80) expression -> . ID
    (81) expression -> . math ISEQUAL boolean
    (82) expression -> . boolean ISEQUAL math
    (83) expression -> . expression2
    (19) math -> . factor mathi
    (103) boolean -> . TRUE
    (104) boolean -> . FALSE
    (84) expression2 -> . TEXT type_op TEXT
    (85) expression2 -> . TEXT type_op ID
    (22) factor -> . LPAREN math RPAREN
    (23) factor -> . NUMBER
    (24) factor -> . ID

    ID              shift and go to state 53
    TRUE            shift and go to state 46
    FALSE           shift and go to state 45
    TEXT            shift and go to state 48
    LPAREN          shift and go to state 95
    NUMBER          shift and go to state 44

    boolean                        shift and go to state 47
    factor                         shift and go to state 50
    expression2                    shift and go to state 51
    expression                     shift and go to state 96
    math                           shift and go to state 97

state 50

    (19) math -> factor . mathi
    (20) mathi -> . type_op_math factor mathi
    (21) mathi -> . empty
    (92) type_op_math -> . PLUS
    (93) type_op_math -> . MINUS
    (94) type_op_math -> . TIMES
    (95) type_op_math -> . DIVIDE
    (96) type_op_math -> . MOD
    (18) empty -> .

    PLUS            shift and go to state 101
    MINUS           shift and go to state 103
    TIMES           shift and go to state 100
    DIVIDE          shift and go to state 99
    MOD             shift and go to state 105
    ISEQUAL         reduce using rule 18 (empty -> .)
    LESSEQUAL       reduce using rule 18 (empty -> .)
    LESS            reduce using rule 18 (empty -> .)
    GREATER         reduce using rule 18 (empty -> .)
    GREATEREQUAL    reduce using rule 18 (empty -> .)
    DEQUAL          reduce using rule 18 (empty -> .)
    RPAREN          reduce using rule 18 (empty -> .)
    COMMA           reduce using rule 18 (empty -> .)
    SEMICOLON       reduce using rule 18 (empty -> .)
    AND             reduce using rule 18 (empty -> .)
    OR              reduce using rule 18 (empty -> .)
    XOR             reduce using rule 18 (empty -> .)
    NOT             reduce using rule 18 (empty -> .)
    DO              reduce using rule 18 (empty -> .)
    THEN            reduce using rule 18 (empty -> .)

    mathi                          shift and go to state 98
    type_op_math                   shift and go to state 102
    empty                          shift and go to state 104

state 51

    (83) expression -> expression2 .

    AND             reduce using rule 83 (expression -> expression2 .)
    OR              reduce using rule 83 (expression -> expression2 .)
    XOR             reduce using rule 83 (expression -> expression2 .)
    NOT             reduce using rule 83 (expression -> expression2 .)
    DO              reduce using rule 83 (expression -> expression2 .)
    THEN            reduce using rule 83 (expression -> expression2 .)
    RPAREN          reduce using rule 83 (expression -> expression2 .)


state 52

    (77) internexpression -> expression .

    AND             reduce using rule 77 (internexpression -> expression .)
    OR              reduce using rule 77 (internexpression -> expression .)
    XOR             reduce using rule 77 (internexpression -> expression .)
    NOT             reduce using rule 77 (internexpression -> expression .)
    DO              reduce using rule 77 (internexpression -> expression .)
    THEN            reduce using rule 77 (internexpression -> expression .)


state 53

    (80) expression -> ID .
    (24) factor -> ID .

  ! reduce/reduce conflict for RPAREN resolved using rule 24 (factor -> ID .)
    AND             reduce using rule 80 (expression -> ID .)
    OR              reduce using rule 80 (expression -> ID .)
    XOR             reduce using rule 80 (expression -> ID .)
    NOT             reduce using rule 80 (expression -> ID .)
    DO              reduce using rule 80 (expression -> ID .)
    THEN            reduce using rule 80 (expression -> ID .)
    PLUS            reduce using rule 24 (factor -> ID .)
    MINUS           reduce using rule 24 (factor -> ID .)
    TIMES           reduce using rule 24 (factor -> ID .)
    DIVIDE          reduce using rule 24 (factor -> ID .)
    MOD             reduce using rule 24 (factor -> ID .)
    ISEQUAL         reduce using rule 24 (factor -> ID .)
    LESSEQUAL       reduce using rule 24 (factor -> ID .)
    LESS            reduce using rule 24 (factor -> ID .)
    GREATER         reduce using rule 24 (factor -> ID .)
    GREATEREQUAL    reduce using rule 24 (factor -> ID .)
    DEQUAL          reduce using rule 24 (factor -> ID .)
    RPAREN          reduce using rule 24 (factor -> ID .)

  ! RPAREN          [ reduce using rule 80 (expression -> ID .) ]


state 54

    (79) expression -> math . type_op math
    (81) expression -> math . ISEQUAL boolean
    (86) type_op -> . LESSEQUAL
    (87) type_op -> . LESS
    (88) type_op -> . GREATER
    (89) type_op -> . GREATEREQUAL
    (90) type_op -> . DEQUAL
    (91) type_op -> . ISEQUAL

    ISEQUAL         shift and go to state 107
    LESSEQUAL       shift and go to state 94
    LESS            shift and go to state 90
    GREATER         shift and go to state 89
    GREATEREQUAL    shift and go to state 88
    DEQUAL          shift and go to state 91

    type_op                        shift and go to state 106

state 55

    (32) instruction -> writing instruction .

    END             reduce using rule 32 (instruction -> writing instruction .)
    ID              reduce using rule 32 (instruction -> writing instruction .)
    WRITELN         reduce using rule 32 (instruction -> writing instruction .)
    READLN          reduce using rule 32 (instruction -> writing instruction .)
    WHILE           reduce using rule 32 (instruction -> writing instruction .)
    IF              reduce using rule 32 (instruction -> writing instruction .)
    FOR             reduce using rule 32 (instruction -> writing instruction .)
    ELSE            reduce using rule 32 (instruction -> writing instruction .)
    PROGRAM         reduce using rule 32 (instruction -> writing instruction .)
    USES            reduce using rule 32 (instruction -> writing instruction .)
    VAR             reduce using rule 32 (instruction -> writing instruction .)
    FUNCTION        reduce using rule 32 (instruction -> writing instruction .)
    PROCEDURE       reduce using rule 32 (instruction -> writing instruction .)
    BEGIN           reduce using rule 32 (instruction -> writing instruction .)
    $end            reduce using rule 32 (instruction -> writing instruction .)


state 56

    (34) instruction -> callFunctions instruction .

    END             reduce using rule 34 (instruction -> callFunctions instruction .)
    ID              reduce using rule 34 (instruction -> callFunctions instruction .)
    WRITELN         reduce using rule 34 (instruction -> callFunctions instruction .)
    READLN          reduce using rule 34 (instruction -> callFunctions instruction .)
    WHILE           reduce using rule 34 (instruction -> callFunctions instruction .)
    IF              reduce using rule 34 (instruction -> callFunctions instruction .)
    FOR             reduce using rule 34 (instruction -> callFunctions instruction .)
    ELSE            reduce using rule 34 (instruction -> callFunctions instruction .)
    PROGRAM         reduce using rule 34 (instruction -> callFunctions instruction .)
    USES            reduce using rule 34 (instruction -> callFunctions instruction .)
    VAR             reduce using rule 34 (instruction -> callFunctions instruction .)
    FUNCTION        reduce using rule 34 (instruction -> callFunctions instruction .)
    PROCEDURE       reduce using rule 34 (instruction -> callFunctions instruction .)
    BEGIN           reduce using rule 34 (instruction -> callFunctions instruction .)
    $end            reduce using rule 34 (instruction -> callFunctions instruction .)


state 57

    (72) for -> FOR asignation_for . TO id_num DO otherBegin
    (73) for -> FOR asignation_for . DOWNTO id_num DO otherBegin

    TO              shift and go to state 109
    DOWNTO          shift and go to state 108


state 58

    (59) asignation_for -> ID . EQUAL id_num

    EQUAL           shift and go to state 110


state 59

    (54) writing -> WRITELN SEMICOLON .

    ID              reduce using rule 54 (writing -> WRITELN SEMICOLON .)
    WRITELN         reduce using rule 54 (writing -> WRITELN SEMICOLON .)
    READLN          reduce using rule 54 (writing -> WRITELN SEMICOLON .)
    WHILE           reduce using rule 54 (writing -> WRITELN SEMICOLON .)
    IF              reduce using rule 54 (writing -> WRITELN SEMICOLON .)
    FOR             reduce using rule 54 (writing -> WRITELN SEMICOLON .)
    PROGRAM         reduce using rule 54 (writing -> WRITELN SEMICOLON .)
    USES            reduce using rule 54 (writing -> WRITELN SEMICOLON .)
    VAR             reduce using rule 54 (writing -> WRITELN SEMICOLON .)
    FUNCTION        reduce using rule 54 (writing -> WRITELN SEMICOLON .)
    PROCEDURE       reduce using rule 54 (writing -> WRITELN SEMICOLON .)
    BEGIN           reduce using rule 54 (writing -> WRITELN SEMICOLON .)
    $end            reduce using rule 54 (writing -> WRITELN SEMICOLON .)
    END             reduce using rule 54 (writing -> WRITELN SEMICOLON .)
    ELSE            reduce using rule 54 (writing -> WRITELN SEMICOLON .)


state 60

    (49) writing -> WRITELN LPAREN . id_text_l TEXT id_text_r RPAREN SEMICOLON
    (50) writing -> WRITELN LPAREN . id_num RPAREN SEMICOLON
    (43) id_text_l -> . callFunctions COMMA id_text_l
    (44) id_text_l -> . ID COMMA id_text_l
    (45) id_text_l -> . empty
    (101) id_num -> . NUMBER
    (102) id_num -> . ID
    (36) callFunctions -> . ID LPAREN params RPAREN
    (18) empty -> .

    ID              shift and go to state 115
    NUMBER          shift and go to state 114
    TEXT            reduce using rule 18 (empty -> .)

    id_text_l                      shift and go to state 112
    id_num                         shift and go to state 113
    callFunctions                  shift and go to state 111
    empty                          shift and go to state 116

state 61

    (36) callFunctions -> ID LPAREN . params RPAREN
    (37) params -> . math params2
    (19) math -> . factor mathi
    (22) factor -> . LPAREN math RPAREN
    (23) factor -> . NUMBER
    (24) factor -> . ID

    LPAREN          shift and go to state 95
    NUMBER          shift and go to state 44
    ID              shift and go to state 118

    params                         shift and go to state 117
    math                           shift and go to state 119
    factor                         shift and go to state 50

state 62

    (55) asignation -> ID EQUAL . callFunctions SEMICOLON
    (56) asignation -> ID EQUAL . math SEMICOLON
    (57) asignation -> ID EQUAL . boolean SEMICOLON
    (58) asignation -> ID EQUAL . TEXT SEMICOLON
    (36) callFunctions -> . ID LPAREN params RPAREN
    (19) math -> . factor mathi
    (103) boolean -> . TRUE
    (104) boolean -> . FALSE
    (22) factor -> . LPAREN math RPAREN
    (23) factor -> . NUMBER
    (24) factor -> . ID

    TEXT            shift and go to state 120
    ID              shift and go to state 123
    TRUE            shift and go to state 46
    FALSE           shift and go to state 45
    LPAREN          shift and go to state 95
    NUMBER          shift and go to state 44

    boolean                        shift and go to state 121
    callFunctions                  shift and go to state 122
    factor                         shift and go to state 50
    math                           shift and go to state 124

state 63

    (66) if -> IF internexpression . op_cycle THEN otherBegin_if
    (67) if -> IF internexpression . op_cycle THEN instruction_one_line
    (68) if -> IF internexpression . op_cycle THEN otherBegin_if ELSE otherBegin
    (69) if -> IF internexpression . op_cycle THEN otherBegin_if ELSE instruction_one_line
    (70) if -> IF internexpression . op_cycle THEN instruction_one_line ELSE otherBegin
    (71) if -> IF internexpression . op_cycle THEN instruction_one_line ELSE instruction_one_line
    (74) op_cycle -> . op_logic internexpression op_cycle
    (75) op_cycle -> . empty
    (97) op_logic -> . AND
    (98) op_logic -> . OR
    (99) op_logic -> . XOR
    (100) op_logic -> . NOT
    (18) empty -> .

    AND             shift and go to state 80
    OR              shift and go to state 85
    XOR             shift and go to state 81
    NOT             shift and go to state 83
    THEN            reduce using rule 18 (empty -> .)

    op_logic                       shift and go to state 82
    op_cycle                       shift and go to state 125
    empty                          shift and go to state 86

state 64

    (30) procedure_declaration -> BEGIN instruction END . DOT

    DOT             shift and go to state 126


state 65

    (31) instruction -> asignation instruction .

    END             reduce using rule 31 (instruction -> asignation instruction .)
    ID              reduce using rule 31 (instruction -> asignation instruction .)
    WRITELN         reduce using rule 31 (instruction -> asignation instruction .)
    READLN          reduce using rule 31 (instruction -> asignation instruction .)
    WHILE           reduce using rule 31 (instruction -> asignation instruction .)
    IF              reduce using rule 31 (instruction -> asignation instruction .)
    FOR             reduce using rule 31 (instruction -> asignation instruction .)
    ELSE            reduce using rule 31 (instruction -> asignation instruction .)
    PROGRAM         reduce using rule 31 (instruction -> asignation instruction .)
    USES            reduce using rule 31 (instruction -> asignation instruction .)
    VAR             reduce using rule 31 (instruction -> asignation instruction .)
    FUNCTION        reduce using rule 31 (instruction -> asignation instruction .)
    PROCEDURE       reduce using rule 31 (instruction -> asignation instruction .)
    BEGIN           reduce using rule 31 (instruction -> asignation instruction .)
    $end            reduce using rule 31 (instruction -> asignation instruction .)


state 66

    (53) writing -> READLN SEMICOLON .

    ID              reduce using rule 53 (writing -> READLN SEMICOLON .)
    WRITELN         reduce using rule 53 (writing -> READLN SEMICOLON .)
    READLN          reduce using rule 53 (writing -> READLN SEMICOLON .)
    WHILE           reduce using rule 53 (writing -> READLN SEMICOLON .)
    IF              reduce using rule 53 (writing -> READLN SEMICOLON .)
    FOR             reduce using rule 53 (writing -> READLN SEMICOLON .)
    PROGRAM         reduce using rule 53 (writing -> READLN SEMICOLON .)
    USES            reduce using rule 53 (writing -> READLN SEMICOLON .)
    VAR             reduce using rule 53 (writing -> READLN SEMICOLON .)
    FUNCTION        reduce using rule 53 (writing -> READLN SEMICOLON .)
    PROCEDURE       reduce using rule 53 (writing -> READLN SEMICOLON .)
    BEGIN           reduce using rule 53 (writing -> READLN SEMICOLON .)
    $end            reduce using rule 53 (writing -> READLN SEMICOLON .)
    END             reduce using rule 53 (writing -> READLN SEMICOLON .)
    ELSE            reduce using rule 53 (writing -> READLN SEMICOLON .)


state 67

    (51) writing -> READLN LPAREN . ID RPAREN SEMICOLON
    (52) writing -> READLN LPAREN . RPAREN SEMICOLON

    ID              shift and go to state 128
    RPAREN          shift and go to state 127


state 68

    (33) instruction -> cycles instruction .
    (64) type_cycle -> cycles instruction .

  ! reduce/reduce conflict for END resolved using rule 33 (instruction -> cycles instruction .)
  ! reduce/reduce conflict for ID resolved using rule 33 (instruction -> cycles instruction .)
  ! reduce/reduce conflict for WRITELN resolved using rule 33 (instruction -> cycles instruction .)
  ! reduce/reduce conflict for READLN resolved using rule 33 (instruction -> cycles instruction .)
  ! reduce/reduce conflict for WHILE resolved using rule 33 (instruction -> cycles instruction .)
  ! reduce/reduce conflict for IF resolved using rule 33 (instruction -> cycles instruction .)
  ! reduce/reduce conflict for FOR resolved using rule 33 (instruction -> cycles instruction .)
  ! reduce/reduce conflict for ELSE resolved using rule 33 (instruction -> cycles instruction .)
  ! reduce/reduce conflict for PROGRAM resolved using rule 33 (instruction -> cycles instruction .)
  ! reduce/reduce conflict for USES resolved using rule 33 (instruction -> cycles instruction .)
  ! reduce/reduce conflict for VAR resolved using rule 33 (instruction -> cycles instruction .)
  ! reduce/reduce conflict for FUNCTION resolved using rule 33 (instruction -> cycles instruction .)
  ! reduce/reduce conflict for PROCEDURE resolved using rule 33 (instruction -> cycles instruction .)
  ! reduce/reduce conflict for BEGIN resolved using rule 33 (instruction -> cycles instruction .)
  ! reduce/reduce conflict for $end resolved using rule 33 (instruction -> cycles instruction .)
    END             reduce using rule 33 (instruction -> cycles instruction .)
    ID              reduce using rule 33 (instruction -> cycles instruction .)
    WRITELN         reduce using rule 33 (instruction -> cycles instruction .)
    READLN          reduce using rule 33 (instruction -> cycles instruction .)
    WHILE           reduce using rule 33 (instruction -> cycles instruction .)
    IF              reduce using rule 33 (instruction -> cycles instruction .)
    FOR             reduce using rule 33 (instruction -> cycles instruction .)
    ELSE            reduce using rule 33 (instruction -> cycles instruction .)
    PROGRAM         reduce using rule 33 (instruction -> cycles instruction .)
    USES            reduce using rule 33 (instruction -> cycles instruction .)
    VAR             reduce using rule 33 (instruction -> cycles instruction .)
    FUNCTION        reduce using rule 33 (instruction -> cycles instruction .)
    PROCEDURE       reduce using rule 33 (instruction -> cycles instruction .)
    BEGIN           reduce using rule 33 (instruction -> cycles instruction .)
    $end            reduce using rule 33 (instruction -> cycles instruction .)

  ! END             [ reduce using rule 64 (type_cycle -> cycles instruction .) ]
  ! ID              [ reduce using rule 64 (type_cycle -> cycles instruction .) ]
  ! WRITELN         [ reduce using rule 64 (type_cycle -> cycles instruction .) ]
  ! READLN          [ reduce using rule 64 (type_cycle -> cycles instruction .) ]
  ! WHILE           [ reduce using rule 64 (type_cycle -> cycles instruction .) ]
  ! IF              [ reduce using rule 64 (type_cycle -> cycles instruction .) ]
  ! FOR             [ reduce using rule 64 (type_cycle -> cycles instruction .) ]
  ! ELSE            [ reduce using rule 64 (type_cycle -> cycles instruction .) ]
  ! PROGRAM         [ reduce using rule 64 (type_cycle -> cycles instruction .) ]
  ! USES            [ reduce using rule 64 (type_cycle -> cycles instruction .) ]
  ! VAR             [ reduce using rule 64 (type_cycle -> cycles instruction .) ]
  ! FUNCTION        [ reduce using rule 64 (type_cycle -> cycles instruction .) ]
  ! PROCEDURE       [ reduce using rule 64 (type_cycle -> cycles instruction .) ]
  ! BEGIN           [ reduce using rule 64 (type_cycle -> cycles instruction .) ]
  ! $end            [ reduce using rule 64 (type_cycle -> cycles instruction .) ]


state 69

    (13) var_declaration_2 -> ID var_declaration_3 . COLON type_specifier SEMICOLON var_declaration_4

    COLON           shift and go to state 129


state 70

    (14) var_declaration_3 -> COMMA . ID var_declaration_3

    ID              shift and go to state 130


state 71

    (15) var_declaration_3 -> empty .

    COLON           reduce using rule 15 (var_declaration_3 -> empty .)


state 72

    (111) function_declaration -> PROCEDURE ID SEMICOLON . Begin_function
    (107) Begin_function -> . var_declaration BEGIN instruction END SEMICOLON instruction
    (108) Begin_function -> . BEGIN instruction END SEMICOLON instruction
    (12) var_declaration -> . VAR var_declaration_2

    BEGIN           shift and go to state 131
    VAR             shift and go to state 9

    Begin_function                 shift and go to state 133
    var_declaration                shift and go to state 132

state 73

    (110) function_declaration -> PROCEDURE ID LPAREN . fun_param RPAREN SEMICOLON Begin_function
    (112) fun_param -> . ID fun_param_2 COLON type_specifier fun_param
    (113) fun_param -> . SEMICOLON ID fun_param_2 COLON type_specifier fun_param
    (114) fun_param -> . empty
    (18) empty -> .

    ID              shift and go to state 76
    SEMICOLON       shift and go to state 74
    RPAREN          reduce using rule 18 (empty -> .)

    fun_param                      shift and go to state 134
    empty                          shift and go to state 77

state 74

    (113) fun_param -> SEMICOLON . ID fun_param_2 COLON type_specifier fun_param

    ID              shift and go to state 135


state 75

    (109) function_declaration -> FUNCTION ID LPAREN fun_param . RPAREN COLON type_specifier SEMICOLON Begin_function

    RPAREN          shift and go to state 136


state 76

    (112) fun_param -> ID . fun_param_2 COLON type_specifier fun_param
    (115) fun_param_2 -> . COMMA ID fun_param_2
    (116) fun_param_2 -> . empty
    (18) empty -> .

    COMMA           shift and go to state 138
    COLON           reduce using rule 18 (empty -> .)

    fun_param_2                    shift and go to state 137
    empty                          shift and go to state 139

state 77

    (114) fun_param -> empty .

    RPAREN          reduce using rule 114 (fun_param -> empty .)


state 78

    (10) header_declaration_3 -> COMMA ID . header_declaration_3
    (10) header_declaration_3 -> . COMMA ID header_declaration_3
    (11) header_declaration_3 -> . empty
    (18) empty -> .

    COMMA           shift and go to state 39
    SEMICOLON       reduce using rule 18 (empty -> .)

    header_declaration_3           shift and go to state 140
    empty                          shift and go to state 41

state 79

    (9) header_declaration -> USES ID header_declaration_3 SEMICOLON .

    PROGRAM         reduce using rule 9 (header_declaration -> USES ID header_declaration_3 SEMICOLON .)
    USES            reduce using rule 9 (header_declaration -> USES ID header_declaration_3 SEMICOLON .)
    VAR             reduce using rule 9 (header_declaration -> USES ID header_declaration_3 SEMICOLON .)
    FUNCTION        reduce using rule 9 (header_declaration -> USES ID header_declaration_3 SEMICOLON .)
    PROCEDURE       reduce using rule 9 (header_declaration -> USES ID header_declaration_3 SEMICOLON .)
    BEGIN           reduce using rule 9 (header_declaration -> USES ID header_declaration_3 SEMICOLON .)
    $end            reduce using rule 9 (header_declaration -> USES ID header_declaration_3 SEMICOLON .)


state 80

    (97) op_logic -> AND .

    LPAREN          reduce using rule 97 (op_logic -> AND .)
    ID              reduce using rule 97 (op_logic -> AND .)
    TRUE            reduce using rule 97 (op_logic -> AND .)
    FALSE           reduce using rule 97 (op_logic -> AND .)
    TEXT            reduce using rule 97 (op_logic -> AND .)
    NUMBER          reduce using rule 97 (op_logic -> AND .)


state 81

    (99) op_logic -> XOR .

    LPAREN          reduce using rule 99 (op_logic -> XOR .)
    ID              reduce using rule 99 (op_logic -> XOR .)
    TRUE            reduce using rule 99 (op_logic -> XOR .)
    FALSE           reduce using rule 99 (op_logic -> XOR .)
    TEXT            reduce using rule 99 (op_logic -> XOR .)
    NUMBER          reduce using rule 99 (op_logic -> XOR .)


state 82

    (74) op_cycle -> op_logic . internexpression op_cycle
    (76) internexpression -> . parentheses
    (77) internexpression -> . expression
    (78) parentheses -> . LPAREN expression RPAREN
    (79) expression -> . math type_op math
    (80) expression -> . ID
    (81) expression -> . math ISEQUAL boolean
    (82) expression -> . boolean ISEQUAL math
    (83) expression -> . expression2
    (19) math -> . factor mathi
    (103) boolean -> . TRUE
    (104) boolean -> . FALSE
    (84) expression2 -> . TEXT type_op TEXT
    (85) expression2 -> . TEXT type_op ID
    (22) factor -> . LPAREN math RPAREN
    (23) factor -> . NUMBER
    (24) factor -> . ID

    LPAREN          shift and go to state 49
    ID              shift and go to state 53
    TRUE            shift and go to state 46
    FALSE           shift and go to state 45
    TEXT            shift and go to state 48
    NUMBER          shift and go to state 44

    parentheses                    shift and go to state 42
    internexpression               shift and go to state 141
    boolean                        shift and go to state 47
    factor                         shift and go to state 50
    expression2                    shift and go to state 51
    expression                     shift and go to state 52
    math                           shift and go to state 54

state 83

    (100) op_logic -> NOT .

    LPAREN          reduce using rule 100 (op_logic -> NOT .)
    ID              reduce using rule 100 (op_logic -> NOT .)
    TRUE            reduce using rule 100 (op_logic -> NOT .)
    FALSE           reduce using rule 100 (op_logic -> NOT .)
    TEXT            reduce using rule 100 (op_logic -> NOT .)
    NUMBER          reduce using rule 100 (op_logic -> NOT .)


state 84

    (65) while -> WHILE internexpression op_cycle . DO otherBegin

    DO              shift and go to state 142


state 85

    (98) op_logic -> OR .

    LPAREN          reduce using rule 98 (op_logic -> OR .)
    ID              reduce using rule 98 (op_logic -> OR .)
    TRUE            reduce using rule 98 (op_logic -> OR .)
    FALSE           reduce using rule 98 (op_logic -> OR .)
    TEXT            reduce using rule 98 (op_logic -> OR .)
    NUMBER          reduce using rule 98 (op_logic -> OR .)


state 86

    (75) op_cycle -> empty .

    DO              reduce using rule 75 (op_cycle -> empty .)
    THEN            reduce using rule 75 (op_cycle -> empty .)


state 87

    (82) expression -> boolean ISEQUAL . math
    (19) math -> . factor mathi
    (22) factor -> . LPAREN math RPAREN
    (23) factor -> . NUMBER
    (24) factor -> . ID

    LPAREN          shift and go to state 95
    NUMBER          shift and go to state 44
    ID              shift and go to state 118

    math                           shift and go to state 143
    factor                         shift and go to state 50

state 88

    (89) type_op -> GREATEREQUAL .

    LPAREN          reduce using rule 89 (type_op -> GREATEREQUAL .)
    NUMBER          reduce using rule 89 (type_op -> GREATEREQUAL .)
    ID              reduce using rule 89 (type_op -> GREATEREQUAL .)
    TEXT            reduce using rule 89 (type_op -> GREATEREQUAL .)


state 89

    (88) type_op -> GREATER .

    LPAREN          reduce using rule 88 (type_op -> GREATER .)
    NUMBER          reduce using rule 88 (type_op -> GREATER .)
    ID              reduce using rule 88 (type_op -> GREATER .)
    TEXT            reduce using rule 88 (type_op -> GREATER .)


state 90

    (87) type_op -> LESS .

    LPAREN          reduce using rule 87 (type_op -> LESS .)
    NUMBER          reduce using rule 87 (type_op -> LESS .)
    ID              reduce using rule 87 (type_op -> LESS .)
    TEXT            reduce using rule 87 (type_op -> LESS .)


state 91

    (90) type_op -> DEQUAL .

    LPAREN          reduce using rule 90 (type_op -> DEQUAL .)
    NUMBER          reduce using rule 90 (type_op -> DEQUAL .)
    ID              reduce using rule 90 (type_op -> DEQUAL .)
    TEXT            reduce using rule 90 (type_op -> DEQUAL .)


state 92

    (91) type_op -> ISEQUAL .

    TEXT            reduce using rule 91 (type_op -> ISEQUAL .)
    ID              reduce using rule 91 (type_op -> ISEQUAL .)


state 93

    (84) expression2 -> TEXT type_op . TEXT
    (85) expression2 -> TEXT type_op . ID

    TEXT            shift and go to state 144
    ID              shift and go to state 145


state 94

    (86) type_op -> LESSEQUAL .

    LPAREN          reduce using rule 86 (type_op -> LESSEQUAL .)
    NUMBER          reduce using rule 86 (type_op -> LESSEQUAL .)
    ID              reduce using rule 86 (type_op -> LESSEQUAL .)
    TEXT            reduce using rule 86 (type_op -> LESSEQUAL .)


state 95

    (22) factor -> LPAREN . math RPAREN
    (19) math -> . factor mathi
    (22) factor -> . LPAREN math RPAREN
    (23) factor -> . NUMBER
    (24) factor -> . ID

    LPAREN          shift and go to state 95
    NUMBER          shift and go to state 44
    ID              shift and go to state 118

    math                           shift and go to state 146
    factor                         shift and go to state 50

state 96

    (78) parentheses -> LPAREN expression . RPAREN

    RPAREN          shift and go to state 147


state 97

    (22) factor -> LPAREN math . RPAREN
    (79) expression -> math . type_op math
    (81) expression -> math . ISEQUAL boolean
    (86) type_op -> . LESSEQUAL
    (87) type_op -> . LESS
    (88) type_op -> . GREATER
    (89) type_op -> . GREATEREQUAL
    (90) type_op -> . DEQUAL
    (91) type_op -> . ISEQUAL

    RPAREN          shift and go to state 148
    ISEQUAL         shift and go to state 107
    LESSEQUAL       shift and go to state 94
    LESS            shift and go to state 90
    GREATER         shift and go to state 89
    GREATEREQUAL    shift and go to state 88
    DEQUAL          shift and go to state 91

    type_op                        shift and go to state 106

state 98

    (19) math -> factor mathi .

    AND             reduce using rule 19 (math -> factor mathi .)
    OR              reduce using rule 19 (math -> factor mathi .)
    XOR             reduce using rule 19 (math -> factor mathi .)
    NOT             reduce using rule 19 (math -> factor mathi .)
    DO              reduce using rule 19 (math -> factor mathi .)
    THEN            reduce using rule 19 (math -> factor mathi .)
    RPAREN          reduce using rule 19 (math -> factor mathi .)
    ISEQUAL         reduce using rule 19 (math -> factor mathi .)
    LESSEQUAL       reduce using rule 19 (math -> factor mathi .)
    LESS            reduce using rule 19 (math -> factor mathi .)
    GREATER         reduce using rule 19 (math -> factor mathi .)
    GREATEREQUAL    reduce using rule 19 (math -> factor mathi .)
    DEQUAL          reduce using rule 19 (math -> factor mathi .)
    COMMA           reduce using rule 19 (math -> factor mathi .)
    SEMICOLON       reduce using rule 19 (math -> factor mathi .)


state 99

    (95) type_op_math -> DIVIDE .

    LPAREN          reduce using rule 95 (type_op_math -> DIVIDE .)
    NUMBER          reduce using rule 95 (type_op_math -> DIVIDE .)
    ID              reduce using rule 95 (type_op_math -> DIVIDE .)


state 100

    (94) type_op_math -> TIMES .

    LPAREN          reduce using rule 94 (type_op_math -> TIMES .)
    NUMBER          reduce using rule 94 (type_op_math -> TIMES .)
    ID              reduce using rule 94 (type_op_math -> TIMES .)


state 101

    (92) type_op_math -> PLUS .

    LPAREN          reduce using rule 92 (type_op_math -> PLUS .)
    NUMBER          reduce using rule 92 (type_op_math -> PLUS .)
    ID              reduce using rule 92 (type_op_math -> PLUS .)


state 102

    (20) mathi -> type_op_math . factor mathi
    (22) factor -> . LPAREN math RPAREN
    (23) factor -> . NUMBER
    (24) factor -> . ID

    LPAREN          shift and go to state 95
    NUMBER          shift and go to state 44
    ID              shift and go to state 118

    factor                         shift and go to state 149

state 103

    (93) type_op_math -> MINUS .

    LPAREN          reduce using rule 93 (type_op_math -> MINUS .)
    NUMBER          reduce using rule 93 (type_op_math -> MINUS .)
    ID              reduce using rule 93 (type_op_math -> MINUS .)


state 104

    (21) mathi -> empty .

    ISEQUAL         reduce using rule 21 (mathi -> empty .)
    LESSEQUAL       reduce using rule 21 (mathi -> empty .)
    LESS            reduce using rule 21 (mathi -> empty .)
    GREATER         reduce using rule 21 (mathi -> empty .)
    GREATEREQUAL    reduce using rule 21 (mathi -> empty .)
    DEQUAL          reduce using rule 21 (mathi -> empty .)
    RPAREN          reduce using rule 21 (mathi -> empty .)
    COMMA           reduce using rule 21 (mathi -> empty .)
    SEMICOLON       reduce using rule 21 (mathi -> empty .)
    AND             reduce using rule 21 (mathi -> empty .)
    OR              reduce using rule 21 (mathi -> empty .)
    XOR             reduce using rule 21 (mathi -> empty .)
    NOT             reduce using rule 21 (mathi -> empty .)
    DO              reduce using rule 21 (mathi -> empty .)
    THEN            reduce using rule 21 (mathi -> empty .)


state 105

    (96) type_op_math -> MOD .

    LPAREN          reduce using rule 96 (type_op_math -> MOD .)
    NUMBER          reduce using rule 96 (type_op_math -> MOD .)
    ID              reduce using rule 96 (type_op_math -> MOD .)


state 106

    (79) expression -> math type_op . math
    (19) math -> . factor mathi
    (22) factor -> . LPAREN math RPAREN
    (23) factor -> . NUMBER
    (24) factor -> . ID

    LPAREN          shift and go to state 95
    NUMBER          shift and go to state 44
    ID              shift and go to state 118

    math                           shift and go to state 150
    factor                         shift and go to state 50

state 107

    (81) expression -> math ISEQUAL . boolean
    (91) type_op -> ISEQUAL .
    (103) boolean -> . TRUE
    (104) boolean -> . FALSE

    LPAREN          reduce using rule 91 (type_op -> ISEQUAL .)
    NUMBER          reduce using rule 91 (type_op -> ISEQUAL .)
    ID              reduce using rule 91 (type_op -> ISEQUAL .)
    TRUE            shift and go to state 46
    FALSE           shift and go to state 45

    boolean                        shift and go to state 151

state 108

    (73) for -> FOR asignation_for DOWNTO . id_num DO otherBegin
    (101) id_num -> . NUMBER
    (102) id_num -> . ID

    NUMBER          shift and go to state 114
    ID              shift and go to state 153

    id_num                         shift and go to state 152

state 109

    (72) for -> FOR asignation_for TO . id_num DO otherBegin
    (101) id_num -> . NUMBER
    (102) id_num -> . ID

    NUMBER          shift and go to state 114
    ID              shift and go to state 153

    id_num                         shift and go to state 154

state 110

    (59) asignation_for -> ID EQUAL . id_num
    (101) id_num -> . NUMBER
    (102) id_num -> . ID

    NUMBER          shift and go to state 114
    ID              shift and go to state 153

    id_num                         shift and go to state 155

state 111

    (43) id_text_l -> callFunctions . COMMA id_text_l

    COMMA           shift and go to state 156


state 112

    (49) writing -> WRITELN LPAREN id_text_l . TEXT id_text_r RPAREN SEMICOLON

    TEXT            shift and go to state 157


state 113

    (50) writing -> WRITELN LPAREN id_num . RPAREN SEMICOLON

    RPAREN          shift and go to state 158


state 114

    (101) id_num -> NUMBER .

    DO              reduce using rule 101 (id_num -> NUMBER .)
    RPAREN          reduce using rule 101 (id_num -> NUMBER .)
    TO              reduce using rule 101 (id_num -> NUMBER .)
    DOWNTO          reduce using rule 101 (id_num -> NUMBER .)


state 115

    (44) id_text_l -> ID . COMMA id_text_l
    (102) id_num -> ID .
    (36) callFunctions -> ID . LPAREN params RPAREN

    COMMA           shift and go to state 159
    RPAREN          reduce using rule 102 (id_num -> ID .)
    LPAREN          shift and go to state 61


state 116

    (45) id_text_l -> empty .

    TEXT            reduce using rule 45 (id_text_l -> empty .)


state 117

    (36) callFunctions -> ID LPAREN params . RPAREN

    RPAREN          shift and go to state 160


state 118

    (24) factor -> ID .

    PLUS            reduce using rule 24 (factor -> ID .)
    MINUS           reduce using rule 24 (factor -> ID .)
    TIMES           reduce using rule 24 (factor -> ID .)
    DIVIDE          reduce using rule 24 (factor -> ID .)
    MOD             reduce using rule 24 (factor -> ID .)
    AND             reduce using rule 24 (factor -> ID .)
    OR              reduce using rule 24 (factor -> ID .)
    XOR             reduce using rule 24 (factor -> ID .)
    NOT             reduce using rule 24 (factor -> ID .)
    DO              reduce using rule 24 (factor -> ID .)
    THEN            reduce using rule 24 (factor -> ID .)
    RPAREN          reduce using rule 24 (factor -> ID .)
    COMMA           reduce using rule 24 (factor -> ID .)
    ISEQUAL         reduce using rule 24 (factor -> ID .)
    LESSEQUAL       reduce using rule 24 (factor -> ID .)
    LESS            reduce using rule 24 (factor -> ID .)
    GREATER         reduce using rule 24 (factor -> ID .)
    GREATEREQUAL    reduce using rule 24 (factor -> ID .)
    DEQUAL          reduce using rule 24 (factor -> ID .)
    SEMICOLON       reduce using rule 24 (factor -> ID .)


state 119

    (37) params -> math . params2
    (38) params2 -> . COMMA math
    (39) params2 -> . empty
    (18) empty -> .

    COMMA           shift and go to state 162
    RPAREN          reduce using rule 18 (empty -> .)

    params2                        shift and go to state 161
    empty                          shift and go to state 163

state 120

    (58) asignation -> ID EQUAL TEXT . SEMICOLON

    SEMICOLON       shift and go to state 164


state 121

    (57) asignation -> ID EQUAL boolean . SEMICOLON

    SEMICOLON       shift and go to state 165


state 122

    (55) asignation -> ID EQUAL callFunctions . SEMICOLON

    SEMICOLON       shift and go to state 166


state 123

    (36) callFunctions -> ID . LPAREN params RPAREN
    (24) factor -> ID .

    LPAREN          shift and go to state 61
    PLUS            reduce using rule 24 (factor -> ID .)
    MINUS           reduce using rule 24 (factor -> ID .)
    TIMES           reduce using rule 24 (factor -> ID .)
    DIVIDE          reduce using rule 24 (factor -> ID .)
    MOD             reduce using rule 24 (factor -> ID .)
    SEMICOLON       reduce using rule 24 (factor -> ID .)


state 124

    (56) asignation -> ID EQUAL math . SEMICOLON

    SEMICOLON       shift and go to state 167


state 125

    (66) if -> IF internexpression op_cycle . THEN otherBegin_if
    (67) if -> IF internexpression op_cycle . THEN instruction_one_line
    (68) if -> IF internexpression op_cycle . THEN otherBegin_if ELSE otherBegin
    (69) if -> IF internexpression op_cycle . THEN otherBegin_if ELSE instruction_one_line
    (70) if -> IF internexpression op_cycle . THEN instruction_one_line ELSE otherBegin
    (71) if -> IF internexpression op_cycle . THEN instruction_one_line ELSE instruction_one_line

    THEN            shift and go to state 168


state 126

    (30) procedure_declaration -> BEGIN instruction END DOT .

    PROGRAM         reduce using rule 30 (procedure_declaration -> BEGIN instruction END DOT .)
    USES            reduce using rule 30 (procedure_declaration -> BEGIN instruction END DOT .)
    VAR             reduce using rule 30 (procedure_declaration -> BEGIN instruction END DOT .)
    FUNCTION        reduce using rule 30 (procedure_declaration -> BEGIN instruction END DOT .)
    PROCEDURE       reduce using rule 30 (procedure_declaration -> BEGIN instruction END DOT .)
    BEGIN           reduce using rule 30 (procedure_declaration -> BEGIN instruction END DOT .)
    $end            reduce using rule 30 (procedure_declaration -> BEGIN instruction END DOT .)


state 127

    (52) writing -> READLN LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 169


state 128

    (51) writing -> READLN LPAREN ID . RPAREN SEMICOLON

    RPAREN          shift and go to state 170


state 129

    (13) var_declaration_2 -> ID var_declaration_3 COLON . type_specifier SEMICOLON var_declaration_4
    (25) type_specifier -> . INTEGER
    (26) type_specifier -> . REAL
    (27) type_specifier -> . CHAR
    (28) type_specifier -> . BOOLEAN
    (29) type_specifier -> . DOUBLE

    INTEGER         shift and go to state 176
    REAL            shift and go to state 171
    CHAR            shift and go to state 174
    BOOLEAN         shift and go to state 175
    DOUBLE          shift and go to state 173

    type_specifier                 shift and go to state 172

state 130

    (14) var_declaration_3 -> COMMA ID . var_declaration_3
    (14) var_declaration_3 -> . COMMA ID var_declaration_3
    (15) var_declaration_3 -> . empty
    (18) empty -> .

    COMMA           shift and go to state 70
    COLON           reduce using rule 18 (empty -> .)

    var_declaration_3              shift and go to state 177
    empty                          shift and go to state 71

state 131

    (108) Begin_function -> BEGIN . instruction END SEMICOLON instruction
    (31) instruction -> . asignation instruction
    (32) instruction -> . writing instruction
    (33) instruction -> . cycles instruction
    (34) instruction -> . callFunctions instruction
    (35) instruction -> . empty
    (55) asignation -> . ID EQUAL callFunctions SEMICOLON
    (56) asignation -> . ID EQUAL math SEMICOLON
    (57) asignation -> . ID EQUAL boolean SEMICOLON
    (58) asignation -> . ID EQUAL TEXT SEMICOLON
    (49) writing -> . WRITELN LPAREN id_text_l TEXT id_text_r RPAREN SEMICOLON
    (50) writing -> . WRITELN LPAREN id_num RPAREN SEMICOLON
    (51) writing -> . READLN LPAREN ID RPAREN SEMICOLON
    (52) writing -> . READLN LPAREN RPAREN SEMICOLON
    (53) writing -> . READLN SEMICOLON
    (54) writing -> . WRITELN SEMICOLON
    (60) cycles -> . type_cycle
    (36) callFunctions -> . ID LPAREN params RPAREN
    (18) empty -> .
    (61) type_cycle -> . while
    (62) type_cycle -> . if
    (63) type_cycle -> . for
    (64) type_cycle -> . cycles instruction
    (65) while -> . WHILE internexpression op_cycle DO otherBegin
    (66) if -> . IF internexpression op_cycle THEN otherBegin_if
    (67) if -> . IF internexpression op_cycle THEN instruction_one_line
    (68) if -> . IF internexpression op_cycle THEN otherBegin_if ELSE otherBegin
    (69) if -> . IF internexpression op_cycle THEN otherBegin_if ELSE instruction_one_line
    (70) if -> . IF internexpression op_cycle THEN instruction_one_line ELSE otherBegin
    (71) if -> . IF internexpression op_cycle THEN instruction_one_line ELSE instruction_one_line
    (72) for -> . FOR asignation_for TO id_num DO otherBegin
    (73) for -> . FOR asignation_for DOWNTO id_num DO otherBegin

    ID              shift and go to state 24
    WRITELN         shift and go to state 23
    READLN          shift and go to state 29
    END             reduce using rule 18 (empty -> .)
    WHILE           shift and go to state 17
    IF              shift and go to state 25
    FOR             shift and go to state 22

    instruction                    shift and go to state 178
    if                             shift and go to state 20
    for                            shift and go to state 26
    writing                        shift and go to state 18
    callFunctions                  shift and go to state 19
    asignation                     shift and go to state 28
    type_cycle                     shift and go to state 30
    while                          shift and go to state 31
    empty                          shift and go to state 21
    cycles                         shift and go to state 32

state 132

    (107) Begin_function -> var_declaration . BEGIN instruction END SEMICOLON instruction

    BEGIN           shift and go to state 179


state 133

    (111) function_declaration -> PROCEDURE ID SEMICOLON Begin_function .

    PROGRAM         reduce using rule 111 (function_declaration -> PROCEDURE ID SEMICOLON Begin_function .)
    USES            reduce using rule 111 (function_declaration -> PROCEDURE ID SEMICOLON Begin_function .)
    VAR             reduce using rule 111 (function_declaration -> PROCEDURE ID SEMICOLON Begin_function .)
    FUNCTION        reduce using rule 111 (function_declaration -> PROCEDURE ID SEMICOLON Begin_function .)
    PROCEDURE       reduce using rule 111 (function_declaration -> PROCEDURE ID SEMICOLON Begin_function .)
    BEGIN           reduce using rule 111 (function_declaration -> PROCEDURE ID SEMICOLON Begin_function .)
    $end            reduce using rule 111 (function_declaration -> PROCEDURE ID SEMICOLON Begin_function .)


state 134

    (110) function_declaration -> PROCEDURE ID LPAREN fun_param . RPAREN SEMICOLON Begin_function

    RPAREN          shift and go to state 180


state 135

    (113) fun_param -> SEMICOLON ID . fun_param_2 COLON type_specifier fun_param
    (115) fun_param_2 -> . COMMA ID fun_param_2
    (116) fun_param_2 -> . empty
    (18) empty -> .

    COMMA           shift and go to state 138
    COLON           reduce using rule 18 (empty -> .)

    fun_param_2                    shift and go to state 181
    empty                          shift and go to state 139

state 136

    (109) function_declaration -> FUNCTION ID LPAREN fun_param RPAREN . COLON type_specifier SEMICOLON Begin_function

    COLON           shift and go to state 182


state 137

    (112) fun_param -> ID fun_param_2 . COLON type_specifier fun_param

    COLON           shift and go to state 183


state 138

    (115) fun_param_2 -> COMMA . ID fun_param_2

    ID              shift and go to state 184


state 139

    (116) fun_param_2 -> empty .

    COLON           reduce using rule 116 (fun_param_2 -> empty .)


state 140

    (10) header_declaration_3 -> COMMA ID header_declaration_3 .

    SEMICOLON       reduce using rule 10 (header_declaration_3 -> COMMA ID header_declaration_3 .)


state 141

    (74) op_cycle -> op_logic internexpression . op_cycle
    (74) op_cycle -> . op_logic internexpression op_cycle
    (75) op_cycle -> . empty
    (97) op_logic -> . AND
    (98) op_logic -> . OR
    (99) op_logic -> . XOR
    (100) op_logic -> . NOT
    (18) empty -> .

    AND             shift and go to state 80
    OR              shift and go to state 85
    XOR             shift and go to state 81
    NOT             shift and go to state 83
    DO              reduce using rule 18 (empty -> .)
    THEN            reduce using rule 18 (empty -> .)

    op_logic                       shift and go to state 82
    op_cycle                       shift and go to state 185
    empty                          shift and go to state 86

state 142

    (65) while -> WHILE internexpression op_cycle DO . otherBegin
    (105) otherBegin -> . BEGIN instruction END SEMICOLON instruction

    BEGIN           shift and go to state 186

    otherBegin                     shift and go to state 187

state 143

    (82) expression -> boolean ISEQUAL math .

    AND             reduce using rule 82 (expression -> boolean ISEQUAL math .)
    OR              reduce using rule 82 (expression -> boolean ISEQUAL math .)
    XOR             reduce using rule 82 (expression -> boolean ISEQUAL math .)
    NOT             reduce using rule 82 (expression -> boolean ISEQUAL math .)
    DO              reduce using rule 82 (expression -> boolean ISEQUAL math .)
    THEN            reduce using rule 82 (expression -> boolean ISEQUAL math .)
    RPAREN          reduce using rule 82 (expression -> boolean ISEQUAL math .)


state 144

    (84) expression2 -> TEXT type_op TEXT .

    AND             reduce using rule 84 (expression2 -> TEXT type_op TEXT .)
    OR              reduce using rule 84 (expression2 -> TEXT type_op TEXT .)
    XOR             reduce using rule 84 (expression2 -> TEXT type_op TEXT .)
    NOT             reduce using rule 84 (expression2 -> TEXT type_op TEXT .)
    DO              reduce using rule 84 (expression2 -> TEXT type_op TEXT .)
    THEN            reduce using rule 84 (expression2 -> TEXT type_op TEXT .)
    RPAREN          reduce using rule 84 (expression2 -> TEXT type_op TEXT .)


state 145

    (85) expression2 -> TEXT type_op ID .

    AND             reduce using rule 85 (expression2 -> TEXT type_op ID .)
    OR              reduce using rule 85 (expression2 -> TEXT type_op ID .)
    XOR             reduce using rule 85 (expression2 -> TEXT type_op ID .)
    NOT             reduce using rule 85 (expression2 -> TEXT type_op ID .)
    DO              reduce using rule 85 (expression2 -> TEXT type_op ID .)
    THEN            reduce using rule 85 (expression2 -> TEXT type_op ID .)
    RPAREN          reduce using rule 85 (expression2 -> TEXT type_op ID .)


state 146

    (22) factor -> LPAREN math . RPAREN

    RPAREN          shift and go to state 148


state 147

    (78) parentheses -> LPAREN expression RPAREN .

    AND             reduce using rule 78 (parentheses -> LPAREN expression RPAREN .)
    OR              reduce using rule 78 (parentheses -> LPAREN expression RPAREN .)
    XOR             reduce using rule 78 (parentheses -> LPAREN expression RPAREN .)
    NOT             reduce using rule 78 (parentheses -> LPAREN expression RPAREN .)
    THEN            reduce using rule 78 (parentheses -> LPAREN expression RPAREN .)
    DO              reduce using rule 78 (parentheses -> LPAREN expression RPAREN .)


state 148

    (22) factor -> LPAREN math RPAREN .

    PLUS            reduce using rule 22 (factor -> LPAREN math RPAREN .)
    MINUS           reduce using rule 22 (factor -> LPAREN math RPAREN .)
    TIMES           reduce using rule 22 (factor -> LPAREN math RPAREN .)
    DIVIDE          reduce using rule 22 (factor -> LPAREN math RPAREN .)
    MOD             reduce using rule 22 (factor -> LPAREN math RPAREN .)
    AND             reduce using rule 22 (factor -> LPAREN math RPAREN .)
    OR              reduce using rule 22 (factor -> LPAREN math RPAREN .)
    XOR             reduce using rule 22 (factor -> LPAREN math RPAREN .)
    NOT             reduce using rule 22 (factor -> LPAREN math RPAREN .)
    DO              reduce using rule 22 (factor -> LPAREN math RPAREN .)
    THEN            reduce using rule 22 (factor -> LPAREN math RPAREN .)
    RPAREN          reduce using rule 22 (factor -> LPAREN math RPAREN .)
    ISEQUAL         reduce using rule 22 (factor -> LPAREN math RPAREN .)
    LESSEQUAL       reduce using rule 22 (factor -> LPAREN math RPAREN .)
    LESS            reduce using rule 22 (factor -> LPAREN math RPAREN .)
    GREATER         reduce using rule 22 (factor -> LPAREN math RPAREN .)
    GREATEREQUAL    reduce using rule 22 (factor -> LPAREN math RPAREN .)
    DEQUAL          reduce using rule 22 (factor -> LPAREN math RPAREN .)
    SEMICOLON       reduce using rule 22 (factor -> LPAREN math RPAREN .)
    COMMA           reduce using rule 22 (factor -> LPAREN math RPAREN .)


state 149

    (20) mathi -> type_op_math factor . mathi
    (20) mathi -> . type_op_math factor mathi
    (21) mathi -> . empty
    (92) type_op_math -> . PLUS
    (93) type_op_math -> . MINUS
    (94) type_op_math -> . TIMES
    (95) type_op_math -> . DIVIDE
    (96) type_op_math -> . MOD
    (18) empty -> .

    PLUS            shift and go to state 101
    MINUS           shift and go to state 103
    TIMES           shift and go to state 100
    DIVIDE          shift and go to state 99
    MOD             shift and go to state 105
    ISEQUAL         reduce using rule 18 (empty -> .)
    LESSEQUAL       reduce using rule 18 (empty -> .)
    LESS            reduce using rule 18 (empty -> .)
    GREATER         reduce using rule 18 (empty -> .)
    GREATEREQUAL    reduce using rule 18 (empty -> .)
    DEQUAL          reduce using rule 18 (empty -> .)
    RPAREN          reduce using rule 18 (empty -> .)
    COMMA           reduce using rule 18 (empty -> .)
    SEMICOLON       reduce using rule 18 (empty -> .)
    AND             reduce using rule 18 (empty -> .)
    OR              reduce using rule 18 (empty -> .)
    XOR             reduce using rule 18 (empty -> .)
    NOT             reduce using rule 18 (empty -> .)
    DO              reduce using rule 18 (empty -> .)
    THEN            reduce using rule 18 (empty -> .)

    mathi                          shift and go to state 188
    empty                          shift and go to state 104
    type_op_math                   shift and go to state 102

state 150

    (79) expression -> math type_op math .

    AND             reduce using rule 79 (expression -> math type_op math .)
    OR              reduce using rule 79 (expression -> math type_op math .)
    XOR             reduce using rule 79 (expression -> math type_op math .)
    NOT             reduce using rule 79 (expression -> math type_op math .)
    DO              reduce using rule 79 (expression -> math type_op math .)
    THEN            reduce using rule 79 (expression -> math type_op math .)
    RPAREN          reduce using rule 79 (expression -> math type_op math .)


state 151

    (81) expression -> math ISEQUAL boolean .

    AND             reduce using rule 81 (expression -> math ISEQUAL boolean .)
    OR              reduce using rule 81 (expression -> math ISEQUAL boolean .)
    XOR             reduce using rule 81 (expression -> math ISEQUAL boolean .)
    NOT             reduce using rule 81 (expression -> math ISEQUAL boolean .)
    DO              reduce using rule 81 (expression -> math ISEQUAL boolean .)
    THEN            reduce using rule 81 (expression -> math ISEQUAL boolean .)
    RPAREN          reduce using rule 81 (expression -> math ISEQUAL boolean .)


state 152

    (73) for -> FOR asignation_for DOWNTO id_num . DO otherBegin

    DO              shift and go to state 189


state 153

    (102) id_num -> ID .

    DO              reduce using rule 102 (id_num -> ID .)
    TO              reduce using rule 102 (id_num -> ID .)
    DOWNTO          reduce using rule 102 (id_num -> ID .)


state 154

    (72) for -> FOR asignation_for TO id_num . DO otherBegin

    DO              shift and go to state 190


state 155

    (59) asignation_for -> ID EQUAL id_num .

    TO              reduce using rule 59 (asignation_for -> ID EQUAL id_num .)
    DOWNTO          reduce using rule 59 (asignation_for -> ID EQUAL id_num .)


state 156

    (43) id_text_l -> callFunctions COMMA . id_text_l
    (43) id_text_l -> . callFunctions COMMA id_text_l
    (44) id_text_l -> . ID COMMA id_text_l
    (45) id_text_l -> . empty
    (36) callFunctions -> . ID LPAREN params RPAREN
    (18) empty -> .

    ID              shift and go to state 192
    TEXT            reduce using rule 18 (empty -> .)

    id_text_l                      shift and go to state 191
    empty                          shift and go to state 116
    callFunctions                  shift and go to state 111

state 157

    (49) writing -> WRITELN LPAREN id_text_l TEXT . id_text_r RPAREN SEMICOLON
    (46) id_text_r -> . COMMA callFunctions id_text_r
    (47) id_text_r -> . COMMA ID id_text_r
    (48) id_text_r -> . empty
    (18) empty -> .

    COMMA           shift and go to state 193
    RPAREN          reduce using rule 18 (empty -> .)

    empty                          shift and go to state 195
    id_text_r                      shift and go to state 194

state 158

    (50) writing -> WRITELN LPAREN id_num RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 196


state 159

    (44) id_text_l -> ID COMMA . id_text_l
    (43) id_text_l -> . callFunctions COMMA id_text_l
    (44) id_text_l -> . ID COMMA id_text_l
    (45) id_text_l -> . empty
    (36) callFunctions -> . ID LPAREN params RPAREN
    (18) empty -> .

    ID              shift and go to state 192
    TEXT            reduce using rule 18 (empty -> .)

    id_text_l                      shift and go to state 197
    empty                          shift and go to state 116
    callFunctions                  shift and go to state 111

state 160

    (36) callFunctions -> ID LPAREN params RPAREN .

    ID              reduce using rule 36 (callFunctions -> ID LPAREN params RPAREN .)
    WRITELN         reduce using rule 36 (callFunctions -> ID LPAREN params RPAREN .)
    READLN          reduce using rule 36 (callFunctions -> ID LPAREN params RPAREN .)
    WHILE           reduce using rule 36 (callFunctions -> ID LPAREN params RPAREN .)
    IF              reduce using rule 36 (callFunctions -> ID LPAREN params RPAREN .)
    FOR             reduce using rule 36 (callFunctions -> ID LPAREN params RPAREN .)
    PROGRAM         reduce using rule 36 (callFunctions -> ID LPAREN params RPAREN .)
    USES            reduce using rule 36 (callFunctions -> ID LPAREN params RPAREN .)
    VAR             reduce using rule 36 (callFunctions -> ID LPAREN params RPAREN .)
    FUNCTION        reduce using rule 36 (callFunctions -> ID LPAREN params RPAREN .)
    PROCEDURE       reduce using rule 36 (callFunctions -> ID LPAREN params RPAREN .)
    BEGIN           reduce using rule 36 (callFunctions -> ID LPAREN params RPAREN .)
    $end            reduce using rule 36 (callFunctions -> ID LPAREN params RPAREN .)
    COMMA           reduce using rule 36 (callFunctions -> ID LPAREN params RPAREN .)
    END             reduce using rule 36 (callFunctions -> ID LPAREN params RPAREN .)
    ELSE            reduce using rule 36 (callFunctions -> ID LPAREN params RPAREN .)
    SEMICOLON       reduce using rule 36 (callFunctions -> ID LPAREN params RPAREN .)
    RPAREN          reduce using rule 36 (callFunctions -> ID LPAREN params RPAREN .)


state 161

    (37) params -> math params2 .

    RPAREN          reduce using rule 37 (params -> math params2 .)


state 162

    (38) params2 -> COMMA . math
    (19) math -> . factor mathi
    (22) factor -> . LPAREN math RPAREN
    (23) factor -> . NUMBER
    (24) factor -> . ID

    LPAREN          shift and go to state 95
    NUMBER          shift and go to state 44
    ID              shift and go to state 118

    math                           shift and go to state 198
    factor                         shift and go to state 50

state 163

    (39) params2 -> empty .

    RPAREN          reduce using rule 39 (params2 -> empty .)


state 164

    (58) asignation -> ID EQUAL TEXT SEMICOLON .

    ID              reduce using rule 58 (asignation -> ID EQUAL TEXT SEMICOLON .)
    WRITELN         reduce using rule 58 (asignation -> ID EQUAL TEXT SEMICOLON .)
    READLN          reduce using rule 58 (asignation -> ID EQUAL TEXT SEMICOLON .)
    WHILE           reduce using rule 58 (asignation -> ID EQUAL TEXT SEMICOLON .)
    IF              reduce using rule 58 (asignation -> ID EQUAL TEXT SEMICOLON .)
    FOR             reduce using rule 58 (asignation -> ID EQUAL TEXT SEMICOLON .)
    END             reduce using rule 58 (asignation -> ID EQUAL TEXT SEMICOLON .)
    ELSE            reduce using rule 58 (asignation -> ID EQUAL TEXT SEMICOLON .)
    PROGRAM         reduce using rule 58 (asignation -> ID EQUAL TEXT SEMICOLON .)
    USES            reduce using rule 58 (asignation -> ID EQUAL TEXT SEMICOLON .)
    VAR             reduce using rule 58 (asignation -> ID EQUAL TEXT SEMICOLON .)
    FUNCTION        reduce using rule 58 (asignation -> ID EQUAL TEXT SEMICOLON .)
    PROCEDURE       reduce using rule 58 (asignation -> ID EQUAL TEXT SEMICOLON .)
    BEGIN           reduce using rule 58 (asignation -> ID EQUAL TEXT SEMICOLON .)
    $end            reduce using rule 58 (asignation -> ID EQUAL TEXT SEMICOLON .)


state 165

    (57) asignation -> ID EQUAL boolean SEMICOLON .

    ID              reduce using rule 57 (asignation -> ID EQUAL boolean SEMICOLON .)
    WRITELN         reduce using rule 57 (asignation -> ID EQUAL boolean SEMICOLON .)
    READLN          reduce using rule 57 (asignation -> ID EQUAL boolean SEMICOLON .)
    WHILE           reduce using rule 57 (asignation -> ID EQUAL boolean SEMICOLON .)
    IF              reduce using rule 57 (asignation -> ID EQUAL boolean SEMICOLON .)
    FOR             reduce using rule 57 (asignation -> ID EQUAL boolean SEMICOLON .)
    END             reduce using rule 57 (asignation -> ID EQUAL boolean SEMICOLON .)
    ELSE            reduce using rule 57 (asignation -> ID EQUAL boolean SEMICOLON .)
    PROGRAM         reduce using rule 57 (asignation -> ID EQUAL boolean SEMICOLON .)
    USES            reduce using rule 57 (asignation -> ID EQUAL boolean SEMICOLON .)
    VAR             reduce using rule 57 (asignation -> ID EQUAL boolean SEMICOLON .)
    FUNCTION        reduce using rule 57 (asignation -> ID EQUAL boolean SEMICOLON .)
    PROCEDURE       reduce using rule 57 (asignation -> ID EQUAL boolean SEMICOLON .)
    BEGIN           reduce using rule 57 (asignation -> ID EQUAL boolean SEMICOLON .)
    $end            reduce using rule 57 (asignation -> ID EQUAL boolean SEMICOLON .)


state 166

    (55) asignation -> ID EQUAL callFunctions SEMICOLON .

    ID              reduce using rule 55 (asignation -> ID EQUAL callFunctions SEMICOLON .)
    WRITELN         reduce using rule 55 (asignation -> ID EQUAL callFunctions SEMICOLON .)
    READLN          reduce using rule 55 (asignation -> ID EQUAL callFunctions SEMICOLON .)
    WHILE           reduce using rule 55 (asignation -> ID EQUAL callFunctions SEMICOLON .)
    IF              reduce using rule 55 (asignation -> ID EQUAL callFunctions SEMICOLON .)
    FOR             reduce using rule 55 (asignation -> ID EQUAL callFunctions SEMICOLON .)
    END             reduce using rule 55 (asignation -> ID EQUAL callFunctions SEMICOLON .)
    ELSE            reduce using rule 55 (asignation -> ID EQUAL callFunctions SEMICOLON .)
    PROGRAM         reduce using rule 55 (asignation -> ID EQUAL callFunctions SEMICOLON .)
    USES            reduce using rule 55 (asignation -> ID EQUAL callFunctions SEMICOLON .)
    VAR             reduce using rule 55 (asignation -> ID EQUAL callFunctions SEMICOLON .)
    FUNCTION        reduce using rule 55 (asignation -> ID EQUAL callFunctions SEMICOLON .)
    PROCEDURE       reduce using rule 55 (asignation -> ID EQUAL callFunctions SEMICOLON .)
    BEGIN           reduce using rule 55 (asignation -> ID EQUAL callFunctions SEMICOLON .)
    $end            reduce using rule 55 (asignation -> ID EQUAL callFunctions SEMICOLON .)


state 167

    (56) asignation -> ID EQUAL math SEMICOLON .

    ID              reduce using rule 56 (asignation -> ID EQUAL math SEMICOLON .)
    WRITELN         reduce using rule 56 (asignation -> ID EQUAL math SEMICOLON .)
    READLN          reduce using rule 56 (asignation -> ID EQUAL math SEMICOLON .)
    WHILE           reduce using rule 56 (asignation -> ID EQUAL math SEMICOLON .)
    IF              reduce using rule 56 (asignation -> ID EQUAL math SEMICOLON .)
    FOR             reduce using rule 56 (asignation -> ID EQUAL math SEMICOLON .)
    END             reduce using rule 56 (asignation -> ID EQUAL math SEMICOLON .)
    ELSE            reduce using rule 56 (asignation -> ID EQUAL math SEMICOLON .)
    PROGRAM         reduce using rule 56 (asignation -> ID EQUAL math SEMICOLON .)
    USES            reduce using rule 56 (asignation -> ID EQUAL math SEMICOLON .)
    VAR             reduce using rule 56 (asignation -> ID EQUAL math SEMICOLON .)
    FUNCTION        reduce using rule 56 (asignation -> ID EQUAL math SEMICOLON .)
    PROCEDURE       reduce using rule 56 (asignation -> ID EQUAL math SEMICOLON .)
    BEGIN           reduce using rule 56 (asignation -> ID EQUAL math SEMICOLON .)
    $end            reduce using rule 56 (asignation -> ID EQUAL math SEMICOLON .)


state 168

    (66) if -> IF internexpression op_cycle THEN . otherBegin_if
    (67) if -> IF internexpression op_cycle THEN . instruction_one_line
    (68) if -> IF internexpression op_cycle THEN . otherBegin_if ELSE otherBegin
    (69) if -> IF internexpression op_cycle THEN . otherBegin_if ELSE instruction_one_line
    (70) if -> IF internexpression op_cycle THEN . instruction_one_line ELSE otherBegin
    (71) if -> IF internexpression op_cycle THEN . instruction_one_line ELSE instruction_one_line
    (106) otherBegin_if -> . BEGIN instruction END instruction
    (40) instruction_one_line -> . asignation
    (41) instruction_one_line -> . writing
    (42) instruction_one_line -> . cycles
    (55) asignation -> . ID EQUAL callFunctions SEMICOLON
    (56) asignation -> . ID EQUAL math SEMICOLON
    (57) asignation -> . ID EQUAL boolean SEMICOLON
    (58) asignation -> . ID EQUAL TEXT SEMICOLON
    (49) writing -> . WRITELN LPAREN id_text_l TEXT id_text_r RPAREN SEMICOLON
    (50) writing -> . WRITELN LPAREN id_num RPAREN SEMICOLON
    (51) writing -> . READLN LPAREN ID RPAREN SEMICOLON
    (52) writing -> . READLN LPAREN RPAREN SEMICOLON
    (53) writing -> . READLN SEMICOLON
    (54) writing -> . WRITELN SEMICOLON
    (60) cycles -> . type_cycle
    (61) type_cycle -> . while
    (62) type_cycle -> . if
    (63) type_cycle -> . for
    (64) type_cycle -> . cycles instruction
    (65) while -> . WHILE internexpression op_cycle DO otherBegin
    (66) if -> . IF internexpression op_cycle THEN otherBegin_if
    (67) if -> . IF internexpression op_cycle THEN instruction_one_line
    (68) if -> . IF internexpression op_cycle THEN otherBegin_if ELSE otherBegin
    (69) if -> . IF internexpression op_cycle THEN otherBegin_if ELSE instruction_one_line
    (70) if -> . IF internexpression op_cycle THEN instruction_one_line ELSE otherBegin
    (71) if -> . IF internexpression op_cycle THEN instruction_one_line ELSE instruction_one_line
    (72) for -> . FOR asignation_for TO id_num DO otherBegin
    (73) for -> . FOR asignation_for DOWNTO id_num DO otherBegin

    BEGIN           shift and go to state 199
    ID              shift and go to state 202
    WRITELN         shift and go to state 23
    READLN          shift and go to state 29
    WHILE           shift and go to state 17
    IF              shift and go to state 25
    FOR             shift and go to state 22

    cycles                         shift and go to state 205
    for                            shift and go to state 26
    while                          shift and go to state 31
    asignation                     shift and go to state 203
    type_cycle                     shift and go to state 30
    instruction_one_line           shift and go to state 201
    otherBegin_if                  shift and go to state 204
    writing                        shift and go to state 200
    if                             shift and go to state 20

state 169

    (52) writing -> READLN LPAREN RPAREN SEMICOLON .

    ID              reduce using rule 52 (writing -> READLN LPAREN RPAREN SEMICOLON .)
    WRITELN         reduce using rule 52 (writing -> READLN LPAREN RPAREN SEMICOLON .)
    READLN          reduce using rule 52 (writing -> READLN LPAREN RPAREN SEMICOLON .)
    WHILE           reduce using rule 52 (writing -> READLN LPAREN RPAREN SEMICOLON .)
    IF              reduce using rule 52 (writing -> READLN LPAREN RPAREN SEMICOLON .)
    FOR             reduce using rule 52 (writing -> READLN LPAREN RPAREN SEMICOLON .)
    PROGRAM         reduce using rule 52 (writing -> READLN LPAREN RPAREN SEMICOLON .)
    USES            reduce using rule 52 (writing -> READLN LPAREN RPAREN SEMICOLON .)
    VAR             reduce using rule 52 (writing -> READLN LPAREN RPAREN SEMICOLON .)
    FUNCTION        reduce using rule 52 (writing -> READLN LPAREN RPAREN SEMICOLON .)
    PROCEDURE       reduce using rule 52 (writing -> READLN LPAREN RPAREN SEMICOLON .)
    BEGIN           reduce using rule 52 (writing -> READLN LPAREN RPAREN SEMICOLON .)
    $end            reduce using rule 52 (writing -> READLN LPAREN RPAREN SEMICOLON .)
    END             reduce using rule 52 (writing -> READLN LPAREN RPAREN SEMICOLON .)
    ELSE            reduce using rule 52 (writing -> READLN LPAREN RPAREN SEMICOLON .)


state 170

    (51) writing -> READLN LPAREN ID RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 206


state 171

    (26) type_specifier -> REAL .

    ID              reduce using rule 26 (type_specifier -> REAL .)
    SEMICOLON       reduce using rule 26 (type_specifier -> REAL .)
    RPAREN          reduce using rule 26 (type_specifier -> REAL .)


state 172

    (13) var_declaration_2 -> ID var_declaration_3 COLON type_specifier . SEMICOLON var_declaration_4

    SEMICOLON       shift and go to state 207


state 173

    (29) type_specifier -> DOUBLE .

    ID              reduce using rule 29 (type_specifier -> DOUBLE .)
    SEMICOLON       reduce using rule 29 (type_specifier -> DOUBLE .)
    RPAREN          reduce using rule 29 (type_specifier -> DOUBLE .)


state 174

    (27) type_specifier -> CHAR .

    ID              reduce using rule 27 (type_specifier -> CHAR .)
    SEMICOLON       reduce using rule 27 (type_specifier -> CHAR .)
    RPAREN          reduce using rule 27 (type_specifier -> CHAR .)


state 175

    (28) type_specifier -> BOOLEAN .

    ID              reduce using rule 28 (type_specifier -> BOOLEAN .)
    SEMICOLON       reduce using rule 28 (type_specifier -> BOOLEAN .)
    RPAREN          reduce using rule 28 (type_specifier -> BOOLEAN .)


state 176

    (25) type_specifier -> INTEGER .

    ID              reduce using rule 25 (type_specifier -> INTEGER .)
    SEMICOLON       reduce using rule 25 (type_specifier -> INTEGER .)
    RPAREN          reduce using rule 25 (type_specifier -> INTEGER .)


state 177

    (14) var_declaration_3 -> COMMA ID var_declaration_3 .

    COLON           reduce using rule 14 (var_declaration_3 -> COMMA ID var_declaration_3 .)


state 178

    (108) Begin_function -> BEGIN instruction . END SEMICOLON instruction

    END             shift and go to state 208


state 179

    (107) Begin_function -> var_declaration BEGIN . instruction END SEMICOLON instruction
    (31) instruction -> . asignation instruction
    (32) instruction -> . writing instruction
    (33) instruction -> . cycles instruction
    (34) instruction -> . callFunctions instruction
    (35) instruction -> . empty
    (55) asignation -> . ID EQUAL callFunctions SEMICOLON
    (56) asignation -> . ID EQUAL math SEMICOLON
    (57) asignation -> . ID EQUAL boolean SEMICOLON
    (58) asignation -> . ID EQUAL TEXT SEMICOLON
    (49) writing -> . WRITELN LPAREN id_text_l TEXT id_text_r RPAREN SEMICOLON
    (50) writing -> . WRITELN LPAREN id_num RPAREN SEMICOLON
    (51) writing -> . READLN LPAREN ID RPAREN SEMICOLON
    (52) writing -> . READLN LPAREN RPAREN SEMICOLON
    (53) writing -> . READLN SEMICOLON
    (54) writing -> . WRITELN SEMICOLON
    (60) cycles -> . type_cycle
    (36) callFunctions -> . ID LPAREN params RPAREN
    (18) empty -> .
    (61) type_cycle -> . while
    (62) type_cycle -> . if
    (63) type_cycle -> . for
    (64) type_cycle -> . cycles instruction
    (65) while -> . WHILE internexpression op_cycle DO otherBegin
    (66) if -> . IF internexpression op_cycle THEN otherBegin_if
    (67) if -> . IF internexpression op_cycle THEN instruction_one_line
    (68) if -> . IF internexpression op_cycle THEN otherBegin_if ELSE otherBegin
    (69) if -> . IF internexpression op_cycle THEN otherBegin_if ELSE instruction_one_line
    (70) if -> . IF internexpression op_cycle THEN instruction_one_line ELSE otherBegin
    (71) if -> . IF internexpression op_cycle THEN instruction_one_line ELSE instruction_one_line
    (72) for -> . FOR asignation_for TO id_num DO otherBegin
    (73) for -> . FOR asignation_for DOWNTO id_num DO otherBegin

    ID              shift and go to state 24
    WRITELN         shift and go to state 23
    READLN          shift and go to state 29
    END             reduce using rule 18 (empty -> .)
    WHILE           shift and go to state 17
    IF              shift and go to state 25
    FOR             shift and go to state 22

    instruction                    shift and go to state 209
    if                             shift and go to state 20
    for                            shift and go to state 26
    writing                        shift and go to state 18
    callFunctions                  shift and go to state 19
    asignation                     shift and go to state 28
    type_cycle                     shift and go to state 30
    while                          shift and go to state 31
    empty                          shift and go to state 21
    cycles                         shift and go to state 32

state 180

    (110) function_declaration -> PROCEDURE ID LPAREN fun_param RPAREN . SEMICOLON Begin_function

    SEMICOLON       shift and go to state 210


state 181

    (113) fun_param -> SEMICOLON ID fun_param_2 . COLON type_specifier fun_param

    COLON           shift and go to state 211


state 182

    (109) function_declaration -> FUNCTION ID LPAREN fun_param RPAREN COLON . type_specifier SEMICOLON Begin_function
    (25) type_specifier -> . INTEGER
    (26) type_specifier -> . REAL
    (27) type_specifier -> . CHAR
    (28) type_specifier -> . BOOLEAN
    (29) type_specifier -> . DOUBLE

    INTEGER         shift and go to state 176
    REAL            shift and go to state 171
    CHAR            shift and go to state 174
    BOOLEAN         shift and go to state 175
    DOUBLE          shift and go to state 173

    type_specifier                 shift and go to state 212

state 183

    (112) fun_param -> ID fun_param_2 COLON . type_specifier fun_param
    (25) type_specifier -> . INTEGER
    (26) type_specifier -> . REAL
    (27) type_specifier -> . CHAR
    (28) type_specifier -> . BOOLEAN
    (29) type_specifier -> . DOUBLE

    INTEGER         shift and go to state 176
    REAL            shift and go to state 171
    CHAR            shift and go to state 174
    BOOLEAN         shift and go to state 175
    DOUBLE          shift and go to state 173

    type_specifier                 shift and go to state 213

state 184

    (115) fun_param_2 -> COMMA ID . fun_param_2
    (115) fun_param_2 -> . COMMA ID fun_param_2
    (116) fun_param_2 -> . empty
    (18) empty -> .

    COMMA           shift and go to state 138
    COLON           reduce using rule 18 (empty -> .)

    fun_param_2                    shift and go to state 214
    empty                          shift and go to state 139

state 185

    (74) op_cycle -> op_logic internexpression op_cycle .

    DO              reduce using rule 74 (op_cycle -> op_logic internexpression op_cycle .)
    THEN            reduce using rule 74 (op_cycle -> op_logic internexpression op_cycle .)


state 186

    (105) otherBegin -> BEGIN . instruction END SEMICOLON instruction
    (31) instruction -> . asignation instruction
    (32) instruction -> . writing instruction
    (33) instruction -> . cycles instruction
    (34) instruction -> . callFunctions instruction
    (35) instruction -> . empty
    (55) asignation -> . ID EQUAL callFunctions SEMICOLON
    (56) asignation -> . ID EQUAL math SEMICOLON
    (57) asignation -> . ID EQUAL boolean SEMICOLON
    (58) asignation -> . ID EQUAL TEXT SEMICOLON
    (49) writing -> . WRITELN LPAREN id_text_l TEXT id_text_r RPAREN SEMICOLON
    (50) writing -> . WRITELN LPAREN id_num RPAREN SEMICOLON
    (51) writing -> . READLN LPAREN ID RPAREN SEMICOLON
    (52) writing -> . READLN LPAREN RPAREN SEMICOLON
    (53) writing -> . READLN SEMICOLON
    (54) writing -> . WRITELN SEMICOLON
    (60) cycles -> . type_cycle
    (36) callFunctions -> . ID LPAREN params RPAREN
    (18) empty -> .
    (61) type_cycle -> . while
    (62) type_cycle -> . if
    (63) type_cycle -> . for
    (64) type_cycle -> . cycles instruction
    (65) while -> . WHILE internexpression op_cycle DO otherBegin
    (66) if -> . IF internexpression op_cycle THEN otherBegin_if
    (67) if -> . IF internexpression op_cycle THEN instruction_one_line
    (68) if -> . IF internexpression op_cycle THEN otherBegin_if ELSE otherBegin
    (69) if -> . IF internexpression op_cycle THEN otherBegin_if ELSE instruction_one_line
    (70) if -> . IF internexpression op_cycle THEN instruction_one_line ELSE otherBegin
    (71) if -> . IF internexpression op_cycle THEN instruction_one_line ELSE instruction_one_line
    (72) for -> . FOR asignation_for TO id_num DO otherBegin
    (73) for -> . FOR asignation_for DOWNTO id_num DO otherBegin

    ID              shift and go to state 24
    WRITELN         shift and go to state 23
    READLN          shift and go to state 29
    END             reduce using rule 18 (empty -> .)
    WHILE           shift and go to state 17
    IF              shift and go to state 25
    FOR             shift and go to state 22

    instruction                    shift and go to state 215
    if                             shift and go to state 20
    for                            shift and go to state 26
    writing                        shift and go to state 18
    callFunctions                  shift and go to state 19
    asignation                     shift and go to state 28
    type_cycle                     shift and go to state 30
    while                          shift and go to state 31
    empty                          shift and go to state 21
    cycles                         shift and go to state 32

state 187

    (65) while -> WHILE internexpression op_cycle DO otherBegin .

    ID              reduce using rule 65 (while -> WHILE internexpression op_cycle DO otherBegin .)
    WRITELN         reduce using rule 65 (while -> WHILE internexpression op_cycle DO otherBegin .)
    READLN          reduce using rule 65 (while -> WHILE internexpression op_cycle DO otherBegin .)
    WHILE           reduce using rule 65 (while -> WHILE internexpression op_cycle DO otherBegin .)
    IF              reduce using rule 65 (while -> WHILE internexpression op_cycle DO otherBegin .)
    FOR             reduce using rule 65 (while -> WHILE internexpression op_cycle DO otherBegin .)
    END             reduce using rule 65 (while -> WHILE internexpression op_cycle DO otherBegin .)
    ELSE            reduce using rule 65 (while -> WHILE internexpression op_cycle DO otherBegin .)
    PROGRAM         reduce using rule 65 (while -> WHILE internexpression op_cycle DO otherBegin .)
    USES            reduce using rule 65 (while -> WHILE internexpression op_cycle DO otherBegin .)
    VAR             reduce using rule 65 (while -> WHILE internexpression op_cycle DO otherBegin .)
    FUNCTION        reduce using rule 65 (while -> WHILE internexpression op_cycle DO otherBegin .)
    PROCEDURE       reduce using rule 65 (while -> WHILE internexpression op_cycle DO otherBegin .)
    BEGIN           reduce using rule 65 (while -> WHILE internexpression op_cycle DO otherBegin .)
    $end            reduce using rule 65 (while -> WHILE internexpression op_cycle DO otherBegin .)


state 188

    (20) mathi -> type_op_math factor mathi .

    ISEQUAL         reduce using rule 20 (mathi -> type_op_math factor mathi .)
    LESSEQUAL       reduce using rule 20 (mathi -> type_op_math factor mathi .)
    LESS            reduce using rule 20 (mathi -> type_op_math factor mathi .)
    GREATER         reduce using rule 20 (mathi -> type_op_math factor mathi .)
    GREATEREQUAL    reduce using rule 20 (mathi -> type_op_math factor mathi .)
    DEQUAL          reduce using rule 20 (mathi -> type_op_math factor mathi .)
    RPAREN          reduce using rule 20 (mathi -> type_op_math factor mathi .)
    COMMA           reduce using rule 20 (mathi -> type_op_math factor mathi .)
    SEMICOLON       reduce using rule 20 (mathi -> type_op_math factor mathi .)
    AND             reduce using rule 20 (mathi -> type_op_math factor mathi .)
    OR              reduce using rule 20 (mathi -> type_op_math factor mathi .)
    XOR             reduce using rule 20 (mathi -> type_op_math factor mathi .)
    NOT             reduce using rule 20 (mathi -> type_op_math factor mathi .)
    DO              reduce using rule 20 (mathi -> type_op_math factor mathi .)
    THEN            reduce using rule 20 (mathi -> type_op_math factor mathi .)


state 189

    (73) for -> FOR asignation_for DOWNTO id_num DO . otherBegin
    (105) otherBegin -> . BEGIN instruction END SEMICOLON instruction

    BEGIN           shift and go to state 186

    otherBegin                     shift and go to state 216

state 190

    (72) for -> FOR asignation_for TO id_num DO . otherBegin
    (105) otherBegin -> . BEGIN instruction END SEMICOLON instruction

    BEGIN           shift and go to state 186

    otherBegin                     shift and go to state 217

state 191

    (43) id_text_l -> callFunctions COMMA id_text_l .

    TEXT            reduce using rule 43 (id_text_l -> callFunctions COMMA id_text_l .)


state 192

    (44) id_text_l -> ID . COMMA id_text_l
    (36) callFunctions -> ID . LPAREN params RPAREN

    COMMA           shift and go to state 159
    LPAREN          shift and go to state 61


state 193

    (46) id_text_r -> COMMA . callFunctions id_text_r
    (47) id_text_r -> COMMA . ID id_text_r
    (36) callFunctions -> . ID LPAREN params RPAREN

    ID              shift and go to state 219

    callFunctions                  shift and go to state 218

state 194

    (49) writing -> WRITELN LPAREN id_text_l TEXT id_text_r . RPAREN SEMICOLON

    RPAREN          shift and go to state 220


state 195

    (48) id_text_r -> empty .

    RPAREN          reduce using rule 48 (id_text_r -> empty .)


state 196

    (50) writing -> WRITELN LPAREN id_num RPAREN SEMICOLON .

    ID              reduce using rule 50 (writing -> WRITELN LPAREN id_num RPAREN SEMICOLON .)
    WRITELN         reduce using rule 50 (writing -> WRITELN LPAREN id_num RPAREN SEMICOLON .)
    READLN          reduce using rule 50 (writing -> WRITELN LPAREN id_num RPAREN SEMICOLON .)
    WHILE           reduce using rule 50 (writing -> WRITELN LPAREN id_num RPAREN SEMICOLON .)
    IF              reduce using rule 50 (writing -> WRITELN LPAREN id_num RPAREN SEMICOLON .)
    FOR             reduce using rule 50 (writing -> WRITELN LPAREN id_num RPAREN SEMICOLON .)
    PROGRAM         reduce using rule 50 (writing -> WRITELN LPAREN id_num RPAREN SEMICOLON .)
    USES            reduce using rule 50 (writing -> WRITELN LPAREN id_num RPAREN SEMICOLON .)
    VAR             reduce using rule 50 (writing -> WRITELN LPAREN id_num RPAREN SEMICOLON .)
    FUNCTION        reduce using rule 50 (writing -> WRITELN LPAREN id_num RPAREN SEMICOLON .)
    PROCEDURE       reduce using rule 50 (writing -> WRITELN LPAREN id_num RPAREN SEMICOLON .)
    BEGIN           reduce using rule 50 (writing -> WRITELN LPAREN id_num RPAREN SEMICOLON .)
    $end            reduce using rule 50 (writing -> WRITELN LPAREN id_num RPAREN SEMICOLON .)
    END             reduce using rule 50 (writing -> WRITELN LPAREN id_num RPAREN SEMICOLON .)
    ELSE            reduce using rule 50 (writing -> WRITELN LPAREN id_num RPAREN SEMICOLON .)


state 197

    (44) id_text_l -> ID COMMA id_text_l .

    TEXT            reduce using rule 44 (id_text_l -> ID COMMA id_text_l .)


state 198

    (38) params2 -> COMMA math .

    RPAREN          reduce using rule 38 (params2 -> COMMA math .)


state 199

    (106) otherBegin_if -> BEGIN . instruction END instruction
    (31) instruction -> . asignation instruction
    (32) instruction -> . writing instruction
    (33) instruction -> . cycles instruction
    (34) instruction -> . callFunctions instruction
    (35) instruction -> . empty
    (55) asignation -> . ID EQUAL callFunctions SEMICOLON
    (56) asignation -> . ID EQUAL math SEMICOLON
    (57) asignation -> . ID EQUAL boolean SEMICOLON
    (58) asignation -> . ID EQUAL TEXT SEMICOLON
    (49) writing -> . WRITELN LPAREN id_text_l TEXT id_text_r RPAREN SEMICOLON
    (50) writing -> . WRITELN LPAREN id_num RPAREN SEMICOLON
    (51) writing -> . READLN LPAREN ID RPAREN SEMICOLON
    (52) writing -> . READLN LPAREN RPAREN SEMICOLON
    (53) writing -> . READLN SEMICOLON
    (54) writing -> . WRITELN SEMICOLON
    (60) cycles -> . type_cycle
    (36) callFunctions -> . ID LPAREN params RPAREN
    (18) empty -> .
    (61) type_cycle -> . while
    (62) type_cycle -> . if
    (63) type_cycle -> . for
    (64) type_cycle -> . cycles instruction
    (65) while -> . WHILE internexpression op_cycle DO otherBegin
    (66) if -> . IF internexpression op_cycle THEN otherBegin_if
    (67) if -> . IF internexpression op_cycle THEN instruction_one_line
    (68) if -> . IF internexpression op_cycle THEN otherBegin_if ELSE otherBegin
    (69) if -> . IF internexpression op_cycle THEN otherBegin_if ELSE instruction_one_line
    (70) if -> . IF internexpression op_cycle THEN instruction_one_line ELSE otherBegin
    (71) if -> . IF internexpression op_cycle THEN instruction_one_line ELSE instruction_one_line
    (72) for -> . FOR asignation_for TO id_num DO otherBegin
    (73) for -> . FOR asignation_for DOWNTO id_num DO otherBegin

    ID              shift and go to state 24
    WRITELN         shift and go to state 23
    READLN          shift and go to state 29
    END             reduce using rule 18 (empty -> .)
    WHILE           shift and go to state 17
    IF              shift and go to state 25
    FOR             shift and go to state 22

    instruction                    shift and go to state 221
    if                             shift and go to state 20
    for                            shift and go to state 26
    writing                        shift and go to state 18
    callFunctions                  shift and go to state 19
    asignation                     shift and go to state 28
    type_cycle                     shift and go to state 30
    while                          shift and go to state 31
    empty                          shift and go to state 21
    cycles                         shift and go to state 32

state 200

    (41) instruction_one_line -> writing .

    END             reduce using rule 41 (instruction_one_line -> writing .)
    ID              reduce using rule 41 (instruction_one_line -> writing .)
    WRITELN         reduce using rule 41 (instruction_one_line -> writing .)
    READLN          reduce using rule 41 (instruction_one_line -> writing .)
    WHILE           reduce using rule 41 (instruction_one_line -> writing .)
    IF              reduce using rule 41 (instruction_one_line -> writing .)
    FOR             reduce using rule 41 (instruction_one_line -> writing .)
    ELSE            reduce using rule 41 (instruction_one_line -> writing .)
    PROGRAM         reduce using rule 41 (instruction_one_line -> writing .)
    USES            reduce using rule 41 (instruction_one_line -> writing .)
    VAR             reduce using rule 41 (instruction_one_line -> writing .)
    FUNCTION        reduce using rule 41 (instruction_one_line -> writing .)
    PROCEDURE       reduce using rule 41 (instruction_one_line -> writing .)
    BEGIN           reduce using rule 41 (instruction_one_line -> writing .)
    $end            reduce using rule 41 (instruction_one_line -> writing .)


state 201

    (67) if -> IF internexpression op_cycle THEN instruction_one_line .
    (70) if -> IF internexpression op_cycle THEN instruction_one_line . ELSE otherBegin
    (71) if -> IF internexpression op_cycle THEN instruction_one_line . ELSE instruction_one_line

  ! shift/reduce conflict for ELSE resolved as shift
    ID              reduce using rule 67 (if -> IF internexpression op_cycle THEN instruction_one_line .)
    WRITELN         reduce using rule 67 (if -> IF internexpression op_cycle THEN instruction_one_line .)
    READLN          reduce using rule 67 (if -> IF internexpression op_cycle THEN instruction_one_line .)
    WHILE           reduce using rule 67 (if -> IF internexpression op_cycle THEN instruction_one_line .)
    IF              reduce using rule 67 (if -> IF internexpression op_cycle THEN instruction_one_line .)
    FOR             reduce using rule 67 (if -> IF internexpression op_cycle THEN instruction_one_line .)
    END             reduce using rule 67 (if -> IF internexpression op_cycle THEN instruction_one_line .)
    PROGRAM         reduce using rule 67 (if -> IF internexpression op_cycle THEN instruction_one_line .)
    USES            reduce using rule 67 (if -> IF internexpression op_cycle THEN instruction_one_line .)
    VAR             reduce using rule 67 (if -> IF internexpression op_cycle THEN instruction_one_line .)
    FUNCTION        reduce using rule 67 (if -> IF internexpression op_cycle THEN instruction_one_line .)
    PROCEDURE       reduce using rule 67 (if -> IF internexpression op_cycle THEN instruction_one_line .)
    BEGIN           reduce using rule 67 (if -> IF internexpression op_cycle THEN instruction_one_line .)
    $end            reduce using rule 67 (if -> IF internexpression op_cycle THEN instruction_one_line .)
    ELSE            shift and go to state 222

  ! ELSE            [ reduce using rule 67 (if -> IF internexpression op_cycle THEN instruction_one_line .) ]


state 202

    (55) asignation -> ID . EQUAL callFunctions SEMICOLON
    (56) asignation -> ID . EQUAL math SEMICOLON
    (57) asignation -> ID . EQUAL boolean SEMICOLON
    (58) asignation -> ID . EQUAL TEXT SEMICOLON

    EQUAL           shift and go to state 62


state 203

    (40) instruction_one_line -> asignation .

    END             reduce using rule 40 (instruction_one_line -> asignation .)
    ID              reduce using rule 40 (instruction_one_line -> asignation .)
    WRITELN         reduce using rule 40 (instruction_one_line -> asignation .)
    READLN          reduce using rule 40 (instruction_one_line -> asignation .)
    WHILE           reduce using rule 40 (instruction_one_line -> asignation .)
    IF              reduce using rule 40 (instruction_one_line -> asignation .)
    FOR             reduce using rule 40 (instruction_one_line -> asignation .)
    ELSE            reduce using rule 40 (instruction_one_line -> asignation .)
    PROGRAM         reduce using rule 40 (instruction_one_line -> asignation .)
    USES            reduce using rule 40 (instruction_one_line -> asignation .)
    VAR             reduce using rule 40 (instruction_one_line -> asignation .)
    FUNCTION        reduce using rule 40 (instruction_one_line -> asignation .)
    PROCEDURE       reduce using rule 40 (instruction_one_line -> asignation .)
    BEGIN           reduce using rule 40 (instruction_one_line -> asignation .)
    $end            reduce using rule 40 (instruction_one_line -> asignation .)


state 204

    (66) if -> IF internexpression op_cycle THEN otherBegin_if .
    (68) if -> IF internexpression op_cycle THEN otherBegin_if . ELSE otherBegin
    (69) if -> IF internexpression op_cycle THEN otherBegin_if . ELSE instruction_one_line

  ! shift/reduce conflict for ELSE resolved as shift
    ID              reduce using rule 66 (if -> IF internexpression op_cycle THEN otherBegin_if .)
    WRITELN         reduce using rule 66 (if -> IF internexpression op_cycle THEN otherBegin_if .)
    READLN          reduce using rule 66 (if -> IF internexpression op_cycle THEN otherBegin_if .)
    WHILE           reduce using rule 66 (if -> IF internexpression op_cycle THEN otherBegin_if .)
    IF              reduce using rule 66 (if -> IF internexpression op_cycle THEN otherBegin_if .)
    FOR             reduce using rule 66 (if -> IF internexpression op_cycle THEN otherBegin_if .)
    END             reduce using rule 66 (if -> IF internexpression op_cycle THEN otherBegin_if .)
    PROGRAM         reduce using rule 66 (if -> IF internexpression op_cycle THEN otherBegin_if .)
    USES            reduce using rule 66 (if -> IF internexpression op_cycle THEN otherBegin_if .)
    VAR             reduce using rule 66 (if -> IF internexpression op_cycle THEN otherBegin_if .)
    FUNCTION        reduce using rule 66 (if -> IF internexpression op_cycle THEN otherBegin_if .)
    PROCEDURE       reduce using rule 66 (if -> IF internexpression op_cycle THEN otherBegin_if .)
    BEGIN           reduce using rule 66 (if -> IF internexpression op_cycle THEN otherBegin_if .)
    $end            reduce using rule 66 (if -> IF internexpression op_cycle THEN otherBegin_if .)
    ELSE            shift and go to state 223

  ! ELSE            [ reduce using rule 66 (if -> IF internexpression op_cycle THEN otherBegin_if .) ]


state 205

    (42) instruction_one_line -> cycles .
    (64) type_cycle -> cycles . instruction
    (31) instruction -> . asignation instruction
    (32) instruction -> . writing instruction
    (33) instruction -> . cycles instruction
    (34) instruction -> . callFunctions instruction
    (35) instruction -> . empty
    (55) asignation -> . ID EQUAL callFunctions SEMICOLON
    (56) asignation -> . ID EQUAL math SEMICOLON
    (57) asignation -> . ID EQUAL boolean SEMICOLON
    (58) asignation -> . ID EQUAL TEXT SEMICOLON
    (49) writing -> . WRITELN LPAREN id_text_l TEXT id_text_r RPAREN SEMICOLON
    (50) writing -> . WRITELN LPAREN id_num RPAREN SEMICOLON
    (51) writing -> . READLN LPAREN ID RPAREN SEMICOLON
    (52) writing -> . READLN LPAREN RPAREN SEMICOLON
    (53) writing -> . READLN SEMICOLON
    (54) writing -> . WRITELN SEMICOLON
    (60) cycles -> . type_cycle
    (36) callFunctions -> . ID LPAREN params RPAREN
    (18) empty -> .
    (61) type_cycle -> . while
    (62) type_cycle -> . if
    (63) type_cycle -> . for
    (64) type_cycle -> . cycles instruction
    (65) while -> . WHILE internexpression op_cycle DO otherBegin
    (66) if -> . IF internexpression op_cycle THEN otherBegin_if
    (67) if -> . IF internexpression op_cycle THEN instruction_one_line
    (68) if -> . IF internexpression op_cycle THEN otherBegin_if ELSE otherBegin
    (69) if -> . IF internexpression op_cycle THEN otherBegin_if ELSE instruction_one_line
    (70) if -> . IF internexpression op_cycle THEN instruction_one_line ELSE otherBegin
    (71) if -> . IF internexpression op_cycle THEN instruction_one_line ELSE instruction_one_line
    (72) for -> . FOR asignation_for TO id_num DO otherBegin
    (73) for -> . FOR asignation_for DOWNTO id_num DO otherBegin

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WRITELN resolved as shift
  ! shift/reduce conflict for READLN resolved as shift
  ! reduce/reduce conflict for END resolved using rule 18 (empty -> .)
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WRITELN resolved as shift
  ! shift/reduce conflict for READLN resolved as shift
  ! reduce/reduce conflict for WHILE resolved using rule 18 (empty -> .)
  ! reduce/reduce conflict for IF resolved using rule 18 (empty -> .)
  ! reduce/reduce conflict for FOR resolved using rule 18 (empty -> .)
  ! reduce/reduce conflict for ELSE resolved using rule 18 (empty -> .)
  ! reduce/reduce conflict for PROGRAM resolved using rule 18 (empty -> .)
  ! reduce/reduce conflict for USES resolved using rule 18 (empty -> .)
  ! reduce/reduce conflict for VAR resolved using rule 18 (empty -> .)
  ! reduce/reduce conflict for FUNCTION resolved using rule 18 (empty -> .)
  ! reduce/reduce conflict for PROCEDURE resolved using rule 18 (empty -> .)
  ! reduce/reduce conflict for BEGIN resolved using rule 18 (empty -> .)
  ! reduce/reduce conflict for $end resolved using rule 18 (empty -> .)
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
    ID              shift and go to state 24
    WRITELN         shift and go to state 23
    READLN          shift and go to state 29
    END             reduce using rule 18 (empty -> .)
    ELSE            reduce using rule 18 (empty -> .)
    PROGRAM         reduce using rule 18 (empty -> .)
    USES            reduce using rule 18 (empty -> .)
    VAR             reduce using rule 18 (empty -> .)
    FUNCTION        reduce using rule 18 (empty -> .)
    PROCEDURE       reduce using rule 18 (empty -> .)
    BEGIN           reduce using rule 18 (empty -> .)
    $end            reduce using rule 18 (empty -> .)
    WHILE           shift and go to state 17
    IF              shift and go to state 25
    FOR             shift and go to state 22

  ! END             [ reduce using rule 42 (instruction_one_line -> cycles .) ]
  ! ID              [ reduce using rule 42 (instruction_one_line -> cycles .) ]
  ! WRITELN         [ reduce using rule 42 (instruction_one_line -> cycles .) ]
  ! READLN          [ reduce using rule 42 (instruction_one_line -> cycles .) ]
  ! WHILE           [ reduce using rule 42 (instruction_one_line -> cycles .) ]
  ! IF              [ reduce using rule 42 (instruction_one_line -> cycles .) ]
  ! FOR             [ reduce using rule 42 (instruction_one_line -> cycles .) ]
  ! ELSE            [ reduce using rule 42 (instruction_one_line -> cycles .) ]
  ! PROGRAM         [ reduce using rule 42 (instruction_one_line -> cycles .) ]
  ! USES            [ reduce using rule 42 (instruction_one_line -> cycles .) ]
  ! VAR             [ reduce using rule 42 (instruction_one_line -> cycles .) ]
  ! FUNCTION        [ reduce using rule 42 (instruction_one_line -> cycles .) ]
  ! PROCEDURE       [ reduce using rule 42 (instruction_one_line -> cycles .) ]
  ! BEGIN           [ reduce using rule 42 (instruction_one_line -> cycles .) ]
  ! $end            [ reduce using rule 42 (instruction_one_line -> cycles .) ]
  ! ID              [ reduce using rule 18 (empty -> .) ]
  ! WRITELN         [ reduce using rule 18 (empty -> .) ]
  ! READLN          [ reduce using rule 18 (empty -> .) ]
  ! WHILE           [ reduce using rule 18 (empty -> .) ]
  ! IF              [ reduce using rule 18 (empty -> .) ]
  ! FOR             [ reduce using rule 18 (empty -> .) ]

    instruction                    shift and go to state 224
    if                             shift and go to state 20
    for                            shift and go to state 26
    writing                        shift and go to state 18
    callFunctions                  shift and go to state 19
    asignation                     shift and go to state 28
    type_cycle                     shift and go to state 30
    while                          shift and go to state 31
    empty                          shift and go to state 21
    cycles                         shift and go to state 32

state 206

    (51) writing -> READLN LPAREN ID RPAREN SEMICOLON .

    ID              reduce using rule 51 (writing -> READLN LPAREN ID RPAREN SEMICOLON .)
    WRITELN         reduce using rule 51 (writing -> READLN LPAREN ID RPAREN SEMICOLON .)
    READLN          reduce using rule 51 (writing -> READLN LPAREN ID RPAREN SEMICOLON .)
    WHILE           reduce using rule 51 (writing -> READLN LPAREN ID RPAREN SEMICOLON .)
    IF              reduce using rule 51 (writing -> READLN LPAREN ID RPAREN SEMICOLON .)
    FOR             reduce using rule 51 (writing -> READLN LPAREN ID RPAREN SEMICOLON .)
    PROGRAM         reduce using rule 51 (writing -> READLN LPAREN ID RPAREN SEMICOLON .)
    USES            reduce using rule 51 (writing -> READLN LPAREN ID RPAREN SEMICOLON .)
    VAR             reduce using rule 51 (writing -> READLN LPAREN ID RPAREN SEMICOLON .)
    FUNCTION        reduce using rule 51 (writing -> READLN LPAREN ID RPAREN SEMICOLON .)
    PROCEDURE       reduce using rule 51 (writing -> READLN LPAREN ID RPAREN SEMICOLON .)
    BEGIN           reduce using rule 51 (writing -> READLN LPAREN ID RPAREN SEMICOLON .)
    $end            reduce using rule 51 (writing -> READLN LPAREN ID RPAREN SEMICOLON .)
    END             reduce using rule 51 (writing -> READLN LPAREN ID RPAREN SEMICOLON .)
    ELSE            reduce using rule 51 (writing -> READLN LPAREN ID RPAREN SEMICOLON .)


state 207

    (13) var_declaration_2 -> ID var_declaration_3 COLON type_specifier SEMICOLON . var_declaration_4
    (16) var_declaration_4 -> . var_declaration_2
    (17) var_declaration_4 -> . empty
    (13) var_declaration_2 -> . ID var_declaration_3 COLON type_specifier SEMICOLON var_declaration_4
    (18) empty -> .

    ID              shift and go to state 34
    PROGRAM         reduce using rule 18 (empty -> .)
    USES            reduce using rule 18 (empty -> .)
    VAR             reduce using rule 18 (empty -> .)
    FUNCTION        reduce using rule 18 (empty -> .)
    PROCEDURE       reduce using rule 18 (empty -> .)
    BEGIN           reduce using rule 18 (empty -> .)
    $end            reduce using rule 18 (empty -> .)

    var_declaration_4              shift and go to state 225
    var_declaration_2              shift and go to state 226
    empty                          shift and go to state 227

state 208

    (108) Begin_function -> BEGIN instruction END . SEMICOLON instruction

    SEMICOLON       shift and go to state 228


state 209

    (107) Begin_function -> var_declaration BEGIN instruction . END SEMICOLON instruction

    END             shift and go to state 229


state 210

    (110) function_declaration -> PROCEDURE ID LPAREN fun_param RPAREN SEMICOLON . Begin_function
    (107) Begin_function -> . var_declaration BEGIN instruction END SEMICOLON instruction
    (108) Begin_function -> . BEGIN instruction END SEMICOLON instruction
    (12) var_declaration -> . VAR var_declaration_2

    BEGIN           shift and go to state 131
    VAR             shift and go to state 9

    Begin_function                 shift and go to state 230
    var_declaration                shift and go to state 132

state 211

    (113) fun_param -> SEMICOLON ID fun_param_2 COLON . type_specifier fun_param
    (25) type_specifier -> . INTEGER
    (26) type_specifier -> . REAL
    (27) type_specifier -> . CHAR
    (28) type_specifier -> . BOOLEAN
    (29) type_specifier -> . DOUBLE

    INTEGER         shift and go to state 176
    REAL            shift and go to state 171
    CHAR            shift and go to state 174
    BOOLEAN         shift and go to state 175
    DOUBLE          shift and go to state 173

    type_specifier                 shift and go to state 231

state 212

    (109) function_declaration -> FUNCTION ID LPAREN fun_param RPAREN COLON type_specifier . SEMICOLON Begin_function

    SEMICOLON       shift and go to state 232


state 213

    (112) fun_param -> ID fun_param_2 COLON type_specifier . fun_param
    (112) fun_param -> . ID fun_param_2 COLON type_specifier fun_param
    (113) fun_param -> . SEMICOLON ID fun_param_2 COLON type_specifier fun_param
    (114) fun_param -> . empty
    (18) empty -> .

    ID              shift and go to state 76
    SEMICOLON       shift and go to state 74
    RPAREN          reduce using rule 18 (empty -> .)

    fun_param                      shift and go to state 233
    empty                          shift and go to state 77

state 214

    (115) fun_param_2 -> COMMA ID fun_param_2 .

    COLON           reduce using rule 115 (fun_param_2 -> COMMA ID fun_param_2 .)


state 215

    (105) otherBegin -> BEGIN instruction . END SEMICOLON instruction

    END             shift and go to state 234


state 216

    (73) for -> FOR asignation_for DOWNTO id_num DO otherBegin .

    ID              reduce using rule 73 (for -> FOR asignation_for DOWNTO id_num DO otherBegin .)
    WRITELN         reduce using rule 73 (for -> FOR asignation_for DOWNTO id_num DO otherBegin .)
    READLN          reduce using rule 73 (for -> FOR asignation_for DOWNTO id_num DO otherBegin .)
    WHILE           reduce using rule 73 (for -> FOR asignation_for DOWNTO id_num DO otherBegin .)
    IF              reduce using rule 73 (for -> FOR asignation_for DOWNTO id_num DO otherBegin .)
    FOR             reduce using rule 73 (for -> FOR asignation_for DOWNTO id_num DO otherBegin .)
    END             reduce using rule 73 (for -> FOR asignation_for DOWNTO id_num DO otherBegin .)
    ELSE            reduce using rule 73 (for -> FOR asignation_for DOWNTO id_num DO otherBegin .)
    PROGRAM         reduce using rule 73 (for -> FOR asignation_for DOWNTO id_num DO otherBegin .)
    USES            reduce using rule 73 (for -> FOR asignation_for DOWNTO id_num DO otherBegin .)
    VAR             reduce using rule 73 (for -> FOR asignation_for DOWNTO id_num DO otherBegin .)
    FUNCTION        reduce using rule 73 (for -> FOR asignation_for DOWNTO id_num DO otherBegin .)
    PROCEDURE       reduce using rule 73 (for -> FOR asignation_for DOWNTO id_num DO otherBegin .)
    BEGIN           reduce using rule 73 (for -> FOR asignation_for DOWNTO id_num DO otherBegin .)
    $end            reduce using rule 73 (for -> FOR asignation_for DOWNTO id_num DO otherBegin .)


state 217

    (72) for -> FOR asignation_for TO id_num DO otherBegin .

    ID              reduce using rule 72 (for -> FOR asignation_for TO id_num DO otherBegin .)
    WRITELN         reduce using rule 72 (for -> FOR asignation_for TO id_num DO otherBegin .)
    READLN          reduce using rule 72 (for -> FOR asignation_for TO id_num DO otherBegin .)
    WHILE           reduce using rule 72 (for -> FOR asignation_for TO id_num DO otherBegin .)
    IF              reduce using rule 72 (for -> FOR asignation_for TO id_num DO otherBegin .)
    FOR             reduce using rule 72 (for -> FOR asignation_for TO id_num DO otherBegin .)
    END             reduce using rule 72 (for -> FOR asignation_for TO id_num DO otherBegin .)
    ELSE            reduce using rule 72 (for -> FOR asignation_for TO id_num DO otherBegin .)
    PROGRAM         reduce using rule 72 (for -> FOR asignation_for TO id_num DO otherBegin .)
    USES            reduce using rule 72 (for -> FOR asignation_for TO id_num DO otherBegin .)
    VAR             reduce using rule 72 (for -> FOR asignation_for TO id_num DO otherBegin .)
    FUNCTION        reduce using rule 72 (for -> FOR asignation_for TO id_num DO otherBegin .)
    PROCEDURE       reduce using rule 72 (for -> FOR asignation_for TO id_num DO otherBegin .)
    BEGIN           reduce using rule 72 (for -> FOR asignation_for TO id_num DO otherBegin .)
    $end            reduce using rule 72 (for -> FOR asignation_for TO id_num DO otherBegin .)


state 218

    (46) id_text_r -> COMMA callFunctions . id_text_r
    (46) id_text_r -> . COMMA callFunctions id_text_r
    (47) id_text_r -> . COMMA ID id_text_r
    (48) id_text_r -> . empty
    (18) empty -> .

    COMMA           shift and go to state 193
    RPAREN          reduce using rule 18 (empty -> .)

    empty                          shift and go to state 195
    id_text_r                      shift and go to state 235

state 219

    (47) id_text_r -> COMMA ID . id_text_r
    (36) callFunctions -> ID . LPAREN params RPAREN
    (46) id_text_r -> . COMMA callFunctions id_text_r
    (47) id_text_r -> . COMMA ID id_text_r
    (48) id_text_r -> . empty
    (18) empty -> .

    LPAREN          shift and go to state 61
    COMMA           shift and go to state 193
    RPAREN          reduce using rule 18 (empty -> .)

    empty                          shift and go to state 195
    id_text_r                      shift and go to state 236

state 220

    (49) writing -> WRITELN LPAREN id_text_l TEXT id_text_r RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 237


state 221

    (106) otherBegin_if -> BEGIN instruction . END instruction

    END             shift and go to state 238


state 222

    (70) if -> IF internexpression op_cycle THEN instruction_one_line ELSE . otherBegin
    (71) if -> IF internexpression op_cycle THEN instruction_one_line ELSE . instruction_one_line
    (105) otherBegin -> . BEGIN instruction END SEMICOLON instruction
    (40) instruction_one_line -> . asignation
    (41) instruction_one_line -> . writing
    (42) instruction_one_line -> . cycles
    (55) asignation -> . ID EQUAL callFunctions SEMICOLON
    (56) asignation -> . ID EQUAL math SEMICOLON
    (57) asignation -> . ID EQUAL boolean SEMICOLON
    (58) asignation -> . ID EQUAL TEXT SEMICOLON
    (49) writing -> . WRITELN LPAREN id_text_l TEXT id_text_r RPAREN SEMICOLON
    (50) writing -> . WRITELN LPAREN id_num RPAREN SEMICOLON
    (51) writing -> . READLN LPAREN ID RPAREN SEMICOLON
    (52) writing -> . READLN LPAREN RPAREN SEMICOLON
    (53) writing -> . READLN SEMICOLON
    (54) writing -> . WRITELN SEMICOLON
    (60) cycles -> . type_cycle
    (61) type_cycle -> . while
    (62) type_cycle -> . if
    (63) type_cycle -> . for
    (64) type_cycle -> . cycles instruction
    (65) while -> . WHILE internexpression op_cycle DO otherBegin
    (66) if -> . IF internexpression op_cycle THEN otherBegin_if
    (67) if -> . IF internexpression op_cycle THEN instruction_one_line
    (68) if -> . IF internexpression op_cycle THEN otherBegin_if ELSE otherBegin
    (69) if -> . IF internexpression op_cycle THEN otherBegin_if ELSE instruction_one_line
    (70) if -> . IF internexpression op_cycle THEN instruction_one_line ELSE otherBegin
    (71) if -> . IF internexpression op_cycle THEN instruction_one_line ELSE instruction_one_line
    (72) for -> . FOR asignation_for TO id_num DO otherBegin
    (73) for -> . FOR asignation_for DOWNTO id_num DO otherBegin

    BEGIN           shift and go to state 186
    ID              shift and go to state 202
    WRITELN         shift and go to state 23
    READLN          shift and go to state 29
    WHILE           shift and go to state 17
    IF              shift and go to state 25
    FOR             shift and go to state 22

    cycles                         shift and go to state 205
    for                            shift and go to state 26
    while                          shift and go to state 31
    asignation                     shift and go to state 203
    type_cycle                     shift and go to state 30
    instruction_one_line           shift and go to state 239
    otherBegin                     shift and go to state 240
    writing                        shift and go to state 200
    if                             shift and go to state 20

state 223

    (68) if -> IF internexpression op_cycle THEN otherBegin_if ELSE . otherBegin
    (69) if -> IF internexpression op_cycle THEN otherBegin_if ELSE . instruction_one_line
    (105) otherBegin -> . BEGIN instruction END SEMICOLON instruction
    (40) instruction_one_line -> . asignation
    (41) instruction_one_line -> . writing
    (42) instruction_one_line -> . cycles
    (55) asignation -> . ID EQUAL callFunctions SEMICOLON
    (56) asignation -> . ID EQUAL math SEMICOLON
    (57) asignation -> . ID EQUAL boolean SEMICOLON
    (58) asignation -> . ID EQUAL TEXT SEMICOLON
    (49) writing -> . WRITELN LPAREN id_text_l TEXT id_text_r RPAREN SEMICOLON
    (50) writing -> . WRITELN LPAREN id_num RPAREN SEMICOLON
    (51) writing -> . READLN LPAREN ID RPAREN SEMICOLON
    (52) writing -> . READLN LPAREN RPAREN SEMICOLON
    (53) writing -> . READLN SEMICOLON
    (54) writing -> . WRITELN SEMICOLON
    (60) cycles -> . type_cycle
    (61) type_cycle -> . while
    (62) type_cycle -> . if
    (63) type_cycle -> . for
    (64) type_cycle -> . cycles instruction
    (65) while -> . WHILE internexpression op_cycle DO otherBegin
    (66) if -> . IF internexpression op_cycle THEN otherBegin_if
    (67) if -> . IF internexpression op_cycle THEN instruction_one_line
    (68) if -> . IF internexpression op_cycle THEN otherBegin_if ELSE otherBegin
    (69) if -> . IF internexpression op_cycle THEN otherBegin_if ELSE instruction_one_line
    (70) if -> . IF internexpression op_cycle THEN instruction_one_line ELSE otherBegin
    (71) if -> . IF internexpression op_cycle THEN instruction_one_line ELSE instruction_one_line
    (72) for -> . FOR asignation_for TO id_num DO otherBegin
    (73) for -> . FOR asignation_for DOWNTO id_num DO otherBegin

    BEGIN           shift and go to state 186
    ID              shift and go to state 202
    WRITELN         shift and go to state 23
    READLN          shift and go to state 29
    WHILE           shift and go to state 17
    IF              shift and go to state 25
    FOR             shift and go to state 22

    cycles                         shift and go to state 205
    for                            shift and go to state 26
    while                          shift and go to state 31
    asignation                     shift and go to state 203
    type_cycle                     shift and go to state 30
    instruction_one_line           shift and go to state 241
    otherBegin                     shift and go to state 242
    writing                        shift and go to state 200
    if                             shift and go to state 20

state 224

    (64) type_cycle -> cycles instruction .

    END             reduce using rule 64 (type_cycle -> cycles instruction .)
    ID              reduce using rule 64 (type_cycle -> cycles instruction .)
    WRITELN         reduce using rule 64 (type_cycle -> cycles instruction .)
    READLN          reduce using rule 64 (type_cycle -> cycles instruction .)
    WHILE           reduce using rule 64 (type_cycle -> cycles instruction .)
    IF              reduce using rule 64 (type_cycle -> cycles instruction .)
    FOR             reduce using rule 64 (type_cycle -> cycles instruction .)
    ELSE            reduce using rule 64 (type_cycle -> cycles instruction .)
    PROGRAM         reduce using rule 64 (type_cycle -> cycles instruction .)
    USES            reduce using rule 64 (type_cycle -> cycles instruction .)
    VAR             reduce using rule 64 (type_cycle -> cycles instruction .)
    FUNCTION        reduce using rule 64 (type_cycle -> cycles instruction .)
    PROCEDURE       reduce using rule 64 (type_cycle -> cycles instruction .)
    BEGIN           reduce using rule 64 (type_cycle -> cycles instruction .)
    $end            reduce using rule 64 (type_cycle -> cycles instruction .)


state 225

    (13) var_declaration_2 -> ID var_declaration_3 COLON type_specifier SEMICOLON var_declaration_4 .

    PROGRAM         reduce using rule 13 (var_declaration_2 -> ID var_declaration_3 COLON type_specifier SEMICOLON var_declaration_4 .)
    USES            reduce using rule 13 (var_declaration_2 -> ID var_declaration_3 COLON type_specifier SEMICOLON var_declaration_4 .)
    VAR             reduce using rule 13 (var_declaration_2 -> ID var_declaration_3 COLON type_specifier SEMICOLON var_declaration_4 .)
    FUNCTION        reduce using rule 13 (var_declaration_2 -> ID var_declaration_3 COLON type_specifier SEMICOLON var_declaration_4 .)
    PROCEDURE       reduce using rule 13 (var_declaration_2 -> ID var_declaration_3 COLON type_specifier SEMICOLON var_declaration_4 .)
    BEGIN           reduce using rule 13 (var_declaration_2 -> ID var_declaration_3 COLON type_specifier SEMICOLON var_declaration_4 .)
    $end            reduce using rule 13 (var_declaration_2 -> ID var_declaration_3 COLON type_specifier SEMICOLON var_declaration_4 .)


state 226

    (16) var_declaration_4 -> var_declaration_2 .

    PROGRAM         reduce using rule 16 (var_declaration_4 -> var_declaration_2 .)
    USES            reduce using rule 16 (var_declaration_4 -> var_declaration_2 .)
    VAR             reduce using rule 16 (var_declaration_4 -> var_declaration_2 .)
    FUNCTION        reduce using rule 16 (var_declaration_4 -> var_declaration_2 .)
    PROCEDURE       reduce using rule 16 (var_declaration_4 -> var_declaration_2 .)
    BEGIN           reduce using rule 16 (var_declaration_4 -> var_declaration_2 .)
    $end            reduce using rule 16 (var_declaration_4 -> var_declaration_2 .)


state 227

    (17) var_declaration_4 -> empty .

    PROGRAM         reduce using rule 17 (var_declaration_4 -> empty .)
    USES            reduce using rule 17 (var_declaration_4 -> empty .)
    VAR             reduce using rule 17 (var_declaration_4 -> empty .)
    FUNCTION        reduce using rule 17 (var_declaration_4 -> empty .)
    PROCEDURE       reduce using rule 17 (var_declaration_4 -> empty .)
    BEGIN           reduce using rule 17 (var_declaration_4 -> empty .)
    $end            reduce using rule 17 (var_declaration_4 -> empty .)


state 228

    (108) Begin_function -> BEGIN instruction END SEMICOLON . instruction
    (31) instruction -> . asignation instruction
    (32) instruction -> . writing instruction
    (33) instruction -> . cycles instruction
    (34) instruction -> . callFunctions instruction
    (35) instruction -> . empty
    (55) asignation -> . ID EQUAL callFunctions SEMICOLON
    (56) asignation -> . ID EQUAL math SEMICOLON
    (57) asignation -> . ID EQUAL boolean SEMICOLON
    (58) asignation -> . ID EQUAL TEXT SEMICOLON
    (49) writing -> . WRITELN LPAREN id_text_l TEXT id_text_r RPAREN SEMICOLON
    (50) writing -> . WRITELN LPAREN id_num RPAREN SEMICOLON
    (51) writing -> . READLN LPAREN ID RPAREN SEMICOLON
    (52) writing -> . READLN LPAREN RPAREN SEMICOLON
    (53) writing -> . READLN SEMICOLON
    (54) writing -> . WRITELN SEMICOLON
    (60) cycles -> . type_cycle
    (36) callFunctions -> . ID LPAREN params RPAREN
    (18) empty -> .
    (61) type_cycle -> . while
    (62) type_cycle -> . if
    (63) type_cycle -> . for
    (64) type_cycle -> . cycles instruction
    (65) while -> . WHILE internexpression op_cycle DO otherBegin
    (66) if -> . IF internexpression op_cycle THEN otherBegin_if
    (67) if -> . IF internexpression op_cycle THEN instruction_one_line
    (68) if -> . IF internexpression op_cycle THEN otherBegin_if ELSE otherBegin
    (69) if -> . IF internexpression op_cycle THEN otherBegin_if ELSE instruction_one_line
    (70) if -> . IF internexpression op_cycle THEN instruction_one_line ELSE otherBegin
    (71) if -> . IF internexpression op_cycle THEN instruction_one_line ELSE instruction_one_line
    (72) for -> . FOR asignation_for TO id_num DO otherBegin
    (73) for -> . FOR asignation_for DOWNTO id_num DO otherBegin

    ID              shift and go to state 24
    WRITELN         shift and go to state 23
    READLN          shift and go to state 29
    PROGRAM         reduce using rule 18 (empty -> .)
    USES            reduce using rule 18 (empty -> .)
    VAR             reduce using rule 18 (empty -> .)
    FUNCTION        reduce using rule 18 (empty -> .)
    PROCEDURE       reduce using rule 18 (empty -> .)
    BEGIN           reduce using rule 18 (empty -> .)
    $end            reduce using rule 18 (empty -> .)
    WHILE           shift and go to state 17
    IF              shift and go to state 25
    FOR             shift and go to state 22

    instruction                    shift and go to state 243
    if                             shift and go to state 20
    for                            shift and go to state 26
    writing                        shift and go to state 18
    callFunctions                  shift and go to state 19
    asignation                     shift and go to state 28
    type_cycle                     shift and go to state 30
    while                          shift and go to state 31
    empty                          shift and go to state 21
    cycles                         shift and go to state 32

state 229

    (107) Begin_function -> var_declaration BEGIN instruction END . SEMICOLON instruction

    SEMICOLON       shift and go to state 244


state 230

    (110) function_declaration -> PROCEDURE ID LPAREN fun_param RPAREN SEMICOLON Begin_function .

    PROGRAM         reduce using rule 110 (function_declaration -> PROCEDURE ID LPAREN fun_param RPAREN SEMICOLON Begin_function .)
    USES            reduce using rule 110 (function_declaration -> PROCEDURE ID LPAREN fun_param RPAREN SEMICOLON Begin_function .)
    VAR             reduce using rule 110 (function_declaration -> PROCEDURE ID LPAREN fun_param RPAREN SEMICOLON Begin_function .)
    FUNCTION        reduce using rule 110 (function_declaration -> PROCEDURE ID LPAREN fun_param RPAREN SEMICOLON Begin_function .)
    PROCEDURE       reduce using rule 110 (function_declaration -> PROCEDURE ID LPAREN fun_param RPAREN SEMICOLON Begin_function .)
    BEGIN           reduce using rule 110 (function_declaration -> PROCEDURE ID LPAREN fun_param RPAREN SEMICOLON Begin_function .)
    $end            reduce using rule 110 (function_declaration -> PROCEDURE ID LPAREN fun_param RPAREN SEMICOLON Begin_function .)


state 231

    (113) fun_param -> SEMICOLON ID fun_param_2 COLON type_specifier . fun_param
    (112) fun_param -> . ID fun_param_2 COLON type_specifier fun_param
    (113) fun_param -> . SEMICOLON ID fun_param_2 COLON type_specifier fun_param
    (114) fun_param -> . empty
    (18) empty -> .

    ID              shift and go to state 76
    SEMICOLON       shift and go to state 74
    RPAREN          reduce using rule 18 (empty -> .)

    fun_param                      shift and go to state 245
    empty                          shift and go to state 77

state 232

    (109) function_declaration -> FUNCTION ID LPAREN fun_param RPAREN COLON type_specifier SEMICOLON . Begin_function
    (107) Begin_function -> . var_declaration BEGIN instruction END SEMICOLON instruction
    (108) Begin_function -> . BEGIN instruction END SEMICOLON instruction
    (12) var_declaration -> . VAR var_declaration_2

    BEGIN           shift and go to state 131
    VAR             shift and go to state 9

    var_declaration                shift and go to state 132
    Begin_function                 shift and go to state 246

state 233

    (112) fun_param -> ID fun_param_2 COLON type_specifier fun_param .

    RPAREN          reduce using rule 112 (fun_param -> ID fun_param_2 COLON type_specifier fun_param .)


state 234

    (105) otherBegin -> BEGIN instruction END . SEMICOLON instruction

    SEMICOLON       shift and go to state 247


state 235

    (46) id_text_r -> COMMA callFunctions id_text_r .

    RPAREN          reduce using rule 46 (id_text_r -> COMMA callFunctions id_text_r .)


state 236

    (47) id_text_r -> COMMA ID id_text_r .

    RPAREN          reduce using rule 47 (id_text_r -> COMMA ID id_text_r .)


state 237

    (49) writing -> WRITELN LPAREN id_text_l TEXT id_text_r RPAREN SEMICOLON .

    ID              reduce using rule 49 (writing -> WRITELN LPAREN id_text_l TEXT id_text_r RPAREN SEMICOLON .)
    WRITELN         reduce using rule 49 (writing -> WRITELN LPAREN id_text_l TEXT id_text_r RPAREN SEMICOLON .)
    READLN          reduce using rule 49 (writing -> WRITELN LPAREN id_text_l TEXT id_text_r RPAREN SEMICOLON .)
    WHILE           reduce using rule 49 (writing -> WRITELN LPAREN id_text_l TEXT id_text_r RPAREN SEMICOLON .)
    IF              reduce using rule 49 (writing -> WRITELN LPAREN id_text_l TEXT id_text_r RPAREN SEMICOLON .)
    FOR             reduce using rule 49 (writing -> WRITELN LPAREN id_text_l TEXT id_text_r RPAREN SEMICOLON .)
    PROGRAM         reduce using rule 49 (writing -> WRITELN LPAREN id_text_l TEXT id_text_r RPAREN SEMICOLON .)
    USES            reduce using rule 49 (writing -> WRITELN LPAREN id_text_l TEXT id_text_r RPAREN SEMICOLON .)
    VAR             reduce using rule 49 (writing -> WRITELN LPAREN id_text_l TEXT id_text_r RPAREN SEMICOLON .)
    FUNCTION        reduce using rule 49 (writing -> WRITELN LPAREN id_text_l TEXT id_text_r RPAREN SEMICOLON .)
    PROCEDURE       reduce using rule 49 (writing -> WRITELN LPAREN id_text_l TEXT id_text_r RPAREN SEMICOLON .)
    BEGIN           reduce using rule 49 (writing -> WRITELN LPAREN id_text_l TEXT id_text_r RPAREN SEMICOLON .)
    $end            reduce using rule 49 (writing -> WRITELN LPAREN id_text_l TEXT id_text_r RPAREN SEMICOLON .)
    END             reduce using rule 49 (writing -> WRITELN LPAREN id_text_l TEXT id_text_r RPAREN SEMICOLON .)
    ELSE            reduce using rule 49 (writing -> WRITELN LPAREN id_text_l TEXT id_text_r RPAREN SEMICOLON .)


state 238

    (106) otherBegin_if -> BEGIN instruction END . instruction
    (31) instruction -> . asignation instruction
    (32) instruction -> . writing instruction
    (33) instruction -> . cycles instruction
    (34) instruction -> . callFunctions instruction
    (35) instruction -> . empty
    (55) asignation -> . ID EQUAL callFunctions SEMICOLON
    (56) asignation -> . ID EQUAL math SEMICOLON
    (57) asignation -> . ID EQUAL boolean SEMICOLON
    (58) asignation -> . ID EQUAL TEXT SEMICOLON
    (49) writing -> . WRITELN LPAREN id_text_l TEXT id_text_r RPAREN SEMICOLON
    (50) writing -> . WRITELN LPAREN id_num RPAREN SEMICOLON
    (51) writing -> . READLN LPAREN ID RPAREN SEMICOLON
    (52) writing -> . READLN LPAREN RPAREN SEMICOLON
    (53) writing -> . READLN SEMICOLON
    (54) writing -> . WRITELN SEMICOLON
    (60) cycles -> . type_cycle
    (36) callFunctions -> . ID LPAREN params RPAREN
    (18) empty -> .
    (61) type_cycle -> . while
    (62) type_cycle -> . if
    (63) type_cycle -> . for
    (64) type_cycle -> . cycles instruction
    (65) while -> . WHILE internexpression op_cycle DO otherBegin
    (66) if -> . IF internexpression op_cycle THEN otherBegin_if
    (67) if -> . IF internexpression op_cycle THEN instruction_one_line
    (68) if -> . IF internexpression op_cycle THEN otherBegin_if ELSE otherBegin
    (69) if -> . IF internexpression op_cycle THEN otherBegin_if ELSE instruction_one_line
    (70) if -> . IF internexpression op_cycle THEN instruction_one_line ELSE otherBegin
    (71) if -> . IF internexpression op_cycle THEN instruction_one_line ELSE instruction_one_line
    (72) for -> . FOR asignation_for TO id_num DO otherBegin
    (73) for -> . FOR asignation_for DOWNTO id_num DO otherBegin

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WRITELN resolved as shift
  ! shift/reduce conflict for READLN resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
    ID              shift and go to state 24
    WRITELN         shift and go to state 23
    READLN          shift and go to state 29
    END             reduce using rule 18 (empty -> .)
    ELSE            reduce using rule 18 (empty -> .)
    PROGRAM         reduce using rule 18 (empty -> .)
    USES            reduce using rule 18 (empty -> .)
    VAR             reduce using rule 18 (empty -> .)
    FUNCTION        reduce using rule 18 (empty -> .)
    PROCEDURE       reduce using rule 18 (empty -> .)
    BEGIN           reduce using rule 18 (empty -> .)
    $end            reduce using rule 18 (empty -> .)
    WHILE           shift and go to state 17
    IF              shift and go to state 25
    FOR             shift and go to state 22

  ! ID              [ reduce using rule 18 (empty -> .) ]
  ! WRITELN         [ reduce using rule 18 (empty -> .) ]
  ! READLN          [ reduce using rule 18 (empty -> .) ]
  ! WHILE           [ reduce using rule 18 (empty -> .) ]
  ! IF              [ reduce using rule 18 (empty -> .) ]
  ! FOR             [ reduce using rule 18 (empty -> .) ]

    instruction                    shift and go to state 248
    if                             shift and go to state 20
    for                            shift and go to state 26
    writing                        shift and go to state 18
    callFunctions                  shift and go to state 19
    asignation                     shift and go to state 28
    type_cycle                     shift and go to state 30
    while                          shift and go to state 31
    empty                          shift and go to state 21
    cycles                         shift and go to state 32

state 239

    (71) if -> IF internexpression op_cycle THEN instruction_one_line ELSE instruction_one_line .

    ID              reduce using rule 71 (if -> IF internexpression op_cycle THEN instruction_one_line ELSE instruction_one_line .)
    WRITELN         reduce using rule 71 (if -> IF internexpression op_cycle THEN instruction_one_line ELSE instruction_one_line .)
    READLN          reduce using rule 71 (if -> IF internexpression op_cycle THEN instruction_one_line ELSE instruction_one_line .)
    WHILE           reduce using rule 71 (if -> IF internexpression op_cycle THEN instruction_one_line ELSE instruction_one_line .)
    IF              reduce using rule 71 (if -> IF internexpression op_cycle THEN instruction_one_line ELSE instruction_one_line .)
    FOR             reduce using rule 71 (if -> IF internexpression op_cycle THEN instruction_one_line ELSE instruction_one_line .)
    END             reduce using rule 71 (if -> IF internexpression op_cycle THEN instruction_one_line ELSE instruction_one_line .)
    ELSE            reduce using rule 71 (if -> IF internexpression op_cycle THEN instruction_one_line ELSE instruction_one_line .)
    PROGRAM         reduce using rule 71 (if -> IF internexpression op_cycle THEN instruction_one_line ELSE instruction_one_line .)
    USES            reduce using rule 71 (if -> IF internexpression op_cycle THEN instruction_one_line ELSE instruction_one_line .)
    VAR             reduce using rule 71 (if -> IF internexpression op_cycle THEN instruction_one_line ELSE instruction_one_line .)
    FUNCTION        reduce using rule 71 (if -> IF internexpression op_cycle THEN instruction_one_line ELSE instruction_one_line .)
    PROCEDURE       reduce using rule 71 (if -> IF internexpression op_cycle THEN instruction_one_line ELSE instruction_one_line .)
    BEGIN           reduce using rule 71 (if -> IF internexpression op_cycle THEN instruction_one_line ELSE instruction_one_line .)
    $end            reduce using rule 71 (if -> IF internexpression op_cycle THEN instruction_one_line ELSE instruction_one_line .)


state 240

    (70) if -> IF internexpression op_cycle THEN instruction_one_line ELSE otherBegin .

    ID              reduce using rule 70 (if -> IF internexpression op_cycle THEN instruction_one_line ELSE otherBegin .)
    WRITELN         reduce using rule 70 (if -> IF internexpression op_cycle THEN instruction_one_line ELSE otherBegin .)
    READLN          reduce using rule 70 (if -> IF internexpression op_cycle THEN instruction_one_line ELSE otherBegin .)
    WHILE           reduce using rule 70 (if -> IF internexpression op_cycle THEN instruction_one_line ELSE otherBegin .)
    IF              reduce using rule 70 (if -> IF internexpression op_cycle THEN instruction_one_line ELSE otherBegin .)
    FOR             reduce using rule 70 (if -> IF internexpression op_cycle THEN instruction_one_line ELSE otherBegin .)
    END             reduce using rule 70 (if -> IF internexpression op_cycle THEN instruction_one_line ELSE otherBegin .)
    ELSE            reduce using rule 70 (if -> IF internexpression op_cycle THEN instruction_one_line ELSE otherBegin .)
    PROGRAM         reduce using rule 70 (if -> IF internexpression op_cycle THEN instruction_one_line ELSE otherBegin .)
    USES            reduce using rule 70 (if -> IF internexpression op_cycle THEN instruction_one_line ELSE otherBegin .)
    VAR             reduce using rule 70 (if -> IF internexpression op_cycle THEN instruction_one_line ELSE otherBegin .)
    FUNCTION        reduce using rule 70 (if -> IF internexpression op_cycle THEN instruction_one_line ELSE otherBegin .)
    PROCEDURE       reduce using rule 70 (if -> IF internexpression op_cycle THEN instruction_one_line ELSE otherBegin .)
    BEGIN           reduce using rule 70 (if -> IF internexpression op_cycle THEN instruction_one_line ELSE otherBegin .)
    $end            reduce using rule 70 (if -> IF internexpression op_cycle THEN instruction_one_line ELSE otherBegin .)


state 241

    (69) if -> IF internexpression op_cycle THEN otherBegin_if ELSE instruction_one_line .

    ID              reduce using rule 69 (if -> IF internexpression op_cycle THEN otherBegin_if ELSE instruction_one_line .)
    WRITELN         reduce using rule 69 (if -> IF internexpression op_cycle THEN otherBegin_if ELSE instruction_one_line .)
    READLN          reduce using rule 69 (if -> IF internexpression op_cycle THEN otherBegin_if ELSE instruction_one_line .)
    WHILE           reduce using rule 69 (if -> IF internexpression op_cycle THEN otherBegin_if ELSE instruction_one_line .)
    IF              reduce using rule 69 (if -> IF internexpression op_cycle THEN otherBegin_if ELSE instruction_one_line .)
    FOR             reduce using rule 69 (if -> IF internexpression op_cycle THEN otherBegin_if ELSE instruction_one_line .)
    END             reduce using rule 69 (if -> IF internexpression op_cycle THEN otherBegin_if ELSE instruction_one_line .)
    ELSE            reduce using rule 69 (if -> IF internexpression op_cycle THEN otherBegin_if ELSE instruction_one_line .)
    PROGRAM         reduce using rule 69 (if -> IF internexpression op_cycle THEN otherBegin_if ELSE instruction_one_line .)
    USES            reduce using rule 69 (if -> IF internexpression op_cycle THEN otherBegin_if ELSE instruction_one_line .)
    VAR             reduce using rule 69 (if -> IF internexpression op_cycle THEN otherBegin_if ELSE instruction_one_line .)
    FUNCTION        reduce using rule 69 (if -> IF internexpression op_cycle THEN otherBegin_if ELSE instruction_one_line .)
    PROCEDURE       reduce using rule 69 (if -> IF internexpression op_cycle THEN otherBegin_if ELSE instruction_one_line .)
    BEGIN           reduce using rule 69 (if -> IF internexpression op_cycle THEN otherBegin_if ELSE instruction_one_line .)
    $end            reduce using rule 69 (if -> IF internexpression op_cycle THEN otherBegin_if ELSE instruction_one_line .)


state 242

    (68) if -> IF internexpression op_cycle THEN otherBegin_if ELSE otherBegin .

    ID              reduce using rule 68 (if -> IF internexpression op_cycle THEN otherBegin_if ELSE otherBegin .)
    WRITELN         reduce using rule 68 (if -> IF internexpression op_cycle THEN otherBegin_if ELSE otherBegin .)
    READLN          reduce using rule 68 (if -> IF internexpression op_cycle THEN otherBegin_if ELSE otherBegin .)
    WHILE           reduce using rule 68 (if -> IF internexpression op_cycle THEN otherBegin_if ELSE otherBegin .)
    IF              reduce using rule 68 (if -> IF internexpression op_cycle THEN otherBegin_if ELSE otherBegin .)
    FOR             reduce using rule 68 (if -> IF internexpression op_cycle THEN otherBegin_if ELSE otherBegin .)
    END             reduce using rule 68 (if -> IF internexpression op_cycle THEN otherBegin_if ELSE otherBegin .)
    ELSE            reduce using rule 68 (if -> IF internexpression op_cycle THEN otherBegin_if ELSE otherBegin .)
    PROGRAM         reduce using rule 68 (if -> IF internexpression op_cycle THEN otherBegin_if ELSE otherBegin .)
    USES            reduce using rule 68 (if -> IF internexpression op_cycle THEN otherBegin_if ELSE otherBegin .)
    VAR             reduce using rule 68 (if -> IF internexpression op_cycle THEN otherBegin_if ELSE otherBegin .)
    FUNCTION        reduce using rule 68 (if -> IF internexpression op_cycle THEN otherBegin_if ELSE otherBegin .)
    PROCEDURE       reduce using rule 68 (if -> IF internexpression op_cycle THEN otherBegin_if ELSE otherBegin .)
    BEGIN           reduce using rule 68 (if -> IF internexpression op_cycle THEN otherBegin_if ELSE otherBegin .)
    $end            reduce using rule 68 (if -> IF internexpression op_cycle THEN otherBegin_if ELSE otherBegin .)


state 243

    (108) Begin_function -> BEGIN instruction END SEMICOLON instruction .

    PROGRAM         reduce using rule 108 (Begin_function -> BEGIN instruction END SEMICOLON instruction .)
    USES            reduce using rule 108 (Begin_function -> BEGIN instruction END SEMICOLON instruction .)
    VAR             reduce using rule 108 (Begin_function -> BEGIN instruction END SEMICOLON instruction .)
    FUNCTION        reduce using rule 108 (Begin_function -> BEGIN instruction END SEMICOLON instruction .)
    PROCEDURE       reduce using rule 108 (Begin_function -> BEGIN instruction END SEMICOLON instruction .)
    BEGIN           reduce using rule 108 (Begin_function -> BEGIN instruction END SEMICOLON instruction .)
    $end            reduce using rule 108 (Begin_function -> BEGIN instruction END SEMICOLON instruction .)


state 244

    (107) Begin_function -> var_declaration BEGIN instruction END SEMICOLON . instruction
    (31) instruction -> . asignation instruction
    (32) instruction -> . writing instruction
    (33) instruction -> . cycles instruction
    (34) instruction -> . callFunctions instruction
    (35) instruction -> . empty
    (55) asignation -> . ID EQUAL callFunctions SEMICOLON
    (56) asignation -> . ID EQUAL math SEMICOLON
    (57) asignation -> . ID EQUAL boolean SEMICOLON
    (58) asignation -> . ID EQUAL TEXT SEMICOLON
    (49) writing -> . WRITELN LPAREN id_text_l TEXT id_text_r RPAREN SEMICOLON
    (50) writing -> . WRITELN LPAREN id_num RPAREN SEMICOLON
    (51) writing -> . READLN LPAREN ID RPAREN SEMICOLON
    (52) writing -> . READLN LPAREN RPAREN SEMICOLON
    (53) writing -> . READLN SEMICOLON
    (54) writing -> . WRITELN SEMICOLON
    (60) cycles -> . type_cycle
    (36) callFunctions -> . ID LPAREN params RPAREN
    (18) empty -> .
    (61) type_cycle -> . while
    (62) type_cycle -> . if
    (63) type_cycle -> . for
    (64) type_cycle -> . cycles instruction
    (65) while -> . WHILE internexpression op_cycle DO otherBegin
    (66) if -> . IF internexpression op_cycle THEN otherBegin_if
    (67) if -> . IF internexpression op_cycle THEN instruction_one_line
    (68) if -> . IF internexpression op_cycle THEN otherBegin_if ELSE otherBegin
    (69) if -> . IF internexpression op_cycle THEN otherBegin_if ELSE instruction_one_line
    (70) if -> . IF internexpression op_cycle THEN instruction_one_line ELSE otherBegin
    (71) if -> . IF internexpression op_cycle THEN instruction_one_line ELSE instruction_one_line
    (72) for -> . FOR asignation_for TO id_num DO otherBegin
    (73) for -> . FOR asignation_for DOWNTO id_num DO otherBegin

    ID              shift and go to state 24
    WRITELN         shift and go to state 23
    READLN          shift and go to state 29
    PROGRAM         reduce using rule 18 (empty -> .)
    USES            reduce using rule 18 (empty -> .)
    VAR             reduce using rule 18 (empty -> .)
    FUNCTION        reduce using rule 18 (empty -> .)
    PROCEDURE       reduce using rule 18 (empty -> .)
    BEGIN           reduce using rule 18 (empty -> .)
    $end            reduce using rule 18 (empty -> .)
    WHILE           shift and go to state 17
    IF              shift and go to state 25
    FOR             shift and go to state 22

    instruction                    shift and go to state 249
    if                             shift and go to state 20
    for                            shift and go to state 26
    writing                        shift and go to state 18
    callFunctions                  shift and go to state 19
    asignation                     shift and go to state 28
    type_cycle                     shift and go to state 30
    while                          shift and go to state 31
    empty                          shift and go to state 21
    cycles                         shift and go to state 32

state 245

    (113) fun_param -> SEMICOLON ID fun_param_2 COLON type_specifier fun_param .

    RPAREN          reduce using rule 113 (fun_param -> SEMICOLON ID fun_param_2 COLON type_specifier fun_param .)


state 246

    (109) function_declaration -> FUNCTION ID LPAREN fun_param RPAREN COLON type_specifier SEMICOLON Begin_function .

    PROGRAM         reduce using rule 109 (function_declaration -> FUNCTION ID LPAREN fun_param RPAREN COLON type_specifier SEMICOLON Begin_function .)
    USES            reduce using rule 109 (function_declaration -> FUNCTION ID LPAREN fun_param RPAREN COLON type_specifier SEMICOLON Begin_function .)
    VAR             reduce using rule 109 (function_declaration -> FUNCTION ID LPAREN fun_param RPAREN COLON type_specifier SEMICOLON Begin_function .)
    FUNCTION        reduce using rule 109 (function_declaration -> FUNCTION ID LPAREN fun_param RPAREN COLON type_specifier SEMICOLON Begin_function .)
    PROCEDURE       reduce using rule 109 (function_declaration -> FUNCTION ID LPAREN fun_param RPAREN COLON type_specifier SEMICOLON Begin_function .)
    BEGIN           reduce using rule 109 (function_declaration -> FUNCTION ID LPAREN fun_param RPAREN COLON type_specifier SEMICOLON Begin_function .)
    $end            reduce using rule 109 (function_declaration -> FUNCTION ID LPAREN fun_param RPAREN COLON type_specifier SEMICOLON Begin_function .)


state 247

    (105) otherBegin -> BEGIN instruction END SEMICOLON . instruction
    (31) instruction -> . asignation instruction
    (32) instruction -> . writing instruction
    (33) instruction -> . cycles instruction
    (34) instruction -> . callFunctions instruction
    (35) instruction -> . empty
    (55) asignation -> . ID EQUAL callFunctions SEMICOLON
    (56) asignation -> . ID EQUAL math SEMICOLON
    (57) asignation -> . ID EQUAL boolean SEMICOLON
    (58) asignation -> . ID EQUAL TEXT SEMICOLON
    (49) writing -> . WRITELN LPAREN id_text_l TEXT id_text_r RPAREN SEMICOLON
    (50) writing -> . WRITELN LPAREN id_num RPAREN SEMICOLON
    (51) writing -> . READLN LPAREN ID RPAREN SEMICOLON
    (52) writing -> . READLN LPAREN RPAREN SEMICOLON
    (53) writing -> . READLN SEMICOLON
    (54) writing -> . WRITELN SEMICOLON
    (60) cycles -> . type_cycle
    (36) callFunctions -> . ID LPAREN params RPAREN
    (18) empty -> .
    (61) type_cycle -> . while
    (62) type_cycle -> . if
    (63) type_cycle -> . for
    (64) type_cycle -> . cycles instruction
    (65) while -> . WHILE internexpression op_cycle DO otherBegin
    (66) if -> . IF internexpression op_cycle THEN otherBegin_if
    (67) if -> . IF internexpression op_cycle THEN instruction_one_line
    (68) if -> . IF internexpression op_cycle THEN otherBegin_if ELSE otherBegin
    (69) if -> . IF internexpression op_cycle THEN otherBegin_if ELSE instruction_one_line
    (70) if -> . IF internexpression op_cycle THEN instruction_one_line ELSE otherBegin
    (71) if -> . IF internexpression op_cycle THEN instruction_one_line ELSE instruction_one_line
    (72) for -> . FOR asignation_for TO id_num DO otherBegin
    (73) for -> . FOR asignation_for DOWNTO id_num DO otherBegin

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WRITELN resolved as shift
  ! shift/reduce conflict for READLN resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
    ID              shift and go to state 24
    WRITELN         shift and go to state 23
    READLN          shift and go to state 29
    END             reduce using rule 18 (empty -> .)
    ELSE            reduce using rule 18 (empty -> .)
    PROGRAM         reduce using rule 18 (empty -> .)
    USES            reduce using rule 18 (empty -> .)
    VAR             reduce using rule 18 (empty -> .)
    FUNCTION        reduce using rule 18 (empty -> .)
    PROCEDURE       reduce using rule 18 (empty -> .)
    BEGIN           reduce using rule 18 (empty -> .)
    $end            reduce using rule 18 (empty -> .)
    WHILE           shift and go to state 17
    IF              shift and go to state 25
    FOR             shift and go to state 22

  ! ID              [ reduce using rule 18 (empty -> .) ]
  ! WRITELN         [ reduce using rule 18 (empty -> .) ]
  ! READLN          [ reduce using rule 18 (empty -> .) ]
  ! WHILE           [ reduce using rule 18 (empty -> .) ]
  ! IF              [ reduce using rule 18 (empty -> .) ]
  ! FOR             [ reduce using rule 18 (empty -> .) ]

    instruction                    shift and go to state 250
    if                             shift and go to state 20
    for                            shift and go to state 26
    writing                        shift and go to state 18
    callFunctions                  shift and go to state 19
    asignation                     shift and go to state 28
    type_cycle                     shift and go to state 30
    while                          shift and go to state 31
    empty                          shift and go to state 21
    cycles                         shift and go to state 32

state 248

    (106) otherBegin_if -> BEGIN instruction END instruction .

    END             reduce using rule 106 (otherBegin_if -> BEGIN instruction END instruction .)
    ID              reduce using rule 106 (otherBegin_if -> BEGIN instruction END instruction .)
    WRITELN         reduce using rule 106 (otherBegin_if -> BEGIN instruction END instruction .)
    READLN          reduce using rule 106 (otherBegin_if -> BEGIN instruction END instruction .)
    WHILE           reduce using rule 106 (otherBegin_if -> BEGIN instruction END instruction .)
    IF              reduce using rule 106 (otherBegin_if -> BEGIN instruction END instruction .)
    FOR             reduce using rule 106 (otherBegin_if -> BEGIN instruction END instruction .)
    ELSE            reduce using rule 106 (otherBegin_if -> BEGIN instruction END instruction .)
    PROGRAM         reduce using rule 106 (otherBegin_if -> BEGIN instruction END instruction .)
    USES            reduce using rule 106 (otherBegin_if -> BEGIN instruction END instruction .)
    VAR             reduce using rule 106 (otherBegin_if -> BEGIN instruction END instruction .)
    FUNCTION        reduce using rule 106 (otherBegin_if -> BEGIN instruction END instruction .)
    PROCEDURE       reduce using rule 106 (otherBegin_if -> BEGIN instruction END instruction .)
    BEGIN           reduce using rule 106 (otherBegin_if -> BEGIN instruction END instruction .)
    $end            reduce using rule 106 (otherBegin_if -> BEGIN instruction END instruction .)


state 249

    (107) Begin_function -> var_declaration BEGIN instruction END SEMICOLON instruction .

    PROGRAM         reduce using rule 107 (Begin_function -> var_declaration BEGIN instruction END SEMICOLON instruction .)
    USES            reduce using rule 107 (Begin_function -> var_declaration BEGIN instruction END SEMICOLON instruction .)
    VAR             reduce using rule 107 (Begin_function -> var_declaration BEGIN instruction END SEMICOLON instruction .)
    FUNCTION        reduce using rule 107 (Begin_function -> var_declaration BEGIN instruction END SEMICOLON instruction .)
    PROCEDURE       reduce using rule 107 (Begin_function -> var_declaration BEGIN instruction END SEMICOLON instruction .)
    BEGIN           reduce using rule 107 (Begin_function -> var_declaration BEGIN instruction END SEMICOLON instruction .)
    $end            reduce using rule 107 (Begin_function -> var_declaration BEGIN instruction END SEMICOLON instruction .)


state 250

    (105) otherBegin -> BEGIN instruction END SEMICOLON instruction .

    END             reduce using rule 105 (otherBegin -> BEGIN instruction END SEMICOLON instruction .)
    ID              reduce using rule 105 (otherBegin -> BEGIN instruction END SEMICOLON instruction .)
    WRITELN         reduce using rule 105 (otherBegin -> BEGIN instruction END SEMICOLON instruction .)
    READLN          reduce using rule 105 (otherBegin -> BEGIN instruction END SEMICOLON instruction .)
    WHILE           reduce using rule 105 (otherBegin -> BEGIN instruction END SEMICOLON instruction .)
    IF              reduce using rule 105 (otherBegin -> BEGIN instruction END SEMICOLON instruction .)
    FOR             reduce using rule 105 (otherBegin -> BEGIN instruction END SEMICOLON instruction .)
    ELSE            reduce using rule 105 (otherBegin -> BEGIN instruction END SEMICOLON instruction .)
    PROGRAM         reduce using rule 105 (otherBegin -> BEGIN instruction END SEMICOLON instruction .)
    USES            reduce using rule 105 (otherBegin -> BEGIN instruction END SEMICOLON instruction .)
    VAR             reduce using rule 105 (otherBegin -> BEGIN instruction END SEMICOLON instruction .)
    FUNCTION        reduce using rule 105 (otherBegin -> BEGIN instruction END SEMICOLON instruction .)
    PROCEDURE       reduce using rule 105 (otherBegin -> BEGIN instruction END SEMICOLON instruction .)
    BEGIN           reduce using rule 105 (otherBegin -> BEGIN instruction END SEMICOLON instruction .)
    $end            reduce using rule 105 (otherBegin -> BEGIN instruction END SEMICOLON instruction .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ID in state 18 resolved as shift
WARNING: shift/reduce conflict for WRITELN in state 18 resolved as shift
WARNING: shift/reduce conflict for READLN in state 18 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 18 resolved as shift
WARNING: shift/reduce conflict for IF in state 18 resolved as shift
WARNING: shift/reduce conflict for FOR in state 18 resolved as shift
WARNING: shift/reduce conflict for ID in state 19 resolved as shift
WARNING: shift/reduce conflict for WRITELN in state 19 resolved as shift
WARNING: shift/reduce conflict for READLN in state 19 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 19 resolved as shift
WARNING: shift/reduce conflict for IF in state 19 resolved as shift
WARNING: shift/reduce conflict for FOR in state 19 resolved as shift
WARNING: shift/reduce conflict for ID in state 28 resolved as shift
WARNING: shift/reduce conflict for WRITELN in state 28 resolved as shift
WARNING: shift/reduce conflict for READLN in state 28 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 28 resolved as shift
WARNING: shift/reduce conflict for IF in state 28 resolved as shift
WARNING: shift/reduce conflict for FOR in state 28 resolved as shift
WARNING: shift/reduce conflict for ID in state 32 resolved as shift
WARNING: shift/reduce conflict for WRITELN in state 32 resolved as shift
WARNING: shift/reduce conflict for READLN in state 32 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 32 resolved as shift
WARNING: shift/reduce conflict for IF in state 32 resolved as shift
WARNING: shift/reduce conflict for FOR in state 32 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 201 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 204 resolved as shift
WARNING: shift/reduce conflict for ID in state 205 resolved as shift
WARNING: shift/reduce conflict for WRITELN in state 205 resolved as shift
WARNING: shift/reduce conflict for READLN in state 205 resolved as shift
WARNING: shift/reduce conflict for ID in state 205 resolved as shift
WARNING: shift/reduce conflict for WRITELN in state 205 resolved as shift
WARNING: shift/reduce conflict for READLN in state 205 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 205 resolved as shift
WARNING: shift/reduce conflict for IF in state 205 resolved as shift
WARNING: shift/reduce conflict for FOR in state 205 resolved as shift
WARNING: shift/reduce conflict for ID in state 238 resolved as shift
WARNING: shift/reduce conflict for WRITELN in state 238 resolved as shift
WARNING: shift/reduce conflict for READLN in state 238 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 238 resolved as shift
WARNING: shift/reduce conflict for IF in state 238 resolved as shift
WARNING: shift/reduce conflict for FOR in state 238 resolved as shift
WARNING: shift/reduce conflict for ID in state 247 resolved as shift
WARNING: shift/reduce conflict for WRITELN in state 247 resolved as shift
WARNING: shift/reduce conflict for READLN in state 247 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 247 resolved as shift
WARNING: shift/reduce conflict for IF in state 247 resolved as shift
WARNING: shift/reduce conflict for FOR in state 247 resolved as shift
WARNING: reduce/reduce conflict in state 53 resolved using rule (factor -> ID)
WARNING: rejected rule (expression -> ID) in state 53
WARNING: reduce/reduce conflict in state 68 resolved using rule (instruction -> cycles instruction)
WARNING: rejected rule (type_cycle -> cycles instruction) in state 68
WARNING: reduce/reduce conflict in state 205 resolved using rule (empty -> <empty>)
WARNING: rejected rule (instruction_one_line -> cycles) in state 205
WARNING: Rule (instruction_one_line -> cycles) is never reduced
