Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    OBJECT
    LBRACKET
    FILE
    PACKED
    ABSOLUTE
    RECORD
    IMPLEMENTATION
    LONG
    GOTO
    REINTRODUCE
    NIL
    OF
    INTERFACE
    LABEL
    AMPERSANT
    BREAK
    WITH
    SHR
    REPEAT
    PLUSPLUS
    RBLOCK
    INHERITED
    OPERATOR
    SHL
    UNTIL
    UNIT
    CLRSCR
    CASE
    SET
    ARRAY
    ASM
    WRITE
    INLINE
    TYPE
    CONST
    CONSTRUCTOR
    STRING
    IN
    LBLOCK
    MINUSMINUS
    SELF
    FLOAT
    DISTINT
    DESTRUCTOR
    HASHTAG
    RBRACKET

Grammar

Rule 0     S' -> program
Rule 1     program -> declaration_list
Rule 2     declaration_list -> declaration_list declaration
Rule 3     declaration_list -> declaration
Rule 4     declaration -> header_declaration
Rule 5     declaration -> var_declaration
Rule 6     declaration -> function_declaration
Rule 7     declaration -> procedure_declaration
Rule 8     header_declaration -> PROGRAM ID SEMICOLON
Rule 9     header_declaration -> USES ID header_declaration_3 SEMICOLON
Rule 10    header_declaration_3 -> COMMA ID header_declaration_3
Rule 11    header_declaration_3 -> empty
Rule 12    var_declaration -> VAR var_declaration_2
Rule 13    var_declaration_2 -> ID var_declaration_3 COLON type_specifier SEMICOLON var_declaration_4
Rule 14    var_declaration_3 -> COMMA ID var_declaration_3
Rule 15    var_declaration_3 -> empty
Rule 16    var_declaration_4 -> var_declaration_2
Rule 17    var_declaration_4 -> empty
Rule 18    empty -> <empty>
Rule 19    math -> factor mathi
Rule 20    mathi -> type_op_math factor mathi
Rule 21    mathi -> empty
Rule 22    factor -> LPAREN math RPAREN
Rule 23    factor -> NUMBER
Rule 24    factor -> ID
Rule 25    type_specifier -> INTEGER
Rule 26    type_specifier -> REAL
Rule 27    type_specifier -> CHAR
Rule 28    type_specifier -> BOOLEAN
Rule 29    type_specifier -> DOUBLE
Rule 30    procedure_declaration -> BEGIN instruction END DOT
Rule 31    instruction -> asignation instruction
Rule 32    instruction -> writing instruction
Rule 33    instruction -> cycles instruction
Rule 34    instruction -> callFunctions instruction
Rule 35    instruction -> empty
Rule 36    callFunctions -> ID LPAREN params RPAREN
Rule 37    params -> math params2
Rule 38    params2 -> COMMA math
Rule 39    params2 -> empty
Rule 40    instruction_one_line -> asignation
Rule 41    instruction_one_line -> writing
Rule 42    instruction_one_line -> cycles
Rule 43    id_text_l -> callFunctions COMMA id_text_l
Rule 44    id_text_l -> ID COMMA id_text_l
Rule 45    id_text_l -> empty
Rule 46    id_text_r -> COMMA callFunctions id_text_r
Rule 47    id_text_r -> COMMA ID id_text_r
Rule 48    id_text_r -> empty
Rule 49    writing -> WRITELN LPAREN id_text_l TEXT id_text_r RPAREN SEMICOLON
Rule 50    writing -> WRITELN LPAREN id_num RPAREN SEMICOLON
Rule 51    writing -> READLN LPAREN ID RPAREN SEMICOLON
Rule 52    writing -> READLN LPAREN RPAREN SEMICOLON
Rule 53    writing -> READLN SEMICOLON
Rule 54    writing -> WRITELN SEMICOLON
Rule 55    asignation -> ID EQUAL callFunctions SEMICOLON
Rule 56    asignation -> ID EQUAL math SEMICOLON
Rule 57    asignation -> ID EQUAL boolean SEMICOLON
Rule 58    asignation -> ID EQUAL TEXT SEMICOLON
Rule 59    asignation_for -> ID EQUAL id_num
Rule 60    cycles -> type_cycle
Rule 61    type_cycle -> while
Rule 62    type_cycle -> if
Rule 63    type_cycle -> for
Rule 64    type_cycle -> cycles instruction
Rule 65    while -> WHILE internexpression op_cycle DO otherBegin
Rule 66    if -> IF internexpression op_cycle THEN otherBegin_if
Rule 67    if -> IF internexpression op_cycle THEN instruction_one_line
Rule 68    if -> IF internexpression op_cycle THEN otherBegin_if ELSE otherBegin
Rule 69    if -> IF internexpression op_cycle THEN otherBegin_if ELSE instruction_one_line
Rule 70    if -> IF internexpression op_cycle THEN instruction_one_line ELSE otherBegin
Rule 71    if -> IF internexpression op_cycle THEN instruction_one_line ELSE instruction_one_line
Rule 72    for -> FOR asignation_for TO id_num DO otherBegin
Rule 73    for -> FOR asignation_for DOWNTO id_num DO otherBegin
Rule 74    op_cycle -> op_logic internexpression op_cycle
Rule 75    op_cycle -> empty
Rule 76    internexpression -> parentheses
Rule 77    internexpression -> expression
Rule 78    parentheses -> LPAREN expression RPAREN
Rule 79    expression -> callFunctions
Rule 80    expression -> callFunctions type_op math
Rule 81    expression -> callFunctions type_op callFunctions
Rule 82    expression -> math type_op math
Rule 83    expression -> ID
Rule 84    expression -> math ISEQUAL boolean
Rule 85    expression -> boolean ISEQUAL math
Rule 86    expression -> expression2
Rule 87    expression2 -> TEXT type_op TEXT
Rule 88    expression2 -> TEXT type_op ID
Rule 89    type_op -> LESSEQUAL
Rule 90    type_op -> LESS
Rule 91    type_op -> GREATER
Rule 92    type_op -> GREATEREQUAL
Rule 93    type_op -> DEQUAL
Rule 94    type_op -> ISEQUAL
Rule 95    type_op_math -> PLUS
Rule 96    type_op_math -> MINUS
Rule 97    type_op_math -> TIMES
Rule 98    type_op_math -> DIVIDE
Rule 99    type_op_math -> MOD
Rule 100   op_logic -> AND
Rule 101   op_logic -> OR
Rule 102   op_logic -> XOR
Rule 103   op_logic -> NOT
Rule 104   id_num -> NUMBER
Rule 105   id_num -> ID
Rule 106   boolean -> TRUE
Rule 107   boolean -> FALSE
Rule 108   otherBegin -> BEGIN instruction END SEMICOLON instruction
Rule 109   otherBegin_if -> BEGIN instruction END instruction
Rule 110   Begin_function -> var_declaration BEGIN instruction END SEMICOLON instruction
Rule 111   Begin_function -> BEGIN instruction END SEMICOLON instruction
Rule 112   function_declaration -> FUNCTION ID LPAREN fun_param RPAREN COLON type_specifier SEMICOLON Begin_function
Rule 113   function_declaration -> PROCEDURE ID LPAREN fun_param RPAREN SEMICOLON Begin_function
Rule 114   function_declaration -> PROCEDURE ID SEMICOLON Begin_function
Rule 115   fun_param -> ID fun_param_2 COLON type_specifier fun_param
Rule 116   fun_param -> SEMICOLON ID fun_param_2 COLON type_specifier fun_param
Rule 117   fun_param -> empty
Rule 118   fun_param_2 -> COMMA ID fun_param_2
Rule 119   fun_param_2 -> empty

Terminals, with rules where they appear

ABSOLUTE             : 
AMPERSANT            : 
AND                  : 100
ARRAY                : 
ASM                  : 
BEGIN                : 30 108 109 110 111
BOOLEAN              : 28
BREAK                : 
CASE                 : 
CHAR                 : 27
CLRSCR               : 
COLON                : 13 112 115 116
COMMA                : 10 14 38 43 44 46 47 118
CONST                : 
CONSTRUCTOR          : 
DEQUAL               : 93
DESTRUCTOR           : 
DISTINT              : 
DIVIDE               : 98
DO                   : 65 72 73
DOT                  : 30
DOUBLE               : 29
DOWNTO               : 73
ELSE                 : 68 69 70 71
END                  : 30 108 109 110 111
EQUAL                : 55 56 57 58 59
FALSE                : 107
FILE                 : 
FLOAT                : 
FOR                  : 72 73
FUNCTION             : 112
GOTO                 : 
GREATER              : 91
GREATEREQUAL         : 92
HASHTAG              : 
ID                   : 8 9 10 13 14 24 36 44 47 51 55 56 57 58 59 83 88 105 112 113 114 115 116 118
IF                   : 66 67 68 69 70 71
IMPLEMENTATION       : 
IN                   : 
INHERITED            : 
INLINE               : 
INTEGER              : 25
INTERFACE            : 
ISEQUAL              : 84 85 94
LABEL                : 
LBLOCK               : 
LBRACKET             : 
LESS                 : 90
LESSEQUAL            : 89
LONG                 : 
LPAREN               : 22 36 49 50 51 52 78 112 113
MINUS                : 96
MINUSMINUS           : 
MOD                  : 99
NIL                  : 
NOT                  : 103
NUMBER               : 23 104
OBJECT               : 
OF                   : 
OPERATOR             : 
OR                   : 101
PACKED               : 
PLUS                 : 95
PLUSPLUS             : 
PROCEDURE            : 113 114
PROGRAM              : 8
RBLOCK               : 
RBRACKET             : 
READLN               : 51 52 53
REAL                 : 26
RECORD               : 
REINTRODUCE          : 
REPEAT               : 
RPAREN               : 22 36 49 50 51 52 78 112 113
SELF                 : 
SEMICOLON            : 8 9 13 49 50 51 52 53 54 55 56 57 58 108 110 111 112 113 114 116
SET                  : 
SHL                  : 
SHR                  : 
STRING               : 
TEXT                 : 49 58 87 87 88
THEN                 : 66 67 68 69 70 71
TIMES                : 97
TO                   : 72
TRUE                 : 106
TYPE                 : 
UNIT                 : 
UNTIL                : 
USES                 : 9
VAR                  : 12
WHILE                : 65
WITH                 : 
WRITE                : 
WRITELN              : 49 50 54
XOR                  : 102
error                : 

Nonterminals, with rules where they appear

Begin_function       : 112 113 114
asignation           : 31 40
asignation_for       : 72 73
boolean              : 57 84 85
callFunctions        : 34 43 46 55 79 80 81 81
cycles               : 33 42 64
declaration          : 2 3
declaration_list     : 1 2
empty                : 11 15 17 21 35 39 45 48 75 117 119
expression           : 77 78
expression2          : 86
factor               : 19 20
for                  : 63
fun_param            : 112 113 115 116
fun_param_2          : 115 116 118
function_declaration : 6
header_declaration   : 4
header_declaration_3 : 9 10
id_num               : 50 59 72 73
id_text_l            : 43 44 49
id_text_r            : 46 47 49
if                   : 62
instruction          : 30 31 32 33 34 64 108 108 109 109 110 110 111 111
instruction_one_line : 67 69 70 71 71
internexpression     : 65 66 67 68 69 70 71 74
math                 : 22 37 38 56 80 82 82 84 85
mathi                : 19 20
op_cycle             : 65 66 67 68 69 70 71 74
op_logic             : 74
otherBegin           : 65 68 70 72 73
otherBegin_if        : 66 68 69
params               : 36
params2              : 37
parentheses          : 76
procedure_declaration : 7
program              : 0
type_cycle           : 60
type_op              : 80 81 82 87 88
type_op_math         : 20
type_specifier       : 13 112 115 116
var_declaration      : 5 110
var_declaration_2    : 12 16
var_declaration_3    : 13 14
var_declaration_4    : 13
while                : 61
writing              : 32 41

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . declaration_list
    (2) declaration_list -> . declaration_list declaration
    (3) declaration_list -> . declaration
    (4) declaration -> . header_declaration
    (5) declaration -> . var_declaration
    (6) declaration -> . function_declaration
    (7) declaration -> . procedure_declaration
    (8) header_declaration -> . PROGRAM ID SEMICOLON
    (9) header_declaration -> . USES ID header_declaration_3 SEMICOLON
    (12) var_declaration -> . VAR var_declaration_2
    (112) function_declaration -> . FUNCTION ID LPAREN fun_param RPAREN COLON type_specifier SEMICOLON Begin_function
    (113) function_declaration -> . PROCEDURE ID LPAREN fun_param RPAREN SEMICOLON Begin_function
    (114) function_declaration -> . PROCEDURE ID SEMICOLON Begin_function
    (30) procedure_declaration -> . BEGIN instruction END DOT

    PROGRAM         shift and go to state 2
    USES            shift and go to state 3
    VAR             shift and go to state 9
    FUNCTION        shift and go to state 1
    PROCEDURE       shift and go to state 10
    BEGIN           shift and go to state 4

    header_declaration             shift and go to state 7
    function_declaration           shift and go to state 11
    procedure_declaration          shift and go to state 12
    declaration_list               shift and go to state 13
    var_declaration                shift and go to state 5
    program                        shift and go to state 6
    declaration                    shift and go to state 8

state 1

    (112) function_declaration -> FUNCTION . ID LPAREN fun_param RPAREN COLON type_specifier SEMICOLON Begin_function

    ID              shift and go to state 14


state 2

    (8) header_declaration -> PROGRAM . ID SEMICOLON

    ID              shift and go to state 15


state 3

    (9) header_declaration -> USES . ID header_declaration_3 SEMICOLON

    ID              shift and go to state 16


state 4

    (30) procedure_declaration -> BEGIN . instruction END DOT
    (31) instruction -> . asignation instruction
    (32) instruction -> . writing instruction
    (33) instruction -> . cycles instruction
    (34) instruction -> . callFunctions instruction
    (35) instruction -> . empty
    (55) asignation -> . ID EQUAL callFunctions SEMICOLON
    (56) asignation -> . ID EQUAL math SEMICOLON
    (57) asignation -> . ID EQUAL boolean SEMICOLON
    (58) asignation -> . ID EQUAL TEXT SEMICOLON
    (49) writing -> . WRITELN LPAREN id_text_l TEXT id_text_r RPAREN SEMICOLON
    (50) writing -> . WRITELN LPAREN id_num RPAREN SEMICOLON
    (51) writing -> . READLN LPAREN ID RPAREN SEMICOLON
    (52) writing -> . READLN LPAREN RPAREN SEMICOLON
    (53) writing -> . READLN SEMICOLON
    (54) writing -> . WRITELN SEMICOLON
    (60) cycles -> . type_cycle
    (36) callFunctions -> . ID LPAREN params RPAREN
    (18) empty -> .
    (61) type_cycle -> . while
    (62) type_cycle -> . if
    (63) type_cycle -> . for
    (64) type_cycle -> . cycles instruction
    (65) while -> . WHILE internexpression op_cycle DO otherBegin
    (66) if -> . IF internexpression op_cycle THEN otherBegin_if
    (67) if -> . IF internexpression op_cycle THEN instruction_one_line
    (68) if -> . IF internexpression op_cycle THEN otherBegin_if ELSE otherBegin
    (69) if -> . IF internexpression op_cycle THEN otherBegin_if ELSE instruction_one_line
    (70) if -> . IF internexpression op_cycle THEN instruction_one_line ELSE otherBegin
    (71) if -> . IF internexpression op_cycle THEN instruction_one_line ELSE instruction_one_line
    (72) for -> . FOR asignation_for TO id_num DO otherBegin
    (73) for -> . FOR asignation_for DOWNTO id_num DO otherBegin

    ID              shift and go to state 24
    WRITELN         shift and go to state 23
    READLN          shift and go to state 29
    END             reduce using rule 18 (empty -> .)
    WHILE           shift and go to state 17
    IF              shift and go to state 25
    FOR             shift and go to state 22

    instruction                    shift and go to state 27
    if                             shift and go to state 20
    for                            shift and go to state 26
    writing                        shift and go to state 18
    callFunctions                  shift and go to state 19
    asignation                     shift and go to state 28
    type_cycle                     shift and go to state 30
    while                          shift and go to state 31
    empty                          shift and go to state 21
    cycles                         shift and go to state 32

state 5

    (5) declaration -> var_declaration .

    PROGRAM         reduce using rule 5 (declaration -> var_declaration .)
    USES            reduce using rule 5 (declaration -> var_declaration .)
    VAR             reduce using rule 5 (declaration -> var_declaration .)
    FUNCTION        reduce using rule 5 (declaration -> var_declaration .)
    PROCEDURE       reduce using rule 5 (declaration -> var_declaration .)
    BEGIN           reduce using rule 5 (declaration -> var_declaration .)
    $end            reduce using rule 5 (declaration -> var_declaration .)


state 6

    (0) S' -> program .



state 7

    (4) declaration -> header_declaration .

    PROGRAM         reduce using rule 4 (declaration -> header_declaration .)
    USES            reduce using rule 4 (declaration -> header_declaration .)
    VAR             reduce using rule 4 (declaration -> header_declaration .)
    FUNCTION        reduce using rule 4 (declaration -> header_declaration .)
    PROCEDURE       reduce using rule 4 (declaration -> header_declaration .)
    BEGIN           reduce using rule 4 (declaration -> header_declaration .)
    $end            reduce using rule 4 (declaration -> header_declaration .)


state 8

    (3) declaration_list -> declaration .

    PROGRAM         reduce using rule 3 (declaration_list -> declaration .)
    USES            reduce using rule 3 (declaration_list -> declaration .)
    VAR             reduce using rule 3 (declaration_list -> declaration .)
    FUNCTION        reduce using rule 3 (declaration_list -> declaration .)
    PROCEDURE       reduce using rule 3 (declaration_list -> declaration .)
    BEGIN           reduce using rule 3 (declaration_list -> declaration .)
    $end            reduce using rule 3 (declaration_list -> declaration .)


state 9

    (12) var_declaration -> VAR . var_declaration_2
    (13) var_declaration_2 -> . ID var_declaration_3 COLON type_specifier SEMICOLON var_declaration_4

    ID              shift and go to state 34

    var_declaration_2              shift and go to state 33

state 10

    (113) function_declaration -> PROCEDURE . ID LPAREN fun_param RPAREN SEMICOLON Begin_function
    (114) function_declaration -> PROCEDURE . ID SEMICOLON Begin_function

    ID              shift and go to state 35


state 11

    (6) declaration -> function_declaration .

    PROGRAM         reduce using rule 6 (declaration -> function_declaration .)
    USES            reduce using rule 6 (declaration -> function_declaration .)
    VAR             reduce using rule 6 (declaration -> function_declaration .)
    FUNCTION        reduce using rule 6 (declaration -> function_declaration .)
    PROCEDURE       reduce using rule 6 (declaration -> function_declaration .)
    BEGIN           reduce using rule 6 (declaration -> function_declaration .)
    $end            reduce using rule 6 (declaration -> function_declaration .)


state 12

    (7) declaration -> procedure_declaration .

    PROGRAM         reduce using rule 7 (declaration -> procedure_declaration .)
    USES            reduce using rule 7 (declaration -> procedure_declaration .)
    VAR             reduce using rule 7 (declaration -> procedure_declaration .)
    FUNCTION        reduce using rule 7 (declaration -> procedure_declaration .)
    PROCEDURE       reduce using rule 7 (declaration -> procedure_declaration .)
    BEGIN           reduce using rule 7 (declaration -> procedure_declaration .)
    $end            reduce using rule 7 (declaration -> procedure_declaration .)


state 13

    (1) program -> declaration_list .
    (2) declaration_list -> declaration_list . declaration
    (4) declaration -> . header_declaration
    (5) declaration -> . var_declaration
    (6) declaration -> . function_declaration
    (7) declaration -> . procedure_declaration
    (8) header_declaration -> . PROGRAM ID SEMICOLON
    (9) header_declaration -> . USES ID header_declaration_3 SEMICOLON
    (12) var_declaration -> . VAR var_declaration_2
    (112) function_declaration -> . FUNCTION ID LPAREN fun_param RPAREN COLON type_specifier SEMICOLON Begin_function
    (113) function_declaration -> . PROCEDURE ID LPAREN fun_param RPAREN SEMICOLON Begin_function
    (114) function_declaration -> . PROCEDURE ID SEMICOLON Begin_function
    (30) procedure_declaration -> . BEGIN instruction END DOT

    $end            reduce using rule 1 (program -> declaration_list .)
    PROGRAM         shift and go to state 2
    USES            shift and go to state 3
    VAR             shift and go to state 9
    FUNCTION        shift and go to state 1
    PROCEDURE       shift and go to state 10
    BEGIN           shift and go to state 4

    header_declaration             shift and go to state 7
    function_declaration           shift and go to state 11
    procedure_declaration          shift and go to state 12
    var_declaration                shift and go to state 5
    declaration                    shift and go to state 36

state 14

    (112) function_declaration -> FUNCTION ID . LPAREN fun_param RPAREN COLON type_specifier SEMICOLON Begin_function

    LPAREN          shift and go to state 37


state 15

    (8) header_declaration -> PROGRAM ID . SEMICOLON

    SEMICOLON       shift and go to state 38


state 16

    (9) header_declaration -> USES ID . header_declaration_3 SEMICOLON
    (10) header_declaration_3 -> . COMMA ID header_declaration_3
    (11) header_declaration_3 -> . empty
    (18) empty -> .

    COMMA           shift and go to state 39
    SEMICOLON       reduce using rule 18 (empty -> .)

    header_declaration_3           shift and go to state 40
    empty                          shift and go to state 41

state 17

    (65) while -> WHILE . internexpression op_cycle DO otherBegin
    (76) internexpression -> . parentheses
    (77) internexpression -> . expression
    (78) parentheses -> . LPAREN expression RPAREN
    (79) expression -> . callFunctions
    (80) expression -> . callFunctions type_op math
    (81) expression -> . callFunctions type_op callFunctions
    (82) expression -> . math type_op math
    (83) expression -> . ID
    (84) expression -> . math ISEQUAL boolean
    (85) expression -> . boolean ISEQUAL math
    (86) expression -> . expression2
    (36) callFunctions -> . ID LPAREN params RPAREN
    (19) math -> . factor mathi
    (106) boolean -> . TRUE
    (107) boolean -> . FALSE
    (87) expression2 -> . TEXT type_op TEXT
    (88) expression2 -> . TEXT type_op ID
    (22) factor -> . LPAREN math RPAREN
    (23) factor -> . NUMBER
    (24) factor -> . ID

    LPAREN          shift and go to state 50
    ID              shift and go to state 52
    TRUE            shift and go to state 45
    FALSE           shift and go to state 54
    TEXT            shift and go to state 42
    NUMBER          shift and go to state 43

    parentheses                    shift and go to state 53
    internexpression               shift and go to state 46
    factor                         shift and go to state 48
    boolean                        shift and go to state 44
    callFunctions                  shift and go to state 47
    expression2                    shift and go to state 51
    expression                     shift and go to state 55
    math                           shift and go to state 49

state 18

    (32) instruction -> writing . instruction
    (31) instruction -> . asignation instruction
    (32) instruction -> . writing instruction
    (33) instruction -> . cycles instruction
    (34) instruction -> . callFunctions instruction
    (35) instruction -> . empty
    (55) asignation -> . ID EQUAL callFunctions SEMICOLON
    (56) asignation -> . ID EQUAL math SEMICOLON
    (57) asignation -> . ID EQUAL boolean SEMICOLON
    (58) asignation -> . ID EQUAL TEXT SEMICOLON
    (49) writing -> . WRITELN LPAREN id_text_l TEXT id_text_r RPAREN SEMICOLON
    (50) writing -> . WRITELN LPAREN id_num RPAREN SEMICOLON
    (51) writing -> . READLN LPAREN ID RPAREN SEMICOLON
    (52) writing -> . READLN LPAREN RPAREN SEMICOLON
    (53) writing -> . READLN SEMICOLON
    (54) writing -> . WRITELN SEMICOLON
    (60) cycles -> . type_cycle
    (36) callFunctions -> . ID LPAREN params RPAREN
    (18) empty -> .
    (61) type_cycle -> . while
    (62) type_cycle -> . if
    (63) type_cycle -> . for
    (64) type_cycle -> . cycles instruction
    (65) while -> . WHILE internexpression op_cycle DO otherBegin
    (66) if -> . IF internexpression op_cycle THEN otherBegin_if
    (67) if -> . IF internexpression op_cycle THEN instruction_one_line
    (68) if -> . IF internexpression op_cycle THEN otherBegin_if ELSE otherBegin
    (69) if -> . IF internexpression op_cycle THEN otherBegin_if ELSE instruction_one_line
    (70) if -> . IF internexpression op_cycle THEN instruction_one_line ELSE otherBegin
    (71) if -> . IF internexpression op_cycle THEN instruction_one_line ELSE instruction_one_line
    (72) for -> . FOR asignation_for TO id_num DO otherBegin
    (73) for -> . FOR asignation_for DOWNTO id_num DO otherBegin

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WRITELN resolved as shift
  ! shift/reduce conflict for READLN resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
    ID              shift and go to state 24
    WRITELN         shift and go to state 23
    READLN          shift and go to state 29
    END             reduce using rule 18 (empty -> .)
    ELSE            reduce using rule 18 (empty -> .)
    PROGRAM         reduce using rule 18 (empty -> .)
    USES            reduce using rule 18 (empty -> .)
    VAR             reduce using rule 18 (empty -> .)
    FUNCTION        reduce using rule 18 (empty -> .)
    PROCEDURE       reduce using rule 18 (empty -> .)
    BEGIN           reduce using rule 18 (empty -> .)
    $end            reduce using rule 18 (empty -> .)
    WHILE           shift and go to state 17
    IF              shift and go to state 25
    FOR             shift and go to state 22

  ! ID              [ reduce using rule 18 (empty -> .) ]
  ! WRITELN         [ reduce using rule 18 (empty -> .) ]
  ! READLN          [ reduce using rule 18 (empty -> .) ]
  ! WHILE           [ reduce using rule 18 (empty -> .) ]
  ! IF              [ reduce using rule 18 (empty -> .) ]
  ! FOR             [ reduce using rule 18 (empty -> .) ]

    instruction                    shift and go to state 56
    if                             shift and go to state 20
    for                            shift and go to state 26
    writing                        shift and go to state 18
    callFunctions                  shift and go to state 19
    asignation                     shift and go to state 28
    type_cycle                     shift and go to state 30
    while                          shift and go to state 31
    empty                          shift and go to state 21
    cycles                         shift and go to state 32

state 19

    (34) instruction -> callFunctions . instruction
    (31) instruction -> . asignation instruction
    (32) instruction -> . writing instruction
    (33) instruction -> . cycles instruction
    (34) instruction -> . callFunctions instruction
    (35) instruction -> . empty
    (55) asignation -> . ID EQUAL callFunctions SEMICOLON
    (56) asignation -> . ID EQUAL math SEMICOLON
    (57) asignation -> . ID EQUAL boolean SEMICOLON
    (58) asignation -> . ID EQUAL TEXT SEMICOLON
    (49) writing -> . WRITELN LPAREN id_text_l TEXT id_text_r RPAREN SEMICOLON
    (50) writing -> . WRITELN LPAREN id_num RPAREN SEMICOLON
    (51) writing -> . READLN LPAREN ID RPAREN SEMICOLON
    (52) writing -> . READLN LPAREN RPAREN SEMICOLON
    (53) writing -> . READLN SEMICOLON
    (54) writing -> . WRITELN SEMICOLON
    (60) cycles -> . type_cycle
    (36) callFunctions -> . ID LPAREN params RPAREN
    (18) empty -> .
    (61) type_cycle -> . while
    (62) type_cycle -> . if
    (63) type_cycle -> . for
    (64) type_cycle -> . cycles instruction
    (65) while -> . WHILE internexpression op_cycle DO otherBegin
    (66) if -> . IF internexpression op_cycle THEN otherBegin_if
    (67) if -> . IF internexpression op_cycle THEN instruction_one_line
    (68) if -> . IF internexpression op_cycle THEN otherBegin_if ELSE otherBegin
    (69) if -> . IF internexpression op_cycle THEN otherBegin_if ELSE instruction_one_line
    (70) if -> . IF internexpression op_cycle THEN instruction_one_line ELSE otherBegin
    (71) if -> . IF internexpression op_cycle THEN instruction_one_line ELSE instruction_one_line
    (72) for -> . FOR asignation_for TO id_num DO otherBegin
    (73) for -> . FOR asignation_for DOWNTO id_num DO otherBegin

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WRITELN resolved as shift
  ! shift/reduce conflict for READLN resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
    ID              shift and go to state 24
    WRITELN         shift and go to state 23
    READLN          shift and go to state 29
    END             reduce using rule 18 (empty -> .)
    ELSE            reduce using rule 18 (empty -> .)
    PROGRAM         reduce using rule 18 (empty -> .)
    USES            reduce using rule 18 (empty -> .)
    VAR             reduce using rule 18 (empty -> .)
    FUNCTION        reduce using rule 18 (empty -> .)
    PROCEDURE       reduce using rule 18 (empty -> .)
    BEGIN           reduce using rule 18 (empty -> .)
    $end            reduce using rule 18 (empty -> .)
    WHILE           shift and go to state 17
    IF              shift and go to state 25
    FOR             shift and go to state 22

  ! ID              [ reduce using rule 18 (empty -> .) ]
  ! WRITELN         [ reduce using rule 18 (empty -> .) ]
  ! READLN          [ reduce using rule 18 (empty -> .) ]
  ! WHILE           [ reduce using rule 18 (empty -> .) ]
  ! IF              [ reduce using rule 18 (empty -> .) ]
  ! FOR             [ reduce using rule 18 (empty -> .) ]

    instruction                    shift and go to state 57
    if                             shift and go to state 20
    for                            shift and go to state 26
    writing                        shift and go to state 18
    callFunctions                  shift and go to state 19
    asignation                     shift and go to state 28
    type_cycle                     shift and go to state 30
    while                          shift and go to state 31
    empty                          shift and go to state 21
    cycles                         shift and go to state 32

state 20

    (62) type_cycle -> if .

    END             reduce using rule 62 (type_cycle -> if .)
    ID              reduce using rule 62 (type_cycle -> if .)
    WRITELN         reduce using rule 62 (type_cycle -> if .)
    READLN          reduce using rule 62 (type_cycle -> if .)
    WHILE           reduce using rule 62 (type_cycle -> if .)
    IF              reduce using rule 62 (type_cycle -> if .)
    FOR             reduce using rule 62 (type_cycle -> if .)
    ELSE            reduce using rule 62 (type_cycle -> if .)
    PROGRAM         reduce using rule 62 (type_cycle -> if .)
    USES            reduce using rule 62 (type_cycle -> if .)
    VAR             reduce using rule 62 (type_cycle -> if .)
    FUNCTION        reduce using rule 62 (type_cycle -> if .)
    PROCEDURE       reduce using rule 62 (type_cycle -> if .)
    BEGIN           reduce using rule 62 (type_cycle -> if .)
    $end            reduce using rule 62 (type_cycle -> if .)


state 21

    (35) instruction -> empty .

    END             reduce using rule 35 (instruction -> empty .)
    PROGRAM         reduce using rule 35 (instruction -> empty .)
    USES            reduce using rule 35 (instruction -> empty .)
    VAR             reduce using rule 35 (instruction -> empty .)
    FUNCTION        reduce using rule 35 (instruction -> empty .)
    PROCEDURE       reduce using rule 35 (instruction -> empty .)
    BEGIN           reduce using rule 35 (instruction -> empty .)
    $end            reduce using rule 35 (instruction -> empty .)
    ID              reduce using rule 35 (instruction -> empty .)
    WRITELN         reduce using rule 35 (instruction -> empty .)
    READLN          reduce using rule 35 (instruction -> empty .)
    WHILE           reduce using rule 35 (instruction -> empty .)
    IF              reduce using rule 35 (instruction -> empty .)
    FOR             reduce using rule 35 (instruction -> empty .)
    ELSE            reduce using rule 35 (instruction -> empty .)


state 22

    (72) for -> FOR . asignation_for TO id_num DO otherBegin
    (73) for -> FOR . asignation_for DOWNTO id_num DO otherBegin
    (59) asignation_for -> . ID EQUAL id_num

    ID              shift and go to state 59

    asignation_for                 shift and go to state 58

state 23

    (49) writing -> WRITELN . LPAREN id_text_l TEXT id_text_r RPAREN SEMICOLON
    (50) writing -> WRITELN . LPAREN id_num RPAREN SEMICOLON
    (54) writing -> WRITELN . SEMICOLON

    LPAREN          shift and go to state 61
    SEMICOLON       shift and go to state 60


state 24

    (55) asignation -> ID . EQUAL callFunctions SEMICOLON
    (56) asignation -> ID . EQUAL math SEMICOLON
    (57) asignation -> ID . EQUAL boolean SEMICOLON
    (58) asignation -> ID . EQUAL TEXT SEMICOLON
    (36) callFunctions -> ID . LPAREN params RPAREN

    EQUAL           shift and go to state 63
    LPAREN          shift and go to state 62


state 25

    (66) if -> IF . internexpression op_cycle THEN otherBegin_if
    (67) if -> IF . internexpression op_cycle THEN instruction_one_line
    (68) if -> IF . internexpression op_cycle THEN otherBegin_if ELSE otherBegin
    (69) if -> IF . internexpression op_cycle THEN otherBegin_if ELSE instruction_one_line
    (70) if -> IF . internexpression op_cycle THEN instruction_one_line ELSE otherBegin
    (71) if -> IF . internexpression op_cycle THEN instruction_one_line ELSE instruction_one_line
    (76) internexpression -> . parentheses
    (77) internexpression -> . expression
    (78) parentheses -> . LPAREN expression RPAREN
    (79) expression -> . callFunctions
    (80) expression -> . callFunctions type_op math
    (81) expression -> . callFunctions type_op callFunctions
    (82) expression -> . math type_op math
    (83) expression -> . ID
    (84) expression -> . math ISEQUAL boolean
    (85) expression -> . boolean ISEQUAL math
    (86) expression -> . expression2
    (36) callFunctions -> . ID LPAREN params RPAREN
    (19) math -> . factor mathi
    (106) boolean -> . TRUE
    (107) boolean -> . FALSE
    (87) expression2 -> . TEXT type_op TEXT
    (88) expression2 -> . TEXT type_op ID
    (22) factor -> . LPAREN math RPAREN
    (23) factor -> . NUMBER
    (24) factor -> . ID

    LPAREN          shift and go to state 50
    ID              shift and go to state 52
    TRUE            shift and go to state 45
    FALSE           shift and go to state 54
    TEXT            shift and go to state 42
    NUMBER          shift and go to state 43

    parentheses                    shift and go to state 53
    internexpression               shift and go to state 64
    factor                         shift and go to state 48
    boolean                        shift and go to state 44
    callFunctions                  shift and go to state 47
    expression2                    shift and go to state 51
    expression                     shift and go to state 55
    math                           shift and go to state 49

state 26

    (63) type_cycle -> for .

    END             reduce using rule 63 (type_cycle -> for .)
    ID              reduce using rule 63 (type_cycle -> for .)
    WRITELN         reduce using rule 63 (type_cycle -> for .)
    READLN          reduce using rule 63 (type_cycle -> for .)
    WHILE           reduce using rule 63 (type_cycle -> for .)
    IF              reduce using rule 63 (type_cycle -> for .)
    FOR             reduce using rule 63 (type_cycle -> for .)
    ELSE            reduce using rule 63 (type_cycle -> for .)
    PROGRAM         reduce using rule 63 (type_cycle -> for .)
    USES            reduce using rule 63 (type_cycle -> for .)
    VAR             reduce using rule 63 (type_cycle -> for .)
    FUNCTION        reduce using rule 63 (type_cycle -> for .)
    PROCEDURE       reduce using rule 63 (type_cycle -> for .)
    BEGIN           reduce using rule 63 (type_cycle -> for .)
    $end            reduce using rule 63 (type_cycle -> for .)


state 27

    (30) procedure_declaration -> BEGIN instruction . END DOT

    END             shift and go to state 65


state 28

    (31) instruction -> asignation . instruction
    (31) instruction -> . asignation instruction
    (32) instruction -> . writing instruction
    (33) instruction -> . cycles instruction
    (34) instruction -> . callFunctions instruction
    (35) instruction -> . empty
    (55) asignation -> . ID EQUAL callFunctions SEMICOLON
    (56) asignation -> . ID EQUAL math SEMICOLON
    (57) asignation -> . ID EQUAL boolean SEMICOLON
    (58) asignation -> . ID EQUAL TEXT SEMICOLON
    (49) writing -> . WRITELN LPAREN id_text_l TEXT id_text_r RPAREN SEMICOLON
    (50) writing -> . WRITELN LPAREN id_num RPAREN SEMICOLON
    (51) writing -> . READLN LPAREN ID RPAREN SEMICOLON
    (52) writing -> . READLN LPAREN RPAREN SEMICOLON
    (53) writing -> . READLN SEMICOLON
    (54) writing -> . WRITELN SEMICOLON
    (60) cycles -> . type_cycle
    (36) callFunctions -> . ID LPAREN params RPAREN
    (18) empty -> .
    (61) type_cycle -> . while
    (62) type_cycle -> . if
    (63) type_cycle -> . for
    (64) type_cycle -> . cycles instruction
    (65) while -> . WHILE internexpression op_cycle DO otherBegin
    (66) if -> . IF internexpression op_cycle THEN otherBegin_if
    (67) if -> . IF internexpression op_cycle THEN instruction_one_line
    (68) if -> . IF internexpression op_cycle THEN otherBegin_if ELSE otherBegin
    (69) if -> . IF internexpression op_cycle THEN otherBegin_if ELSE instruction_one_line
    (70) if -> . IF internexpression op_cycle THEN instruction_one_line ELSE otherBegin
    (71) if -> . IF internexpression op_cycle THEN instruction_one_line ELSE instruction_one_line
    (72) for -> . FOR asignation_for TO id_num DO otherBegin
    (73) for -> . FOR asignation_for DOWNTO id_num DO otherBegin

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WRITELN resolved as shift
  ! shift/reduce conflict for READLN resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
    ID              shift and go to state 24
    WRITELN         shift and go to state 23
    READLN          shift and go to state 29
    END             reduce using rule 18 (empty -> .)
    ELSE            reduce using rule 18 (empty -> .)
    PROGRAM         reduce using rule 18 (empty -> .)
    USES            reduce using rule 18 (empty -> .)
    VAR             reduce using rule 18 (empty -> .)
    FUNCTION        reduce using rule 18 (empty -> .)
    PROCEDURE       reduce using rule 18 (empty -> .)
    BEGIN           reduce using rule 18 (empty -> .)
    $end            reduce using rule 18 (empty -> .)
    WHILE           shift and go to state 17
    IF              shift and go to state 25
    FOR             shift and go to state 22

  ! ID              [ reduce using rule 18 (empty -> .) ]
  ! WRITELN         [ reduce using rule 18 (empty -> .) ]
  ! READLN          [ reduce using rule 18 (empty -> .) ]
  ! WHILE           [ reduce using rule 18 (empty -> .) ]
  ! IF              [ reduce using rule 18 (empty -> .) ]
  ! FOR             [ reduce using rule 18 (empty -> .) ]

    instruction                    shift and go to state 66
    if                             shift and go to state 20
    for                            shift and go to state 26
    writing                        shift and go to state 18
    callFunctions                  shift and go to state 19
    asignation                     shift and go to state 28
    type_cycle                     shift and go to state 30
    while                          shift and go to state 31
    empty                          shift and go to state 21
    cycles                         shift and go to state 32

state 29

    (51) writing -> READLN . LPAREN ID RPAREN SEMICOLON
    (52) writing -> READLN . LPAREN RPAREN SEMICOLON
    (53) writing -> READLN . SEMICOLON

    LPAREN          shift and go to state 68
    SEMICOLON       shift and go to state 67


state 30

    (60) cycles -> type_cycle .

    END             reduce using rule 60 (cycles -> type_cycle .)
    ID              reduce using rule 60 (cycles -> type_cycle .)
    WRITELN         reduce using rule 60 (cycles -> type_cycle .)
    READLN          reduce using rule 60 (cycles -> type_cycle .)
    WHILE           reduce using rule 60 (cycles -> type_cycle .)
    IF              reduce using rule 60 (cycles -> type_cycle .)
    FOR             reduce using rule 60 (cycles -> type_cycle .)
    ELSE            reduce using rule 60 (cycles -> type_cycle .)
    PROGRAM         reduce using rule 60 (cycles -> type_cycle .)
    USES            reduce using rule 60 (cycles -> type_cycle .)
    VAR             reduce using rule 60 (cycles -> type_cycle .)
    FUNCTION        reduce using rule 60 (cycles -> type_cycle .)
    PROCEDURE       reduce using rule 60 (cycles -> type_cycle .)
    BEGIN           reduce using rule 60 (cycles -> type_cycle .)
    $end            reduce using rule 60 (cycles -> type_cycle .)


state 31

    (61) type_cycle -> while .

    END             reduce using rule 61 (type_cycle -> while .)
    ID              reduce using rule 61 (type_cycle -> while .)
    WRITELN         reduce using rule 61 (type_cycle -> while .)
    READLN          reduce using rule 61 (type_cycle -> while .)
    WHILE           reduce using rule 61 (type_cycle -> while .)
    IF              reduce using rule 61 (type_cycle -> while .)
    FOR             reduce using rule 61 (type_cycle -> while .)
    ELSE            reduce using rule 61 (type_cycle -> while .)
    PROGRAM         reduce using rule 61 (type_cycle -> while .)
    USES            reduce using rule 61 (type_cycle -> while .)
    VAR             reduce using rule 61 (type_cycle -> while .)
    FUNCTION        reduce using rule 61 (type_cycle -> while .)
    PROCEDURE       reduce using rule 61 (type_cycle -> while .)
    BEGIN           reduce using rule 61 (type_cycle -> while .)
    $end            reduce using rule 61 (type_cycle -> while .)


state 32

    (33) instruction -> cycles . instruction
    (64) type_cycle -> cycles . instruction
    (31) instruction -> . asignation instruction
    (32) instruction -> . writing instruction
    (33) instruction -> . cycles instruction
    (34) instruction -> . callFunctions instruction
    (35) instruction -> . empty
    (55) asignation -> . ID EQUAL callFunctions SEMICOLON
    (56) asignation -> . ID EQUAL math SEMICOLON
    (57) asignation -> . ID EQUAL boolean SEMICOLON
    (58) asignation -> . ID EQUAL TEXT SEMICOLON
    (49) writing -> . WRITELN LPAREN id_text_l TEXT id_text_r RPAREN SEMICOLON
    (50) writing -> . WRITELN LPAREN id_num RPAREN SEMICOLON
    (51) writing -> . READLN LPAREN ID RPAREN SEMICOLON
    (52) writing -> . READLN LPAREN RPAREN SEMICOLON
    (53) writing -> . READLN SEMICOLON
    (54) writing -> . WRITELN SEMICOLON
    (60) cycles -> . type_cycle
    (36) callFunctions -> . ID LPAREN params RPAREN
    (18) empty -> .
    (61) type_cycle -> . while
    (62) type_cycle -> . if
    (63) type_cycle -> . for
    (64) type_cycle -> . cycles instruction
    (65) while -> . WHILE internexpression op_cycle DO otherBegin
    (66) if -> . IF internexpression op_cycle THEN otherBegin_if
    (67) if -> . IF internexpression op_cycle THEN instruction_one_line
    (68) if -> . IF internexpression op_cycle THEN otherBegin_if ELSE otherBegin
    (69) if -> . IF internexpression op_cycle THEN otherBegin_if ELSE instruction_one_line
    (70) if -> . IF internexpression op_cycle THEN instruction_one_line ELSE otherBegin
    (71) if -> . IF internexpression op_cycle THEN instruction_one_line ELSE instruction_one_line
    (72) for -> . FOR asignation_for TO id_num DO otherBegin
    (73) for -> . FOR asignation_for DOWNTO id_num DO otherBegin

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WRITELN resolved as shift
  ! shift/reduce conflict for READLN resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
    ID              shift and go to state 24
    WRITELN         shift and go to state 23
    READLN          shift and go to state 29
    END             reduce using rule 18 (empty -> .)
    ELSE            reduce using rule 18 (empty -> .)
    PROGRAM         reduce using rule 18 (empty -> .)
    USES            reduce using rule 18 (empty -> .)
    VAR             reduce using rule 18 (empty -> .)
    FUNCTION        reduce using rule 18 (empty -> .)
    PROCEDURE       reduce using rule 18 (empty -> .)
    BEGIN           reduce using rule 18 (empty -> .)
    $end            reduce using rule 18 (empty -> .)
    WHILE           shift and go to state 17
    IF              shift and go to state 25
    FOR             shift and go to state 22

  ! ID              [ reduce using rule 18 (empty -> .) ]
  ! WRITELN         [ reduce using rule 18 (empty -> .) ]
  ! READLN          [ reduce using rule 18 (empty -> .) ]
  ! WHILE           [ reduce using rule 18 (empty -> .) ]
  ! IF              [ reduce using rule 18 (empty -> .) ]
  ! FOR             [ reduce using rule 18 (empty -> .) ]

    instruction                    shift and go to state 69
    if                             shift and go to state 20
    for                            shift and go to state 26
    writing                        shift and go to state 18
    callFunctions                  shift and go to state 19
    asignation                     shift and go to state 28
    type_cycle                     shift and go to state 30
    while                          shift and go to state 31
    empty                          shift and go to state 21
    cycles                         shift and go to state 32

state 33

    (12) var_declaration -> VAR var_declaration_2 .

    PROGRAM         reduce using rule 12 (var_declaration -> VAR var_declaration_2 .)
    USES            reduce using rule 12 (var_declaration -> VAR var_declaration_2 .)
    VAR             reduce using rule 12 (var_declaration -> VAR var_declaration_2 .)
    FUNCTION        reduce using rule 12 (var_declaration -> VAR var_declaration_2 .)
    PROCEDURE       reduce using rule 12 (var_declaration -> VAR var_declaration_2 .)
    BEGIN           reduce using rule 12 (var_declaration -> VAR var_declaration_2 .)
    $end            reduce using rule 12 (var_declaration -> VAR var_declaration_2 .)


state 34

    (13) var_declaration_2 -> ID . var_declaration_3 COLON type_specifier SEMICOLON var_declaration_4
    (14) var_declaration_3 -> . COMMA ID var_declaration_3
    (15) var_declaration_3 -> . empty
    (18) empty -> .

    COMMA           shift and go to state 71
    COLON           reduce using rule 18 (empty -> .)

    var_declaration_3              shift and go to state 70
    empty                          shift and go to state 72

state 35

    (113) function_declaration -> PROCEDURE ID . LPAREN fun_param RPAREN SEMICOLON Begin_function
    (114) function_declaration -> PROCEDURE ID . SEMICOLON Begin_function

    LPAREN          shift and go to state 74
    SEMICOLON       shift and go to state 73


state 36

    (2) declaration_list -> declaration_list declaration .

    PROGRAM         reduce using rule 2 (declaration_list -> declaration_list declaration .)
    USES            reduce using rule 2 (declaration_list -> declaration_list declaration .)
    VAR             reduce using rule 2 (declaration_list -> declaration_list declaration .)
    FUNCTION        reduce using rule 2 (declaration_list -> declaration_list declaration .)
    PROCEDURE       reduce using rule 2 (declaration_list -> declaration_list declaration .)
    BEGIN           reduce using rule 2 (declaration_list -> declaration_list declaration .)
    $end            reduce using rule 2 (declaration_list -> declaration_list declaration .)


state 37

    (112) function_declaration -> FUNCTION ID LPAREN . fun_param RPAREN COLON type_specifier SEMICOLON Begin_function
    (115) fun_param -> . ID fun_param_2 COLON type_specifier fun_param
    (116) fun_param -> . SEMICOLON ID fun_param_2 COLON type_specifier fun_param
    (117) fun_param -> . empty
    (18) empty -> .

    ID              shift and go to state 77
    SEMICOLON       shift and go to state 75
    RPAREN          reduce using rule 18 (empty -> .)

    fun_param                      shift and go to state 76
    empty                          shift and go to state 78

state 38

    (8) header_declaration -> PROGRAM ID SEMICOLON .

    PROGRAM         reduce using rule 8 (header_declaration -> PROGRAM ID SEMICOLON .)
    USES            reduce using rule 8 (header_declaration -> PROGRAM ID SEMICOLON .)
    VAR             reduce using rule 8 (header_declaration -> PROGRAM ID SEMICOLON .)
    FUNCTION        reduce using rule 8 (header_declaration -> PROGRAM ID SEMICOLON .)
    PROCEDURE       reduce using rule 8 (header_declaration -> PROGRAM ID SEMICOLON .)
    BEGIN           reduce using rule 8 (header_declaration -> PROGRAM ID SEMICOLON .)
    $end            reduce using rule 8 (header_declaration -> PROGRAM ID SEMICOLON .)


state 39

    (10) header_declaration_3 -> COMMA . ID header_declaration_3

    ID              shift and go to state 79


state 40

    (9) header_declaration -> USES ID header_declaration_3 . SEMICOLON

    SEMICOLON       shift and go to state 80


state 41

    (11) header_declaration_3 -> empty .

    SEMICOLON       reduce using rule 11 (header_declaration_3 -> empty .)


state 42

    (87) expression2 -> TEXT . type_op TEXT
    (88) expression2 -> TEXT . type_op ID
    (89) type_op -> . LESSEQUAL
    (90) type_op -> . LESS
    (91) type_op -> . GREATER
    (92) type_op -> . GREATEREQUAL
    (93) type_op -> . DEQUAL
    (94) type_op -> . ISEQUAL

    LESSEQUAL       shift and go to state 87
    LESS            shift and go to state 83
    GREATER         shift and go to state 82
    GREATEREQUAL    shift and go to state 81
    DEQUAL          shift and go to state 84
    ISEQUAL         shift and go to state 85

    type_op                        shift and go to state 86

state 43

    (23) factor -> NUMBER .

    PLUS            reduce using rule 23 (factor -> NUMBER .)
    MINUS           reduce using rule 23 (factor -> NUMBER .)
    TIMES           reduce using rule 23 (factor -> NUMBER .)
    DIVIDE          reduce using rule 23 (factor -> NUMBER .)
    MOD             reduce using rule 23 (factor -> NUMBER .)
    AND             reduce using rule 23 (factor -> NUMBER .)
    OR              reduce using rule 23 (factor -> NUMBER .)
    XOR             reduce using rule 23 (factor -> NUMBER .)
    NOT             reduce using rule 23 (factor -> NUMBER .)
    DO              reduce using rule 23 (factor -> NUMBER .)
    THEN            reduce using rule 23 (factor -> NUMBER .)
    RPAREN          reduce using rule 23 (factor -> NUMBER .)
    ISEQUAL         reduce using rule 23 (factor -> NUMBER .)
    LESSEQUAL       reduce using rule 23 (factor -> NUMBER .)
    LESS            reduce using rule 23 (factor -> NUMBER .)
    GREATER         reduce using rule 23 (factor -> NUMBER .)
    GREATEREQUAL    reduce using rule 23 (factor -> NUMBER .)
    DEQUAL          reduce using rule 23 (factor -> NUMBER .)
    COMMA           reduce using rule 23 (factor -> NUMBER .)
    SEMICOLON       reduce using rule 23 (factor -> NUMBER .)


state 44

    (85) expression -> boolean . ISEQUAL math

    ISEQUAL         shift and go to state 88


state 45

    (106) boolean -> TRUE .

    SEMICOLON       reduce using rule 106 (boolean -> TRUE .)
    ISEQUAL         reduce using rule 106 (boolean -> TRUE .)
    AND             reduce using rule 106 (boolean -> TRUE .)
    OR              reduce using rule 106 (boolean -> TRUE .)
    XOR             reduce using rule 106 (boolean -> TRUE .)
    NOT             reduce using rule 106 (boolean -> TRUE .)
    DO              reduce using rule 106 (boolean -> TRUE .)
    THEN            reduce using rule 106 (boolean -> TRUE .)
    RPAREN          reduce using rule 106 (boolean -> TRUE .)


state 46

    (65) while -> WHILE internexpression . op_cycle DO otherBegin
    (74) op_cycle -> . op_logic internexpression op_cycle
    (75) op_cycle -> . empty
    (100) op_logic -> . AND
    (101) op_logic -> . OR
    (102) op_logic -> . XOR
    (103) op_logic -> . NOT
    (18) empty -> .

    AND             shift and go to state 89
    OR              shift and go to state 94
    XOR             shift and go to state 90
    NOT             shift and go to state 92
    DO              reduce using rule 18 (empty -> .)

    empty                          shift and go to state 95
    op_cycle                       shift and go to state 93
    op_logic                       shift and go to state 91

state 47

    (79) expression -> callFunctions .
    (80) expression -> callFunctions . type_op math
    (81) expression -> callFunctions . type_op callFunctions
    (89) type_op -> . LESSEQUAL
    (90) type_op -> . LESS
    (91) type_op -> . GREATER
    (92) type_op -> . GREATEREQUAL
    (93) type_op -> . DEQUAL
    (94) type_op -> . ISEQUAL

    AND             reduce using rule 79 (expression -> callFunctions .)
    OR              reduce using rule 79 (expression -> callFunctions .)
    XOR             reduce using rule 79 (expression -> callFunctions .)
    NOT             reduce using rule 79 (expression -> callFunctions .)
    DO              reduce using rule 79 (expression -> callFunctions .)
    THEN            reduce using rule 79 (expression -> callFunctions .)
    RPAREN          reduce using rule 79 (expression -> callFunctions .)
    LESSEQUAL       shift and go to state 87
    LESS            shift and go to state 83
    GREATER         shift and go to state 82
    GREATEREQUAL    shift and go to state 81
    DEQUAL          shift and go to state 84
    ISEQUAL         shift and go to state 85

    type_op                        shift and go to state 96

state 48

    (19) math -> factor . mathi
    (20) mathi -> . type_op_math factor mathi
    (21) mathi -> . empty
    (95) type_op_math -> . PLUS
    (96) type_op_math -> . MINUS
    (97) type_op_math -> . TIMES
    (98) type_op_math -> . DIVIDE
    (99) type_op_math -> . MOD
    (18) empty -> .

    PLUS            shift and go to state 100
    MINUS           shift and go to state 102
    TIMES           shift and go to state 99
    DIVIDE          shift and go to state 98
    MOD             shift and go to state 104
    ISEQUAL         reduce using rule 18 (empty -> .)
    LESSEQUAL       reduce using rule 18 (empty -> .)
    LESS            reduce using rule 18 (empty -> .)
    GREATER         reduce using rule 18 (empty -> .)
    GREATEREQUAL    reduce using rule 18 (empty -> .)
    DEQUAL          reduce using rule 18 (empty -> .)
    RPAREN          reduce using rule 18 (empty -> .)
    COMMA           reduce using rule 18 (empty -> .)
    SEMICOLON       reduce using rule 18 (empty -> .)
    AND             reduce using rule 18 (empty -> .)
    OR              reduce using rule 18 (empty -> .)
    XOR             reduce using rule 18 (empty -> .)
    NOT             reduce using rule 18 (empty -> .)
    DO              reduce using rule 18 (empty -> .)
    THEN            reduce using rule 18 (empty -> .)

    mathi                          shift and go to state 97
    type_op_math                   shift and go to state 101
    empty                          shift and go to state 103

state 49

    (82) expression -> math . type_op math
    (84) expression -> math . ISEQUAL boolean
    (89) type_op -> . LESSEQUAL
    (90) type_op -> . LESS
    (91) type_op -> . GREATER
    (92) type_op -> . GREATEREQUAL
    (93) type_op -> . DEQUAL
    (94) type_op -> . ISEQUAL

    ISEQUAL         shift and go to state 106
    LESSEQUAL       shift and go to state 87
    LESS            shift and go to state 83
    GREATER         shift and go to state 82
    GREATEREQUAL    shift and go to state 81
    DEQUAL          shift and go to state 84

    type_op                        shift and go to state 105

state 50

    (78) parentheses -> LPAREN . expression RPAREN
    (22) factor -> LPAREN . math RPAREN
    (79) expression -> . callFunctions
    (80) expression -> . callFunctions type_op math
    (81) expression -> . callFunctions type_op callFunctions
    (82) expression -> . math type_op math
    (83) expression -> . ID
    (84) expression -> . math ISEQUAL boolean
    (85) expression -> . boolean ISEQUAL math
    (86) expression -> . expression2
    (19) math -> . factor mathi
    (36) callFunctions -> . ID LPAREN params RPAREN
    (106) boolean -> . TRUE
    (107) boolean -> . FALSE
    (87) expression2 -> . TEXT type_op TEXT
    (88) expression2 -> . TEXT type_op ID
    (22) factor -> . LPAREN math RPAREN
    (23) factor -> . NUMBER
    (24) factor -> . ID

    ID              shift and go to state 52
    TRUE            shift and go to state 45
    FALSE           shift and go to state 54
    TEXT            shift and go to state 42
    LPAREN          shift and go to state 107
    NUMBER          shift and go to state 43

    boolean                        shift and go to state 44
    callFunctions                  shift and go to state 47
    factor                         shift and go to state 48
    expression2                    shift and go to state 51
    expression                     shift and go to state 108
    math                           shift and go to state 109

state 51

    (86) expression -> expression2 .

    AND             reduce using rule 86 (expression -> expression2 .)
    OR              reduce using rule 86 (expression -> expression2 .)
    XOR             reduce using rule 86 (expression -> expression2 .)
    NOT             reduce using rule 86 (expression -> expression2 .)
    DO              reduce using rule 86 (expression -> expression2 .)
    THEN            reduce using rule 86 (expression -> expression2 .)
    RPAREN          reduce using rule 86 (expression -> expression2 .)


state 52

    (83) expression -> ID .
    (36) callFunctions -> ID . LPAREN params RPAREN
    (24) factor -> ID .

  ! reduce/reduce conflict for RPAREN resolved using rule 24 (factor -> ID .)
    AND             reduce using rule 83 (expression -> ID .)
    OR              reduce using rule 83 (expression -> ID .)
    XOR             reduce using rule 83 (expression -> ID .)
    NOT             reduce using rule 83 (expression -> ID .)
    DO              reduce using rule 83 (expression -> ID .)
    THEN            reduce using rule 83 (expression -> ID .)
    LPAREN          shift and go to state 62
    PLUS            reduce using rule 24 (factor -> ID .)
    MINUS           reduce using rule 24 (factor -> ID .)
    TIMES           reduce using rule 24 (factor -> ID .)
    DIVIDE          reduce using rule 24 (factor -> ID .)
    MOD             reduce using rule 24 (factor -> ID .)
    RPAREN          reduce using rule 24 (factor -> ID .)
    ISEQUAL         reduce using rule 24 (factor -> ID .)
    LESSEQUAL       reduce using rule 24 (factor -> ID .)
    LESS            reduce using rule 24 (factor -> ID .)
    GREATER         reduce using rule 24 (factor -> ID .)
    GREATEREQUAL    reduce using rule 24 (factor -> ID .)
    DEQUAL          reduce using rule 24 (factor -> ID .)

  ! RPAREN          [ reduce using rule 83 (expression -> ID .) ]


state 53

    (76) internexpression -> parentheses .

    AND             reduce using rule 76 (internexpression -> parentheses .)
    OR              reduce using rule 76 (internexpression -> parentheses .)
    XOR             reduce using rule 76 (internexpression -> parentheses .)
    NOT             reduce using rule 76 (internexpression -> parentheses .)
    DO              reduce using rule 76 (internexpression -> parentheses .)
    THEN            reduce using rule 76 (internexpression -> parentheses .)


state 54

    (107) boolean -> FALSE .

    SEMICOLON       reduce using rule 107 (boolean -> FALSE .)
    ISEQUAL         reduce using rule 107 (boolean -> FALSE .)
    AND             reduce using rule 107 (boolean -> FALSE .)
    OR              reduce using rule 107 (boolean -> FALSE .)
    XOR             reduce using rule 107 (boolean -> FALSE .)
    NOT             reduce using rule 107 (boolean -> FALSE .)
    DO              reduce using rule 107 (boolean -> FALSE .)
    THEN            reduce using rule 107 (boolean -> FALSE .)
    RPAREN          reduce using rule 107 (boolean -> FALSE .)


state 55

    (77) internexpression -> expression .

    AND             reduce using rule 77 (internexpression -> expression .)
    OR              reduce using rule 77 (internexpression -> expression .)
    XOR             reduce using rule 77 (internexpression -> expression .)
    NOT             reduce using rule 77 (internexpression -> expression .)
    DO              reduce using rule 77 (internexpression -> expression .)
    THEN            reduce using rule 77 (internexpression -> expression .)


state 56

    (32) instruction -> writing instruction .

    END             reduce using rule 32 (instruction -> writing instruction .)
    PROGRAM         reduce using rule 32 (instruction -> writing instruction .)
    USES            reduce using rule 32 (instruction -> writing instruction .)
    VAR             reduce using rule 32 (instruction -> writing instruction .)
    FUNCTION        reduce using rule 32 (instruction -> writing instruction .)
    PROCEDURE       reduce using rule 32 (instruction -> writing instruction .)
    BEGIN           reduce using rule 32 (instruction -> writing instruction .)
    $end            reduce using rule 32 (instruction -> writing instruction .)
    ID              reduce using rule 32 (instruction -> writing instruction .)
    WRITELN         reduce using rule 32 (instruction -> writing instruction .)
    READLN          reduce using rule 32 (instruction -> writing instruction .)
    WHILE           reduce using rule 32 (instruction -> writing instruction .)
    IF              reduce using rule 32 (instruction -> writing instruction .)
    FOR             reduce using rule 32 (instruction -> writing instruction .)
    ELSE            reduce using rule 32 (instruction -> writing instruction .)


state 57

    (34) instruction -> callFunctions instruction .

    END             reduce using rule 34 (instruction -> callFunctions instruction .)
    PROGRAM         reduce using rule 34 (instruction -> callFunctions instruction .)
    USES            reduce using rule 34 (instruction -> callFunctions instruction .)
    VAR             reduce using rule 34 (instruction -> callFunctions instruction .)
    FUNCTION        reduce using rule 34 (instruction -> callFunctions instruction .)
    PROCEDURE       reduce using rule 34 (instruction -> callFunctions instruction .)
    BEGIN           reduce using rule 34 (instruction -> callFunctions instruction .)
    $end            reduce using rule 34 (instruction -> callFunctions instruction .)
    ID              reduce using rule 34 (instruction -> callFunctions instruction .)
    WRITELN         reduce using rule 34 (instruction -> callFunctions instruction .)
    READLN          reduce using rule 34 (instruction -> callFunctions instruction .)
    WHILE           reduce using rule 34 (instruction -> callFunctions instruction .)
    IF              reduce using rule 34 (instruction -> callFunctions instruction .)
    FOR             reduce using rule 34 (instruction -> callFunctions instruction .)
    ELSE            reduce using rule 34 (instruction -> callFunctions instruction .)


state 58

    (72) for -> FOR asignation_for . TO id_num DO otherBegin
    (73) for -> FOR asignation_for . DOWNTO id_num DO otherBegin

    TO              shift and go to state 111
    DOWNTO          shift and go to state 110


state 59

    (59) asignation_for -> ID . EQUAL id_num

    EQUAL           shift and go to state 112


state 60

    (54) writing -> WRITELN SEMICOLON .

    ID              reduce using rule 54 (writing -> WRITELN SEMICOLON .)
    WRITELN         reduce using rule 54 (writing -> WRITELN SEMICOLON .)
    READLN          reduce using rule 54 (writing -> WRITELN SEMICOLON .)
    WHILE           reduce using rule 54 (writing -> WRITELN SEMICOLON .)
    IF              reduce using rule 54 (writing -> WRITELN SEMICOLON .)
    FOR             reduce using rule 54 (writing -> WRITELN SEMICOLON .)
    END             reduce using rule 54 (writing -> WRITELN SEMICOLON .)
    ELSE            reduce using rule 54 (writing -> WRITELN SEMICOLON .)
    PROGRAM         reduce using rule 54 (writing -> WRITELN SEMICOLON .)
    USES            reduce using rule 54 (writing -> WRITELN SEMICOLON .)
    VAR             reduce using rule 54 (writing -> WRITELN SEMICOLON .)
    FUNCTION        reduce using rule 54 (writing -> WRITELN SEMICOLON .)
    PROCEDURE       reduce using rule 54 (writing -> WRITELN SEMICOLON .)
    BEGIN           reduce using rule 54 (writing -> WRITELN SEMICOLON .)
    $end            reduce using rule 54 (writing -> WRITELN SEMICOLON .)


state 61

    (49) writing -> WRITELN LPAREN . id_text_l TEXT id_text_r RPAREN SEMICOLON
    (50) writing -> WRITELN LPAREN . id_num RPAREN SEMICOLON
    (43) id_text_l -> . callFunctions COMMA id_text_l
    (44) id_text_l -> . ID COMMA id_text_l
    (45) id_text_l -> . empty
    (104) id_num -> . NUMBER
    (105) id_num -> . ID
    (36) callFunctions -> . ID LPAREN params RPAREN
    (18) empty -> .

    ID              shift and go to state 117
    NUMBER          shift and go to state 116
    TEXT            reduce using rule 18 (empty -> .)

    id_text_l                      shift and go to state 114
    id_num                         shift and go to state 115
    callFunctions                  shift and go to state 113
    empty                          shift and go to state 118

state 62

    (36) callFunctions -> ID LPAREN . params RPAREN
    (37) params -> . math params2
    (19) math -> . factor mathi
    (22) factor -> . LPAREN math RPAREN
    (23) factor -> . NUMBER
    (24) factor -> . ID

    LPAREN          shift and go to state 107
    NUMBER          shift and go to state 43
    ID              shift and go to state 120

    params                         shift and go to state 119
    math                           shift and go to state 121
    factor                         shift and go to state 48

state 63

    (55) asignation -> ID EQUAL . callFunctions SEMICOLON
    (56) asignation -> ID EQUAL . math SEMICOLON
    (57) asignation -> ID EQUAL . boolean SEMICOLON
    (58) asignation -> ID EQUAL . TEXT SEMICOLON
    (36) callFunctions -> . ID LPAREN params RPAREN
    (19) math -> . factor mathi
    (106) boolean -> . TRUE
    (107) boolean -> . FALSE
    (22) factor -> . LPAREN math RPAREN
    (23) factor -> . NUMBER
    (24) factor -> . ID

    TEXT            shift and go to state 122
    ID              shift and go to state 125
    TRUE            shift and go to state 45
    FALSE           shift and go to state 54
    LPAREN          shift and go to state 107
    NUMBER          shift and go to state 43

    boolean                        shift and go to state 123
    callFunctions                  shift and go to state 124
    factor                         shift and go to state 48
    math                           shift and go to state 126

state 64

    (66) if -> IF internexpression . op_cycle THEN otherBegin_if
    (67) if -> IF internexpression . op_cycle THEN instruction_one_line
    (68) if -> IF internexpression . op_cycle THEN otherBegin_if ELSE otherBegin
    (69) if -> IF internexpression . op_cycle THEN otherBegin_if ELSE instruction_one_line
    (70) if -> IF internexpression . op_cycle THEN instruction_one_line ELSE otherBegin
    (71) if -> IF internexpression . op_cycle THEN instruction_one_line ELSE instruction_one_line
    (74) op_cycle -> . op_logic internexpression op_cycle
    (75) op_cycle -> . empty
    (100) op_logic -> . AND
    (101) op_logic -> . OR
    (102) op_logic -> . XOR
    (103) op_logic -> . NOT
    (18) empty -> .

    AND             shift and go to state 89
    OR              shift and go to state 94
    XOR             shift and go to state 90
    NOT             shift and go to state 92
    THEN            reduce using rule 18 (empty -> .)

    op_logic                       shift and go to state 91
    op_cycle                       shift and go to state 127
    empty                          shift and go to state 95

state 65

    (30) procedure_declaration -> BEGIN instruction END . DOT

    DOT             shift and go to state 128


state 66

    (31) instruction -> asignation instruction .

    END             reduce using rule 31 (instruction -> asignation instruction .)
    PROGRAM         reduce using rule 31 (instruction -> asignation instruction .)
    USES            reduce using rule 31 (instruction -> asignation instruction .)
    VAR             reduce using rule 31 (instruction -> asignation instruction .)
    FUNCTION        reduce using rule 31 (instruction -> asignation instruction .)
    PROCEDURE       reduce using rule 31 (instruction -> asignation instruction .)
    BEGIN           reduce using rule 31 (instruction -> asignation instruction .)
    $end            reduce using rule 31 (instruction -> asignation instruction .)
    ID              reduce using rule 31 (instruction -> asignation instruction .)
    WRITELN         reduce using rule 31 (instruction -> asignation instruction .)
    READLN          reduce using rule 31 (instruction -> asignation instruction .)
    WHILE           reduce using rule 31 (instruction -> asignation instruction .)
    IF              reduce using rule 31 (instruction -> asignation instruction .)
    FOR             reduce using rule 31 (instruction -> asignation instruction .)
    ELSE            reduce using rule 31 (instruction -> asignation instruction .)


state 67

    (53) writing -> READLN SEMICOLON .

    ID              reduce using rule 53 (writing -> READLN SEMICOLON .)
    WRITELN         reduce using rule 53 (writing -> READLN SEMICOLON .)
    READLN          reduce using rule 53 (writing -> READLN SEMICOLON .)
    WHILE           reduce using rule 53 (writing -> READLN SEMICOLON .)
    IF              reduce using rule 53 (writing -> READLN SEMICOLON .)
    FOR             reduce using rule 53 (writing -> READLN SEMICOLON .)
    END             reduce using rule 53 (writing -> READLN SEMICOLON .)
    ELSE            reduce using rule 53 (writing -> READLN SEMICOLON .)
    PROGRAM         reduce using rule 53 (writing -> READLN SEMICOLON .)
    USES            reduce using rule 53 (writing -> READLN SEMICOLON .)
    VAR             reduce using rule 53 (writing -> READLN SEMICOLON .)
    FUNCTION        reduce using rule 53 (writing -> READLN SEMICOLON .)
    PROCEDURE       reduce using rule 53 (writing -> READLN SEMICOLON .)
    BEGIN           reduce using rule 53 (writing -> READLN SEMICOLON .)
    $end            reduce using rule 53 (writing -> READLN SEMICOLON .)


state 68

    (51) writing -> READLN LPAREN . ID RPAREN SEMICOLON
    (52) writing -> READLN LPAREN . RPAREN SEMICOLON

    ID              shift and go to state 130
    RPAREN          shift and go to state 129


state 69

    (33) instruction -> cycles instruction .
    (64) type_cycle -> cycles instruction .

  ! reduce/reduce conflict for END resolved using rule 33 (instruction -> cycles instruction .)
  ! reduce/reduce conflict for ID resolved using rule 33 (instruction -> cycles instruction .)
  ! reduce/reduce conflict for WRITELN resolved using rule 33 (instruction -> cycles instruction .)
  ! reduce/reduce conflict for READLN resolved using rule 33 (instruction -> cycles instruction .)
  ! reduce/reduce conflict for WHILE resolved using rule 33 (instruction -> cycles instruction .)
  ! reduce/reduce conflict for IF resolved using rule 33 (instruction -> cycles instruction .)
  ! reduce/reduce conflict for FOR resolved using rule 33 (instruction -> cycles instruction .)
  ! reduce/reduce conflict for ELSE resolved using rule 33 (instruction -> cycles instruction .)
  ! reduce/reduce conflict for PROGRAM resolved using rule 33 (instruction -> cycles instruction .)
  ! reduce/reduce conflict for USES resolved using rule 33 (instruction -> cycles instruction .)
  ! reduce/reduce conflict for VAR resolved using rule 33 (instruction -> cycles instruction .)
  ! reduce/reduce conflict for FUNCTION resolved using rule 33 (instruction -> cycles instruction .)
  ! reduce/reduce conflict for PROCEDURE resolved using rule 33 (instruction -> cycles instruction .)
  ! reduce/reduce conflict for BEGIN resolved using rule 33 (instruction -> cycles instruction .)
  ! reduce/reduce conflict for $end resolved using rule 33 (instruction -> cycles instruction .)
    END             reduce using rule 33 (instruction -> cycles instruction .)
    PROGRAM         reduce using rule 33 (instruction -> cycles instruction .)
    USES            reduce using rule 33 (instruction -> cycles instruction .)
    VAR             reduce using rule 33 (instruction -> cycles instruction .)
    FUNCTION        reduce using rule 33 (instruction -> cycles instruction .)
    PROCEDURE       reduce using rule 33 (instruction -> cycles instruction .)
    BEGIN           reduce using rule 33 (instruction -> cycles instruction .)
    $end            reduce using rule 33 (instruction -> cycles instruction .)
    ID              reduce using rule 33 (instruction -> cycles instruction .)
    WRITELN         reduce using rule 33 (instruction -> cycles instruction .)
    READLN          reduce using rule 33 (instruction -> cycles instruction .)
    WHILE           reduce using rule 33 (instruction -> cycles instruction .)
    IF              reduce using rule 33 (instruction -> cycles instruction .)
    FOR             reduce using rule 33 (instruction -> cycles instruction .)
    ELSE            reduce using rule 33 (instruction -> cycles instruction .)

  ! END             [ reduce using rule 64 (type_cycle -> cycles instruction .) ]
  ! ID              [ reduce using rule 64 (type_cycle -> cycles instruction .) ]
  ! WRITELN         [ reduce using rule 64 (type_cycle -> cycles instruction .) ]
  ! READLN          [ reduce using rule 64 (type_cycle -> cycles instruction .) ]
  ! WHILE           [ reduce using rule 64 (type_cycle -> cycles instruction .) ]
  ! IF              [ reduce using rule 64 (type_cycle -> cycles instruction .) ]
  ! FOR             [ reduce using rule 64 (type_cycle -> cycles instruction .) ]
  ! ELSE            [ reduce using rule 64 (type_cycle -> cycles instruction .) ]
  ! PROGRAM         [ reduce using rule 64 (type_cycle -> cycles instruction .) ]
  ! USES            [ reduce using rule 64 (type_cycle -> cycles instruction .) ]
  ! VAR             [ reduce using rule 64 (type_cycle -> cycles instruction .) ]
  ! FUNCTION        [ reduce using rule 64 (type_cycle -> cycles instruction .) ]
  ! PROCEDURE       [ reduce using rule 64 (type_cycle -> cycles instruction .) ]
  ! BEGIN           [ reduce using rule 64 (type_cycle -> cycles instruction .) ]
  ! $end            [ reduce using rule 64 (type_cycle -> cycles instruction .) ]


state 70

    (13) var_declaration_2 -> ID var_declaration_3 . COLON type_specifier SEMICOLON var_declaration_4

    COLON           shift and go to state 131


state 71

    (14) var_declaration_3 -> COMMA . ID var_declaration_3

    ID              shift and go to state 132


state 72

    (15) var_declaration_3 -> empty .

    COLON           reduce using rule 15 (var_declaration_3 -> empty .)


state 73

    (114) function_declaration -> PROCEDURE ID SEMICOLON . Begin_function
    (110) Begin_function -> . var_declaration BEGIN instruction END SEMICOLON instruction
    (111) Begin_function -> . BEGIN instruction END SEMICOLON instruction
    (12) var_declaration -> . VAR var_declaration_2

    BEGIN           shift and go to state 133
    VAR             shift and go to state 9

    Begin_function                 shift and go to state 135
    var_declaration                shift and go to state 134

state 74

    (113) function_declaration -> PROCEDURE ID LPAREN . fun_param RPAREN SEMICOLON Begin_function
    (115) fun_param -> . ID fun_param_2 COLON type_specifier fun_param
    (116) fun_param -> . SEMICOLON ID fun_param_2 COLON type_specifier fun_param
    (117) fun_param -> . empty
    (18) empty -> .

    ID              shift and go to state 77
    SEMICOLON       shift and go to state 75
    RPAREN          reduce using rule 18 (empty -> .)

    fun_param                      shift and go to state 136
    empty                          shift and go to state 78

state 75

    (116) fun_param -> SEMICOLON . ID fun_param_2 COLON type_specifier fun_param

    ID              shift and go to state 137


state 76

    (112) function_declaration -> FUNCTION ID LPAREN fun_param . RPAREN COLON type_specifier SEMICOLON Begin_function

    RPAREN          shift and go to state 138


state 77

    (115) fun_param -> ID . fun_param_2 COLON type_specifier fun_param
    (118) fun_param_2 -> . COMMA ID fun_param_2
    (119) fun_param_2 -> . empty
    (18) empty -> .

    COMMA           shift and go to state 140
    COLON           reduce using rule 18 (empty -> .)

    fun_param_2                    shift and go to state 139
    empty                          shift and go to state 141

state 78

    (117) fun_param -> empty .

    RPAREN          reduce using rule 117 (fun_param -> empty .)


state 79

    (10) header_declaration_3 -> COMMA ID . header_declaration_3
    (10) header_declaration_3 -> . COMMA ID header_declaration_3
    (11) header_declaration_3 -> . empty
    (18) empty -> .

    COMMA           shift and go to state 39
    SEMICOLON       reduce using rule 18 (empty -> .)

    header_declaration_3           shift and go to state 142
    empty                          shift and go to state 41

state 80

    (9) header_declaration -> USES ID header_declaration_3 SEMICOLON .

    PROGRAM         reduce using rule 9 (header_declaration -> USES ID header_declaration_3 SEMICOLON .)
    USES            reduce using rule 9 (header_declaration -> USES ID header_declaration_3 SEMICOLON .)
    VAR             reduce using rule 9 (header_declaration -> USES ID header_declaration_3 SEMICOLON .)
    FUNCTION        reduce using rule 9 (header_declaration -> USES ID header_declaration_3 SEMICOLON .)
    PROCEDURE       reduce using rule 9 (header_declaration -> USES ID header_declaration_3 SEMICOLON .)
    BEGIN           reduce using rule 9 (header_declaration -> USES ID header_declaration_3 SEMICOLON .)
    $end            reduce using rule 9 (header_declaration -> USES ID header_declaration_3 SEMICOLON .)


state 81

    (92) type_op -> GREATEREQUAL .

    LPAREN          reduce using rule 92 (type_op -> GREATEREQUAL .)
    NUMBER          reduce using rule 92 (type_op -> GREATEREQUAL .)
    ID              reduce using rule 92 (type_op -> GREATEREQUAL .)
    TEXT            reduce using rule 92 (type_op -> GREATEREQUAL .)


state 82

    (91) type_op -> GREATER .

    LPAREN          reduce using rule 91 (type_op -> GREATER .)
    NUMBER          reduce using rule 91 (type_op -> GREATER .)
    ID              reduce using rule 91 (type_op -> GREATER .)
    TEXT            reduce using rule 91 (type_op -> GREATER .)


state 83

    (90) type_op -> LESS .

    LPAREN          reduce using rule 90 (type_op -> LESS .)
    NUMBER          reduce using rule 90 (type_op -> LESS .)
    ID              reduce using rule 90 (type_op -> LESS .)
    TEXT            reduce using rule 90 (type_op -> LESS .)


state 84

    (93) type_op -> DEQUAL .

    LPAREN          reduce using rule 93 (type_op -> DEQUAL .)
    NUMBER          reduce using rule 93 (type_op -> DEQUAL .)
    ID              reduce using rule 93 (type_op -> DEQUAL .)
    TEXT            reduce using rule 93 (type_op -> DEQUAL .)


state 85

    (94) type_op -> ISEQUAL .

    ID              reduce using rule 94 (type_op -> ISEQUAL .)
    LPAREN          reduce using rule 94 (type_op -> ISEQUAL .)
    NUMBER          reduce using rule 94 (type_op -> ISEQUAL .)
    TEXT            reduce using rule 94 (type_op -> ISEQUAL .)


state 86

    (87) expression2 -> TEXT type_op . TEXT
    (88) expression2 -> TEXT type_op . ID

    TEXT            shift and go to state 143
    ID              shift and go to state 144


state 87

    (89) type_op -> LESSEQUAL .

    LPAREN          reduce using rule 89 (type_op -> LESSEQUAL .)
    NUMBER          reduce using rule 89 (type_op -> LESSEQUAL .)
    ID              reduce using rule 89 (type_op -> LESSEQUAL .)
    TEXT            reduce using rule 89 (type_op -> LESSEQUAL .)


state 88

    (85) expression -> boolean ISEQUAL . math
    (19) math -> . factor mathi
    (22) factor -> . LPAREN math RPAREN
    (23) factor -> . NUMBER
    (24) factor -> . ID

    LPAREN          shift and go to state 107
    NUMBER          shift and go to state 43
    ID              shift and go to state 120

    math                           shift and go to state 145
    factor                         shift and go to state 48

state 89

    (100) op_logic -> AND .

    LPAREN          reduce using rule 100 (op_logic -> AND .)
    ID              reduce using rule 100 (op_logic -> AND .)
    TRUE            reduce using rule 100 (op_logic -> AND .)
    FALSE           reduce using rule 100 (op_logic -> AND .)
    TEXT            reduce using rule 100 (op_logic -> AND .)
    NUMBER          reduce using rule 100 (op_logic -> AND .)


state 90

    (102) op_logic -> XOR .

    LPAREN          reduce using rule 102 (op_logic -> XOR .)
    ID              reduce using rule 102 (op_logic -> XOR .)
    TRUE            reduce using rule 102 (op_logic -> XOR .)
    FALSE           reduce using rule 102 (op_logic -> XOR .)
    TEXT            reduce using rule 102 (op_logic -> XOR .)
    NUMBER          reduce using rule 102 (op_logic -> XOR .)


state 91

    (74) op_cycle -> op_logic . internexpression op_cycle
    (76) internexpression -> . parentheses
    (77) internexpression -> . expression
    (78) parentheses -> . LPAREN expression RPAREN
    (79) expression -> . callFunctions
    (80) expression -> . callFunctions type_op math
    (81) expression -> . callFunctions type_op callFunctions
    (82) expression -> . math type_op math
    (83) expression -> . ID
    (84) expression -> . math ISEQUAL boolean
    (85) expression -> . boolean ISEQUAL math
    (86) expression -> . expression2
    (36) callFunctions -> . ID LPAREN params RPAREN
    (19) math -> . factor mathi
    (106) boolean -> . TRUE
    (107) boolean -> . FALSE
    (87) expression2 -> . TEXT type_op TEXT
    (88) expression2 -> . TEXT type_op ID
    (22) factor -> . LPAREN math RPAREN
    (23) factor -> . NUMBER
    (24) factor -> . ID

    LPAREN          shift and go to state 50
    ID              shift and go to state 52
    TRUE            shift and go to state 45
    FALSE           shift and go to state 54
    TEXT            shift and go to state 42
    NUMBER          shift and go to state 43

    parentheses                    shift and go to state 53
    internexpression               shift and go to state 146
    boolean                        shift and go to state 44
    callFunctions                  shift and go to state 47
    factor                         shift and go to state 48
    expression2                    shift and go to state 51
    expression                     shift and go to state 55
    math                           shift and go to state 49

state 92

    (103) op_logic -> NOT .

    LPAREN          reduce using rule 103 (op_logic -> NOT .)
    ID              reduce using rule 103 (op_logic -> NOT .)
    TRUE            reduce using rule 103 (op_logic -> NOT .)
    FALSE           reduce using rule 103 (op_logic -> NOT .)
    TEXT            reduce using rule 103 (op_logic -> NOT .)
    NUMBER          reduce using rule 103 (op_logic -> NOT .)


state 93

    (65) while -> WHILE internexpression op_cycle . DO otherBegin

    DO              shift and go to state 147


state 94

    (101) op_logic -> OR .

    LPAREN          reduce using rule 101 (op_logic -> OR .)
    ID              reduce using rule 101 (op_logic -> OR .)
    TRUE            reduce using rule 101 (op_logic -> OR .)
    FALSE           reduce using rule 101 (op_logic -> OR .)
    TEXT            reduce using rule 101 (op_logic -> OR .)
    NUMBER          reduce using rule 101 (op_logic -> OR .)


state 95

    (75) op_cycle -> empty .

    DO              reduce using rule 75 (op_cycle -> empty .)
    THEN            reduce using rule 75 (op_cycle -> empty .)


state 96

    (80) expression -> callFunctions type_op . math
    (81) expression -> callFunctions type_op . callFunctions
    (19) math -> . factor mathi
    (36) callFunctions -> . ID LPAREN params RPAREN
    (22) factor -> . LPAREN math RPAREN
    (23) factor -> . NUMBER
    (24) factor -> . ID

    ID              shift and go to state 125
    LPAREN          shift and go to state 107
    NUMBER          shift and go to state 43

    callFunctions                  shift and go to state 148
    factor                         shift and go to state 48
    math                           shift and go to state 149

state 97

    (19) math -> factor mathi .

    RPAREN          reduce using rule 19 (math -> factor mathi .)
    ISEQUAL         reduce using rule 19 (math -> factor mathi .)
    LESSEQUAL       reduce using rule 19 (math -> factor mathi .)
    LESS            reduce using rule 19 (math -> factor mathi .)
    GREATER         reduce using rule 19 (math -> factor mathi .)
    GREATEREQUAL    reduce using rule 19 (math -> factor mathi .)
    DEQUAL          reduce using rule 19 (math -> factor mathi .)
    AND             reduce using rule 19 (math -> factor mathi .)
    OR              reduce using rule 19 (math -> factor mathi .)
    XOR             reduce using rule 19 (math -> factor mathi .)
    NOT             reduce using rule 19 (math -> factor mathi .)
    DO              reduce using rule 19 (math -> factor mathi .)
    THEN            reduce using rule 19 (math -> factor mathi .)
    SEMICOLON       reduce using rule 19 (math -> factor mathi .)
    COMMA           reduce using rule 19 (math -> factor mathi .)


state 98

    (98) type_op_math -> DIVIDE .

    LPAREN          reduce using rule 98 (type_op_math -> DIVIDE .)
    NUMBER          reduce using rule 98 (type_op_math -> DIVIDE .)
    ID              reduce using rule 98 (type_op_math -> DIVIDE .)


state 99

    (97) type_op_math -> TIMES .

    LPAREN          reduce using rule 97 (type_op_math -> TIMES .)
    NUMBER          reduce using rule 97 (type_op_math -> TIMES .)
    ID              reduce using rule 97 (type_op_math -> TIMES .)


state 100

    (95) type_op_math -> PLUS .

    LPAREN          reduce using rule 95 (type_op_math -> PLUS .)
    NUMBER          reduce using rule 95 (type_op_math -> PLUS .)
    ID              reduce using rule 95 (type_op_math -> PLUS .)


state 101

    (20) mathi -> type_op_math . factor mathi
    (22) factor -> . LPAREN math RPAREN
    (23) factor -> . NUMBER
    (24) factor -> . ID

    LPAREN          shift and go to state 107
    NUMBER          shift and go to state 43
    ID              shift and go to state 120

    factor                         shift and go to state 150

state 102

    (96) type_op_math -> MINUS .

    LPAREN          reduce using rule 96 (type_op_math -> MINUS .)
    NUMBER          reduce using rule 96 (type_op_math -> MINUS .)
    ID              reduce using rule 96 (type_op_math -> MINUS .)


state 103

    (21) mathi -> empty .

    ISEQUAL         reduce using rule 21 (mathi -> empty .)
    LESSEQUAL       reduce using rule 21 (mathi -> empty .)
    LESS            reduce using rule 21 (mathi -> empty .)
    GREATER         reduce using rule 21 (mathi -> empty .)
    GREATEREQUAL    reduce using rule 21 (mathi -> empty .)
    DEQUAL          reduce using rule 21 (mathi -> empty .)
    RPAREN          reduce using rule 21 (mathi -> empty .)
    COMMA           reduce using rule 21 (mathi -> empty .)
    SEMICOLON       reduce using rule 21 (mathi -> empty .)
    AND             reduce using rule 21 (mathi -> empty .)
    OR              reduce using rule 21 (mathi -> empty .)
    XOR             reduce using rule 21 (mathi -> empty .)
    NOT             reduce using rule 21 (mathi -> empty .)
    DO              reduce using rule 21 (mathi -> empty .)
    THEN            reduce using rule 21 (mathi -> empty .)


state 104

    (99) type_op_math -> MOD .

    LPAREN          reduce using rule 99 (type_op_math -> MOD .)
    NUMBER          reduce using rule 99 (type_op_math -> MOD .)
    ID              reduce using rule 99 (type_op_math -> MOD .)


state 105

    (82) expression -> math type_op . math
    (19) math -> . factor mathi
    (22) factor -> . LPAREN math RPAREN
    (23) factor -> . NUMBER
    (24) factor -> . ID

    LPAREN          shift and go to state 107
    NUMBER          shift and go to state 43
    ID              shift and go to state 120

    math                           shift and go to state 151
    factor                         shift and go to state 48

state 106

    (84) expression -> math ISEQUAL . boolean
    (94) type_op -> ISEQUAL .
    (106) boolean -> . TRUE
    (107) boolean -> . FALSE

    LPAREN          reduce using rule 94 (type_op -> ISEQUAL .)
    NUMBER          reduce using rule 94 (type_op -> ISEQUAL .)
    ID              reduce using rule 94 (type_op -> ISEQUAL .)
    TRUE            shift and go to state 45
    FALSE           shift and go to state 54

    boolean                        shift and go to state 152

state 107

    (22) factor -> LPAREN . math RPAREN
    (19) math -> . factor mathi
    (22) factor -> . LPAREN math RPAREN
    (23) factor -> . NUMBER
    (24) factor -> . ID

    LPAREN          shift and go to state 107
    NUMBER          shift and go to state 43
    ID              shift and go to state 120

    math                           shift and go to state 153
    factor                         shift and go to state 48

state 108

    (78) parentheses -> LPAREN expression . RPAREN

    RPAREN          shift and go to state 154


state 109

    (22) factor -> LPAREN math . RPAREN
    (82) expression -> math . type_op math
    (84) expression -> math . ISEQUAL boolean
    (89) type_op -> . LESSEQUAL
    (90) type_op -> . LESS
    (91) type_op -> . GREATER
    (92) type_op -> . GREATEREQUAL
    (93) type_op -> . DEQUAL
    (94) type_op -> . ISEQUAL

    RPAREN          shift and go to state 155
    ISEQUAL         shift and go to state 106
    LESSEQUAL       shift and go to state 87
    LESS            shift and go to state 83
    GREATER         shift and go to state 82
    GREATEREQUAL    shift and go to state 81
    DEQUAL          shift and go to state 84

    type_op                        shift and go to state 105

state 110

    (73) for -> FOR asignation_for DOWNTO . id_num DO otherBegin
    (104) id_num -> . NUMBER
    (105) id_num -> . ID

    NUMBER          shift and go to state 116
    ID              shift and go to state 157

    id_num                         shift and go to state 156

state 111

    (72) for -> FOR asignation_for TO . id_num DO otherBegin
    (104) id_num -> . NUMBER
    (105) id_num -> . ID

    NUMBER          shift and go to state 116
    ID              shift and go to state 157

    id_num                         shift and go to state 158

state 112

    (59) asignation_for -> ID EQUAL . id_num
    (104) id_num -> . NUMBER
    (105) id_num -> . ID

    NUMBER          shift and go to state 116
    ID              shift and go to state 157

    id_num                         shift and go to state 159

state 113

    (43) id_text_l -> callFunctions . COMMA id_text_l

    COMMA           shift and go to state 160


state 114

    (49) writing -> WRITELN LPAREN id_text_l . TEXT id_text_r RPAREN SEMICOLON

    TEXT            shift and go to state 161


state 115

    (50) writing -> WRITELN LPAREN id_num . RPAREN SEMICOLON

    RPAREN          shift and go to state 162


state 116

    (104) id_num -> NUMBER .

    DO              reduce using rule 104 (id_num -> NUMBER .)
    RPAREN          reduce using rule 104 (id_num -> NUMBER .)
    TO              reduce using rule 104 (id_num -> NUMBER .)
    DOWNTO          reduce using rule 104 (id_num -> NUMBER .)


state 117

    (44) id_text_l -> ID . COMMA id_text_l
    (105) id_num -> ID .
    (36) callFunctions -> ID . LPAREN params RPAREN

    COMMA           shift and go to state 163
    RPAREN          reduce using rule 105 (id_num -> ID .)
    LPAREN          shift and go to state 62


state 118

    (45) id_text_l -> empty .

    TEXT            reduce using rule 45 (id_text_l -> empty .)


state 119

    (36) callFunctions -> ID LPAREN params . RPAREN

    RPAREN          shift and go to state 164


state 120

    (24) factor -> ID .

    PLUS            reduce using rule 24 (factor -> ID .)
    MINUS           reduce using rule 24 (factor -> ID .)
    TIMES           reduce using rule 24 (factor -> ID .)
    DIVIDE          reduce using rule 24 (factor -> ID .)
    MOD             reduce using rule 24 (factor -> ID .)
    AND             reduce using rule 24 (factor -> ID .)
    OR              reduce using rule 24 (factor -> ID .)
    XOR             reduce using rule 24 (factor -> ID .)
    NOT             reduce using rule 24 (factor -> ID .)
    DO              reduce using rule 24 (factor -> ID .)
    THEN            reduce using rule 24 (factor -> ID .)
    RPAREN          reduce using rule 24 (factor -> ID .)
    ISEQUAL         reduce using rule 24 (factor -> ID .)
    LESSEQUAL       reduce using rule 24 (factor -> ID .)
    LESS            reduce using rule 24 (factor -> ID .)
    GREATER         reduce using rule 24 (factor -> ID .)
    GREATEREQUAL    reduce using rule 24 (factor -> ID .)
    DEQUAL          reduce using rule 24 (factor -> ID .)
    COMMA           reduce using rule 24 (factor -> ID .)
    SEMICOLON       reduce using rule 24 (factor -> ID .)


state 121

    (37) params -> math . params2
    (38) params2 -> . COMMA math
    (39) params2 -> . empty
    (18) empty -> .

    COMMA           shift and go to state 166
    RPAREN          reduce using rule 18 (empty -> .)

    params2                        shift and go to state 165
    empty                          shift and go to state 167

state 122

    (58) asignation -> ID EQUAL TEXT . SEMICOLON

    SEMICOLON       shift and go to state 168


state 123

    (57) asignation -> ID EQUAL boolean . SEMICOLON

    SEMICOLON       shift and go to state 169


state 124

    (55) asignation -> ID EQUAL callFunctions . SEMICOLON

    SEMICOLON       shift and go to state 170


state 125

    (36) callFunctions -> ID . LPAREN params RPAREN
    (24) factor -> ID .

    LPAREN          shift and go to state 62
    PLUS            reduce using rule 24 (factor -> ID .)
    MINUS           reduce using rule 24 (factor -> ID .)
    TIMES           reduce using rule 24 (factor -> ID .)
    DIVIDE          reduce using rule 24 (factor -> ID .)
    MOD             reduce using rule 24 (factor -> ID .)
    SEMICOLON       reduce using rule 24 (factor -> ID .)
    AND             reduce using rule 24 (factor -> ID .)
    OR              reduce using rule 24 (factor -> ID .)
    XOR             reduce using rule 24 (factor -> ID .)
    NOT             reduce using rule 24 (factor -> ID .)
    DO              reduce using rule 24 (factor -> ID .)
    THEN            reduce using rule 24 (factor -> ID .)
    RPAREN          reduce using rule 24 (factor -> ID .)


state 126

    (56) asignation -> ID EQUAL math . SEMICOLON

    SEMICOLON       shift and go to state 171


state 127

    (66) if -> IF internexpression op_cycle . THEN otherBegin_if
    (67) if -> IF internexpression op_cycle . THEN instruction_one_line
    (68) if -> IF internexpression op_cycle . THEN otherBegin_if ELSE otherBegin
    (69) if -> IF internexpression op_cycle . THEN otherBegin_if ELSE instruction_one_line
    (70) if -> IF internexpression op_cycle . THEN instruction_one_line ELSE otherBegin
    (71) if -> IF internexpression op_cycle . THEN instruction_one_line ELSE instruction_one_line

    THEN            shift and go to state 172


state 128

    (30) procedure_declaration -> BEGIN instruction END DOT .

    PROGRAM         reduce using rule 30 (procedure_declaration -> BEGIN instruction END DOT .)
    USES            reduce using rule 30 (procedure_declaration -> BEGIN instruction END DOT .)
    VAR             reduce using rule 30 (procedure_declaration -> BEGIN instruction END DOT .)
    FUNCTION        reduce using rule 30 (procedure_declaration -> BEGIN instruction END DOT .)
    PROCEDURE       reduce using rule 30 (procedure_declaration -> BEGIN instruction END DOT .)
    BEGIN           reduce using rule 30 (procedure_declaration -> BEGIN instruction END DOT .)
    $end            reduce using rule 30 (procedure_declaration -> BEGIN instruction END DOT .)


state 129

    (52) writing -> READLN LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 173


state 130

    (51) writing -> READLN LPAREN ID . RPAREN SEMICOLON

    RPAREN          shift and go to state 174


state 131

    (13) var_declaration_2 -> ID var_declaration_3 COLON . type_specifier SEMICOLON var_declaration_4
    (25) type_specifier -> . INTEGER
    (26) type_specifier -> . REAL
    (27) type_specifier -> . CHAR
    (28) type_specifier -> . BOOLEAN
    (29) type_specifier -> . DOUBLE

    INTEGER         shift and go to state 180
    REAL            shift and go to state 175
    CHAR            shift and go to state 178
    BOOLEAN         shift and go to state 179
    DOUBLE          shift and go to state 177

    type_specifier                 shift and go to state 176

state 132

    (14) var_declaration_3 -> COMMA ID . var_declaration_3
    (14) var_declaration_3 -> . COMMA ID var_declaration_3
    (15) var_declaration_3 -> . empty
    (18) empty -> .

    COMMA           shift and go to state 71
    COLON           reduce using rule 18 (empty -> .)

    var_declaration_3              shift and go to state 181
    empty                          shift and go to state 72

state 133

    (111) Begin_function -> BEGIN . instruction END SEMICOLON instruction
    (31) instruction -> . asignation instruction
    (32) instruction -> . writing instruction
    (33) instruction -> . cycles instruction
    (34) instruction -> . callFunctions instruction
    (35) instruction -> . empty
    (55) asignation -> . ID EQUAL callFunctions SEMICOLON
    (56) asignation -> . ID EQUAL math SEMICOLON
    (57) asignation -> . ID EQUAL boolean SEMICOLON
    (58) asignation -> . ID EQUAL TEXT SEMICOLON
    (49) writing -> . WRITELN LPAREN id_text_l TEXT id_text_r RPAREN SEMICOLON
    (50) writing -> . WRITELN LPAREN id_num RPAREN SEMICOLON
    (51) writing -> . READLN LPAREN ID RPAREN SEMICOLON
    (52) writing -> . READLN LPAREN RPAREN SEMICOLON
    (53) writing -> . READLN SEMICOLON
    (54) writing -> . WRITELN SEMICOLON
    (60) cycles -> . type_cycle
    (36) callFunctions -> . ID LPAREN params RPAREN
    (18) empty -> .
    (61) type_cycle -> . while
    (62) type_cycle -> . if
    (63) type_cycle -> . for
    (64) type_cycle -> . cycles instruction
    (65) while -> . WHILE internexpression op_cycle DO otherBegin
    (66) if -> . IF internexpression op_cycle THEN otherBegin_if
    (67) if -> . IF internexpression op_cycle THEN instruction_one_line
    (68) if -> . IF internexpression op_cycle THEN otherBegin_if ELSE otherBegin
    (69) if -> . IF internexpression op_cycle THEN otherBegin_if ELSE instruction_one_line
    (70) if -> . IF internexpression op_cycle THEN instruction_one_line ELSE otherBegin
    (71) if -> . IF internexpression op_cycle THEN instruction_one_line ELSE instruction_one_line
    (72) for -> . FOR asignation_for TO id_num DO otherBegin
    (73) for -> . FOR asignation_for DOWNTO id_num DO otherBegin

    ID              shift and go to state 24
    WRITELN         shift and go to state 23
    READLN          shift and go to state 29
    END             reduce using rule 18 (empty -> .)
    WHILE           shift and go to state 17
    IF              shift and go to state 25
    FOR             shift and go to state 22

    instruction                    shift and go to state 182
    if                             shift and go to state 20
    for                            shift and go to state 26
    writing                        shift and go to state 18
    callFunctions                  shift and go to state 19
    asignation                     shift and go to state 28
    type_cycle                     shift and go to state 30
    while                          shift and go to state 31
    empty                          shift and go to state 21
    cycles                         shift and go to state 32

state 134

    (110) Begin_function -> var_declaration . BEGIN instruction END SEMICOLON instruction

    BEGIN           shift and go to state 183


state 135

    (114) function_declaration -> PROCEDURE ID SEMICOLON Begin_function .

    PROGRAM         reduce using rule 114 (function_declaration -> PROCEDURE ID SEMICOLON Begin_function .)
    USES            reduce using rule 114 (function_declaration -> PROCEDURE ID SEMICOLON Begin_function .)
    VAR             reduce using rule 114 (function_declaration -> PROCEDURE ID SEMICOLON Begin_function .)
    FUNCTION        reduce using rule 114 (function_declaration -> PROCEDURE ID SEMICOLON Begin_function .)
    PROCEDURE       reduce using rule 114 (function_declaration -> PROCEDURE ID SEMICOLON Begin_function .)
    BEGIN           reduce using rule 114 (function_declaration -> PROCEDURE ID SEMICOLON Begin_function .)
    $end            reduce using rule 114 (function_declaration -> PROCEDURE ID SEMICOLON Begin_function .)


state 136

    (113) function_declaration -> PROCEDURE ID LPAREN fun_param . RPAREN SEMICOLON Begin_function

    RPAREN          shift and go to state 184


state 137

    (116) fun_param -> SEMICOLON ID . fun_param_2 COLON type_specifier fun_param
    (118) fun_param_2 -> . COMMA ID fun_param_2
    (119) fun_param_2 -> . empty
    (18) empty -> .

    COMMA           shift and go to state 140
    COLON           reduce using rule 18 (empty -> .)

    fun_param_2                    shift and go to state 185
    empty                          shift and go to state 141

state 138

    (112) function_declaration -> FUNCTION ID LPAREN fun_param RPAREN . COLON type_specifier SEMICOLON Begin_function

    COLON           shift and go to state 186


state 139

    (115) fun_param -> ID fun_param_2 . COLON type_specifier fun_param

    COLON           shift and go to state 187


state 140

    (118) fun_param_2 -> COMMA . ID fun_param_2

    ID              shift and go to state 188


state 141

    (119) fun_param_2 -> empty .

    COLON           reduce using rule 119 (fun_param_2 -> empty .)


state 142

    (10) header_declaration_3 -> COMMA ID header_declaration_3 .

    SEMICOLON       reduce using rule 10 (header_declaration_3 -> COMMA ID header_declaration_3 .)


state 143

    (87) expression2 -> TEXT type_op TEXT .

    AND             reduce using rule 87 (expression2 -> TEXT type_op TEXT .)
    OR              reduce using rule 87 (expression2 -> TEXT type_op TEXT .)
    XOR             reduce using rule 87 (expression2 -> TEXT type_op TEXT .)
    NOT             reduce using rule 87 (expression2 -> TEXT type_op TEXT .)
    THEN            reduce using rule 87 (expression2 -> TEXT type_op TEXT .)
    RPAREN          reduce using rule 87 (expression2 -> TEXT type_op TEXT .)
    DO              reduce using rule 87 (expression2 -> TEXT type_op TEXT .)


state 144

    (88) expression2 -> TEXT type_op ID .

    AND             reduce using rule 88 (expression2 -> TEXT type_op ID .)
    OR              reduce using rule 88 (expression2 -> TEXT type_op ID .)
    XOR             reduce using rule 88 (expression2 -> TEXT type_op ID .)
    NOT             reduce using rule 88 (expression2 -> TEXT type_op ID .)
    THEN            reduce using rule 88 (expression2 -> TEXT type_op ID .)
    RPAREN          reduce using rule 88 (expression2 -> TEXT type_op ID .)
    DO              reduce using rule 88 (expression2 -> TEXT type_op ID .)


state 145

    (85) expression -> boolean ISEQUAL math .

    AND             reduce using rule 85 (expression -> boolean ISEQUAL math .)
    OR              reduce using rule 85 (expression -> boolean ISEQUAL math .)
    XOR             reduce using rule 85 (expression -> boolean ISEQUAL math .)
    NOT             reduce using rule 85 (expression -> boolean ISEQUAL math .)
    DO              reduce using rule 85 (expression -> boolean ISEQUAL math .)
    THEN            reduce using rule 85 (expression -> boolean ISEQUAL math .)
    RPAREN          reduce using rule 85 (expression -> boolean ISEQUAL math .)


state 146

    (74) op_cycle -> op_logic internexpression . op_cycle
    (74) op_cycle -> . op_logic internexpression op_cycle
    (75) op_cycle -> . empty
    (100) op_logic -> . AND
    (101) op_logic -> . OR
    (102) op_logic -> . XOR
    (103) op_logic -> . NOT
    (18) empty -> .

    AND             shift and go to state 89
    OR              shift and go to state 94
    XOR             shift and go to state 90
    NOT             shift and go to state 92
    DO              reduce using rule 18 (empty -> .)
    THEN            reduce using rule 18 (empty -> .)

    op_logic                       shift and go to state 91
    op_cycle                       shift and go to state 189
    empty                          shift and go to state 95

state 147

    (65) while -> WHILE internexpression op_cycle DO . otherBegin
    (108) otherBegin -> . BEGIN instruction END SEMICOLON instruction

    BEGIN           shift and go to state 190

    otherBegin                     shift and go to state 191

state 148

    (81) expression -> callFunctions type_op callFunctions .

    AND             reduce using rule 81 (expression -> callFunctions type_op callFunctions .)
    OR              reduce using rule 81 (expression -> callFunctions type_op callFunctions .)
    XOR             reduce using rule 81 (expression -> callFunctions type_op callFunctions .)
    NOT             reduce using rule 81 (expression -> callFunctions type_op callFunctions .)
    DO              reduce using rule 81 (expression -> callFunctions type_op callFunctions .)
    THEN            reduce using rule 81 (expression -> callFunctions type_op callFunctions .)
    RPAREN          reduce using rule 81 (expression -> callFunctions type_op callFunctions .)


state 149

    (80) expression -> callFunctions type_op math .

    AND             reduce using rule 80 (expression -> callFunctions type_op math .)
    OR              reduce using rule 80 (expression -> callFunctions type_op math .)
    XOR             reduce using rule 80 (expression -> callFunctions type_op math .)
    NOT             reduce using rule 80 (expression -> callFunctions type_op math .)
    DO              reduce using rule 80 (expression -> callFunctions type_op math .)
    THEN            reduce using rule 80 (expression -> callFunctions type_op math .)
    RPAREN          reduce using rule 80 (expression -> callFunctions type_op math .)


state 150

    (20) mathi -> type_op_math factor . mathi
    (20) mathi -> . type_op_math factor mathi
    (21) mathi -> . empty
    (95) type_op_math -> . PLUS
    (96) type_op_math -> . MINUS
    (97) type_op_math -> . TIMES
    (98) type_op_math -> . DIVIDE
    (99) type_op_math -> . MOD
    (18) empty -> .

    PLUS            shift and go to state 100
    MINUS           shift and go to state 102
    TIMES           shift and go to state 99
    DIVIDE          shift and go to state 98
    MOD             shift and go to state 104
    ISEQUAL         reduce using rule 18 (empty -> .)
    LESSEQUAL       reduce using rule 18 (empty -> .)
    LESS            reduce using rule 18 (empty -> .)
    GREATER         reduce using rule 18 (empty -> .)
    GREATEREQUAL    reduce using rule 18 (empty -> .)
    DEQUAL          reduce using rule 18 (empty -> .)
    RPAREN          reduce using rule 18 (empty -> .)
    COMMA           reduce using rule 18 (empty -> .)
    SEMICOLON       reduce using rule 18 (empty -> .)
    AND             reduce using rule 18 (empty -> .)
    OR              reduce using rule 18 (empty -> .)
    XOR             reduce using rule 18 (empty -> .)
    NOT             reduce using rule 18 (empty -> .)
    DO              reduce using rule 18 (empty -> .)
    THEN            reduce using rule 18 (empty -> .)

    mathi                          shift and go to state 192
    empty                          shift and go to state 103
    type_op_math                   shift and go to state 101

state 151

    (82) expression -> math type_op math .

    AND             reduce using rule 82 (expression -> math type_op math .)
    OR              reduce using rule 82 (expression -> math type_op math .)
    XOR             reduce using rule 82 (expression -> math type_op math .)
    NOT             reduce using rule 82 (expression -> math type_op math .)
    DO              reduce using rule 82 (expression -> math type_op math .)
    THEN            reduce using rule 82 (expression -> math type_op math .)
    RPAREN          reduce using rule 82 (expression -> math type_op math .)


state 152

    (84) expression -> math ISEQUAL boolean .

    AND             reduce using rule 84 (expression -> math ISEQUAL boolean .)
    OR              reduce using rule 84 (expression -> math ISEQUAL boolean .)
    XOR             reduce using rule 84 (expression -> math ISEQUAL boolean .)
    NOT             reduce using rule 84 (expression -> math ISEQUAL boolean .)
    DO              reduce using rule 84 (expression -> math ISEQUAL boolean .)
    THEN            reduce using rule 84 (expression -> math ISEQUAL boolean .)
    RPAREN          reduce using rule 84 (expression -> math ISEQUAL boolean .)


state 153

    (22) factor -> LPAREN math . RPAREN

    RPAREN          shift and go to state 155


state 154

    (78) parentheses -> LPAREN expression RPAREN .

    AND             reduce using rule 78 (parentheses -> LPAREN expression RPAREN .)
    OR              reduce using rule 78 (parentheses -> LPAREN expression RPAREN .)
    XOR             reduce using rule 78 (parentheses -> LPAREN expression RPAREN .)
    NOT             reduce using rule 78 (parentheses -> LPAREN expression RPAREN .)
    THEN            reduce using rule 78 (parentheses -> LPAREN expression RPAREN .)
    DO              reduce using rule 78 (parentheses -> LPAREN expression RPAREN .)


state 155

    (22) factor -> LPAREN math RPAREN .

    PLUS            reduce using rule 22 (factor -> LPAREN math RPAREN .)
    MINUS           reduce using rule 22 (factor -> LPAREN math RPAREN .)
    TIMES           reduce using rule 22 (factor -> LPAREN math RPAREN .)
    DIVIDE          reduce using rule 22 (factor -> LPAREN math RPAREN .)
    MOD             reduce using rule 22 (factor -> LPAREN math RPAREN .)
    AND             reduce using rule 22 (factor -> LPAREN math RPAREN .)
    OR              reduce using rule 22 (factor -> LPAREN math RPAREN .)
    XOR             reduce using rule 22 (factor -> LPAREN math RPAREN .)
    NOT             reduce using rule 22 (factor -> LPAREN math RPAREN .)
    DO              reduce using rule 22 (factor -> LPAREN math RPAREN .)
    THEN            reduce using rule 22 (factor -> LPAREN math RPAREN .)
    RPAREN          reduce using rule 22 (factor -> LPAREN math RPAREN .)
    ISEQUAL         reduce using rule 22 (factor -> LPAREN math RPAREN .)
    LESSEQUAL       reduce using rule 22 (factor -> LPAREN math RPAREN .)
    LESS            reduce using rule 22 (factor -> LPAREN math RPAREN .)
    GREATER         reduce using rule 22 (factor -> LPAREN math RPAREN .)
    GREATEREQUAL    reduce using rule 22 (factor -> LPAREN math RPAREN .)
    DEQUAL          reduce using rule 22 (factor -> LPAREN math RPAREN .)
    COMMA           reduce using rule 22 (factor -> LPAREN math RPAREN .)
    SEMICOLON       reduce using rule 22 (factor -> LPAREN math RPAREN .)


state 156

    (73) for -> FOR asignation_for DOWNTO id_num . DO otherBegin

    DO              shift and go to state 193


state 157

    (105) id_num -> ID .

    DO              reduce using rule 105 (id_num -> ID .)
    TO              reduce using rule 105 (id_num -> ID .)
    DOWNTO          reduce using rule 105 (id_num -> ID .)


state 158

    (72) for -> FOR asignation_for TO id_num . DO otherBegin

    DO              shift and go to state 194


state 159

    (59) asignation_for -> ID EQUAL id_num .

    TO              reduce using rule 59 (asignation_for -> ID EQUAL id_num .)
    DOWNTO          reduce using rule 59 (asignation_for -> ID EQUAL id_num .)


state 160

    (43) id_text_l -> callFunctions COMMA . id_text_l
    (43) id_text_l -> . callFunctions COMMA id_text_l
    (44) id_text_l -> . ID COMMA id_text_l
    (45) id_text_l -> . empty
    (36) callFunctions -> . ID LPAREN params RPAREN
    (18) empty -> .

    ID              shift and go to state 196
    TEXT            reduce using rule 18 (empty -> .)

    id_text_l                      shift and go to state 195
    empty                          shift and go to state 118
    callFunctions                  shift and go to state 113

state 161

    (49) writing -> WRITELN LPAREN id_text_l TEXT . id_text_r RPAREN SEMICOLON
    (46) id_text_r -> . COMMA callFunctions id_text_r
    (47) id_text_r -> . COMMA ID id_text_r
    (48) id_text_r -> . empty
    (18) empty -> .

    COMMA           shift and go to state 197
    RPAREN          reduce using rule 18 (empty -> .)

    empty                          shift and go to state 199
    id_text_r                      shift and go to state 198

state 162

    (50) writing -> WRITELN LPAREN id_num RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 200


state 163

    (44) id_text_l -> ID COMMA . id_text_l
    (43) id_text_l -> . callFunctions COMMA id_text_l
    (44) id_text_l -> . ID COMMA id_text_l
    (45) id_text_l -> . empty
    (36) callFunctions -> . ID LPAREN params RPAREN
    (18) empty -> .

    ID              shift and go to state 196
    TEXT            reduce using rule 18 (empty -> .)

    id_text_l                      shift and go to state 201
    empty                          shift and go to state 118
    callFunctions                  shift and go to state 113

state 164

    (36) callFunctions -> ID LPAREN params RPAREN .

    ID              reduce using rule 36 (callFunctions -> ID LPAREN params RPAREN .)
    WRITELN         reduce using rule 36 (callFunctions -> ID LPAREN params RPAREN .)
    READLN          reduce using rule 36 (callFunctions -> ID LPAREN params RPAREN .)
    WHILE           reduce using rule 36 (callFunctions -> ID LPAREN params RPAREN .)
    IF              reduce using rule 36 (callFunctions -> ID LPAREN params RPAREN .)
    FOR             reduce using rule 36 (callFunctions -> ID LPAREN params RPAREN .)
    END             reduce using rule 36 (callFunctions -> ID LPAREN params RPAREN .)
    LESSEQUAL       reduce using rule 36 (callFunctions -> ID LPAREN params RPAREN .)
    LESS            reduce using rule 36 (callFunctions -> ID LPAREN params RPAREN .)
    GREATER         reduce using rule 36 (callFunctions -> ID LPAREN params RPAREN .)
    GREATEREQUAL    reduce using rule 36 (callFunctions -> ID LPAREN params RPAREN .)
    DEQUAL          reduce using rule 36 (callFunctions -> ID LPAREN params RPAREN .)
    ISEQUAL         reduce using rule 36 (callFunctions -> ID LPAREN params RPAREN .)
    RPAREN          reduce using rule 36 (callFunctions -> ID LPAREN params RPAREN .)
    COMMA           reduce using rule 36 (callFunctions -> ID LPAREN params RPAREN .)
    SEMICOLON       reduce using rule 36 (callFunctions -> ID LPAREN params RPAREN .)
    ELSE            reduce using rule 36 (callFunctions -> ID LPAREN params RPAREN .)
    PROGRAM         reduce using rule 36 (callFunctions -> ID LPAREN params RPAREN .)
    USES            reduce using rule 36 (callFunctions -> ID LPAREN params RPAREN .)
    VAR             reduce using rule 36 (callFunctions -> ID LPAREN params RPAREN .)
    FUNCTION        reduce using rule 36 (callFunctions -> ID LPAREN params RPAREN .)
    PROCEDURE       reduce using rule 36 (callFunctions -> ID LPAREN params RPAREN .)
    BEGIN           reduce using rule 36 (callFunctions -> ID LPAREN params RPAREN .)
    $end            reduce using rule 36 (callFunctions -> ID LPAREN params RPAREN .)
    AND             reduce using rule 36 (callFunctions -> ID LPAREN params RPAREN .)
    OR              reduce using rule 36 (callFunctions -> ID LPAREN params RPAREN .)
    XOR             reduce using rule 36 (callFunctions -> ID LPAREN params RPAREN .)
    NOT             reduce using rule 36 (callFunctions -> ID LPAREN params RPAREN .)
    THEN            reduce using rule 36 (callFunctions -> ID LPAREN params RPAREN .)
    DO              reduce using rule 36 (callFunctions -> ID LPAREN params RPAREN .)


state 165

    (37) params -> math params2 .

    RPAREN          reduce using rule 37 (params -> math params2 .)


state 166

    (38) params2 -> COMMA . math
    (19) math -> . factor mathi
    (22) factor -> . LPAREN math RPAREN
    (23) factor -> . NUMBER
    (24) factor -> . ID

    LPAREN          shift and go to state 107
    NUMBER          shift and go to state 43
    ID              shift and go to state 120

    math                           shift and go to state 202
    factor                         shift and go to state 48

state 167

    (39) params2 -> empty .

    RPAREN          reduce using rule 39 (params2 -> empty .)


state 168

    (58) asignation -> ID EQUAL TEXT SEMICOLON .

    ID              reduce using rule 58 (asignation -> ID EQUAL TEXT SEMICOLON .)
    WRITELN         reduce using rule 58 (asignation -> ID EQUAL TEXT SEMICOLON .)
    READLN          reduce using rule 58 (asignation -> ID EQUAL TEXT SEMICOLON .)
    WHILE           reduce using rule 58 (asignation -> ID EQUAL TEXT SEMICOLON .)
    IF              reduce using rule 58 (asignation -> ID EQUAL TEXT SEMICOLON .)
    FOR             reduce using rule 58 (asignation -> ID EQUAL TEXT SEMICOLON .)
    END             reduce using rule 58 (asignation -> ID EQUAL TEXT SEMICOLON .)
    ELSE            reduce using rule 58 (asignation -> ID EQUAL TEXT SEMICOLON .)
    PROGRAM         reduce using rule 58 (asignation -> ID EQUAL TEXT SEMICOLON .)
    USES            reduce using rule 58 (asignation -> ID EQUAL TEXT SEMICOLON .)
    VAR             reduce using rule 58 (asignation -> ID EQUAL TEXT SEMICOLON .)
    FUNCTION        reduce using rule 58 (asignation -> ID EQUAL TEXT SEMICOLON .)
    PROCEDURE       reduce using rule 58 (asignation -> ID EQUAL TEXT SEMICOLON .)
    BEGIN           reduce using rule 58 (asignation -> ID EQUAL TEXT SEMICOLON .)
    $end            reduce using rule 58 (asignation -> ID EQUAL TEXT SEMICOLON .)


state 169

    (57) asignation -> ID EQUAL boolean SEMICOLON .

    ID              reduce using rule 57 (asignation -> ID EQUAL boolean SEMICOLON .)
    WRITELN         reduce using rule 57 (asignation -> ID EQUAL boolean SEMICOLON .)
    READLN          reduce using rule 57 (asignation -> ID EQUAL boolean SEMICOLON .)
    WHILE           reduce using rule 57 (asignation -> ID EQUAL boolean SEMICOLON .)
    IF              reduce using rule 57 (asignation -> ID EQUAL boolean SEMICOLON .)
    FOR             reduce using rule 57 (asignation -> ID EQUAL boolean SEMICOLON .)
    END             reduce using rule 57 (asignation -> ID EQUAL boolean SEMICOLON .)
    ELSE            reduce using rule 57 (asignation -> ID EQUAL boolean SEMICOLON .)
    PROGRAM         reduce using rule 57 (asignation -> ID EQUAL boolean SEMICOLON .)
    USES            reduce using rule 57 (asignation -> ID EQUAL boolean SEMICOLON .)
    VAR             reduce using rule 57 (asignation -> ID EQUAL boolean SEMICOLON .)
    FUNCTION        reduce using rule 57 (asignation -> ID EQUAL boolean SEMICOLON .)
    PROCEDURE       reduce using rule 57 (asignation -> ID EQUAL boolean SEMICOLON .)
    BEGIN           reduce using rule 57 (asignation -> ID EQUAL boolean SEMICOLON .)
    $end            reduce using rule 57 (asignation -> ID EQUAL boolean SEMICOLON .)


state 170

    (55) asignation -> ID EQUAL callFunctions SEMICOLON .

    ID              reduce using rule 55 (asignation -> ID EQUAL callFunctions SEMICOLON .)
    WRITELN         reduce using rule 55 (asignation -> ID EQUAL callFunctions SEMICOLON .)
    READLN          reduce using rule 55 (asignation -> ID EQUAL callFunctions SEMICOLON .)
    WHILE           reduce using rule 55 (asignation -> ID EQUAL callFunctions SEMICOLON .)
    IF              reduce using rule 55 (asignation -> ID EQUAL callFunctions SEMICOLON .)
    FOR             reduce using rule 55 (asignation -> ID EQUAL callFunctions SEMICOLON .)
    END             reduce using rule 55 (asignation -> ID EQUAL callFunctions SEMICOLON .)
    ELSE            reduce using rule 55 (asignation -> ID EQUAL callFunctions SEMICOLON .)
    PROGRAM         reduce using rule 55 (asignation -> ID EQUAL callFunctions SEMICOLON .)
    USES            reduce using rule 55 (asignation -> ID EQUAL callFunctions SEMICOLON .)
    VAR             reduce using rule 55 (asignation -> ID EQUAL callFunctions SEMICOLON .)
    FUNCTION        reduce using rule 55 (asignation -> ID EQUAL callFunctions SEMICOLON .)
    PROCEDURE       reduce using rule 55 (asignation -> ID EQUAL callFunctions SEMICOLON .)
    BEGIN           reduce using rule 55 (asignation -> ID EQUAL callFunctions SEMICOLON .)
    $end            reduce using rule 55 (asignation -> ID EQUAL callFunctions SEMICOLON .)


state 171

    (56) asignation -> ID EQUAL math SEMICOLON .

    ID              reduce using rule 56 (asignation -> ID EQUAL math SEMICOLON .)
    WRITELN         reduce using rule 56 (asignation -> ID EQUAL math SEMICOLON .)
    READLN          reduce using rule 56 (asignation -> ID EQUAL math SEMICOLON .)
    WHILE           reduce using rule 56 (asignation -> ID EQUAL math SEMICOLON .)
    IF              reduce using rule 56 (asignation -> ID EQUAL math SEMICOLON .)
    FOR             reduce using rule 56 (asignation -> ID EQUAL math SEMICOLON .)
    END             reduce using rule 56 (asignation -> ID EQUAL math SEMICOLON .)
    ELSE            reduce using rule 56 (asignation -> ID EQUAL math SEMICOLON .)
    PROGRAM         reduce using rule 56 (asignation -> ID EQUAL math SEMICOLON .)
    USES            reduce using rule 56 (asignation -> ID EQUAL math SEMICOLON .)
    VAR             reduce using rule 56 (asignation -> ID EQUAL math SEMICOLON .)
    FUNCTION        reduce using rule 56 (asignation -> ID EQUAL math SEMICOLON .)
    PROCEDURE       reduce using rule 56 (asignation -> ID EQUAL math SEMICOLON .)
    BEGIN           reduce using rule 56 (asignation -> ID EQUAL math SEMICOLON .)
    $end            reduce using rule 56 (asignation -> ID EQUAL math SEMICOLON .)


state 172

    (66) if -> IF internexpression op_cycle THEN . otherBegin_if
    (67) if -> IF internexpression op_cycle THEN . instruction_one_line
    (68) if -> IF internexpression op_cycle THEN . otherBegin_if ELSE otherBegin
    (69) if -> IF internexpression op_cycle THEN . otherBegin_if ELSE instruction_one_line
    (70) if -> IF internexpression op_cycle THEN . instruction_one_line ELSE otherBegin
    (71) if -> IF internexpression op_cycle THEN . instruction_one_line ELSE instruction_one_line
    (109) otherBegin_if -> . BEGIN instruction END instruction
    (40) instruction_one_line -> . asignation
    (41) instruction_one_line -> . writing
    (42) instruction_one_line -> . cycles
    (55) asignation -> . ID EQUAL callFunctions SEMICOLON
    (56) asignation -> . ID EQUAL math SEMICOLON
    (57) asignation -> . ID EQUAL boolean SEMICOLON
    (58) asignation -> . ID EQUAL TEXT SEMICOLON
    (49) writing -> . WRITELN LPAREN id_text_l TEXT id_text_r RPAREN SEMICOLON
    (50) writing -> . WRITELN LPAREN id_num RPAREN SEMICOLON
    (51) writing -> . READLN LPAREN ID RPAREN SEMICOLON
    (52) writing -> . READLN LPAREN RPAREN SEMICOLON
    (53) writing -> . READLN SEMICOLON
    (54) writing -> . WRITELN SEMICOLON
    (60) cycles -> . type_cycle
    (61) type_cycle -> . while
    (62) type_cycle -> . if
    (63) type_cycle -> . for
    (64) type_cycle -> . cycles instruction
    (65) while -> . WHILE internexpression op_cycle DO otherBegin
    (66) if -> . IF internexpression op_cycle THEN otherBegin_if
    (67) if -> . IF internexpression op_cycle THEN instruction_one_line
    (68) if -> . IF internexpression op_cycle THEN otherBegin_if ELSE otherBegin
    (69) if -> . IF internexpression op_cycle THEN otherBegin_if ELSE instruction_one_line
    (70) if -> . IF internexpression op_cycle THEN instruction_one_line ELSE otherBegin
    (71) if -> . IF internexpression op_cycle THEN instruction_one_line ELSE instruction_one_line
    (72) for -> . FOR asignation_for TO id_num DO otherBegin
    (73) for -> . FOR asignation_for DOWNTO id_num DO otherBegin

    BEGIN           shift and go to state 203
    ID              shift and go to state 206
    WRITELN         shift and go to state 23
    READLN          shift and go to state 29
    WHILE           shift and go to state 17
    IF              shift and go to state 25
    FOR             shift and go to state 22

    cycles                         shift and go to state 209
    for                            shift and go to state 26
    while                          shift and go to state 31
    asignation                     shift and go to state 207
    type_cycle                     shift and go to state 30
    instruction_one_line           shift and go to state 205
    otherBegin_if                  shift and go to state 208
    writing                        shift and go to state 204
    if                             shift and go to state 20

state 173

    (52) writing -> READLN LPAREN RPAREN SEMICOLON .

    ID              reduce using rule 52 (writing -> READLN LPAREN RPAREN SEMICOLON .)
    WRITELN         reduce using rule 52 (writing -> READLN LPAREN RPAREN SEMICOLON .)
    READLN          reduce using rule 52 (writing -> READLN LPAREN RPAREN SEMICOLON .)
    WHILE           reduce using rule 52 (writing -> READLN LPAREN RPAREN SEMICOLON .)
    IF              reduce using rule 52 (writing -> READLN LPAREN RPAREN SEMICOLON .)
    FOR             reduce using rule 52 (writing -> READLN LPAREN RPAREN SEMICOLON .)
    END             reduce using rule 52 (writing -> READLN LPAREN RPAREN SEMICOLON .)
    ELSE            reduce using rule 52 (writing -> READLN LPAREN RPAREN SEMICOLON .)
    PROGRAM         reduce using rule 52 (writing -> READLN LPAREN RPAREN SEMICOLON .)
    USES            reduce using rule 52 (writing -> READLN LPAREN RPAREN SEMICOLON .)
    VAR             reduce using rule 52 (writing -> READLN LPAREN RPAREN SEMICOLON .)
    FUNCTION        reduce using rule 52 (writing -> READLN LPAREN RPAREN SEMICOLON .)
    PROCEDURE       reduce using rule 52 (writing -> READLN LPAREN RPAREN SEMICOLON .)
    BEGIN           reduce using rule 52 (writing -> READLN LPAREN RPAREN SEMICOLON .)
    $end            reduce using rule 52 (writing -> READLN LPAREN RPAREN SEMICOLON .)


state 174

    (51) writing -> READLN LPAREN ID RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 210


state 175

    (26) type_specifier -> REAL .

    SEMICOLON       reduce using rule 26 (type_specifier -> REAL .)
    ID              reduce using rule 26 (type_specifier -> REAL .)
    RPAREN          reduce using rule 26 (type_specifier -> REAL .)


state 176

    (13) var_declaration_2 -> ID var_declaration_3 COLON type_specifier . SEMICOLON var_declaration_4

    SEMICOLON       shift and go to state 211


state 177

    (29) type_specifier -> DOUBLE .

    SEMICOLON       reduce using rule 29 (type_specifier -> DOUBLE .)
    ID              reduce using rule 29 (type_specifier -> DOUBLE .)
    RPAREN          reduce using rule 29 (type_specifier -> DOUBLE .)


state 178

    (27) type_specifier -> CHAR .

    SEMICOLON       reduce using rule 27 (type_specifier -> CHAR .)
    ID              reduce using rule 27 (type_specifier -> CHAR .)
    RPAREN          reduce using rule 27 (type_specifier -> CHAR .)


state 179

    (28) type_specifier -> BOOLEAN .

    SEMICOLON       reduce using rule 28 (type_specifier -> BOOLEAN .)
    ID              reduce using rule 28 (type_specifier -> BOOLEAN .)
    RPAREN          reduce using rule 28 (type_specifier -> BOOLEAN .)


state 180

    (25) type_specifier -> INTEGER .

    SEMICOLON       reduce using rule 25 (type_specifier -> INTEGER .)
    ID              reduce using rule 25 (type_specifier -> INTEGER .)
    RPAREN          reduce using rule 25 (type_specifier -> INTEGER .)


state 181

    (14) var_declaration_3 -> COMMA ID var_declaration_3 .

    COLON           reduce using rule 14 (var_declaration_3 -> COMMA ID var_declaration_3 .)


state 182

    (111) Begin_function -> BEGIN instruction . END SEMICOLON instruction

    END             shift and go to state 212


state 183

    (110) Begin_function -> var_declaration BEGIN . instruction END SEMICOLON instruction
    (31) instruction -> . asignation instruction
    (32) instruction -> . writing instruction
    (33) instruction -> . cycles instruction
    (34) instruction -> . callFunctions instruction
    (35) instruction -> . empty
    (55) asignation -> . ID EQUAL callFunctions SEMICOLON
    (56) asignation -> . ID EQUAL math SEMICOLON
    (57) asignation -> . ID EQUAL boolean SEMICOLON
    (58) asignation -> . ID EQUAL TEXT SEMICOLON
    (49) writing -> . WRITELN LPAREN id_text_l TEXT id_text_r RPAREN SEMICOLON
    (50) writing -> . WRITELN LPAREN id_num RPAREN SEMICOLON
    (51) writing -> . READLN LPAREN ID RPAREN SEMICOLON
    (52) writing -> . READLN LPAREN RPAREN SEMICOLON
    (53) writing -> . READLN SEMICOLON
    (54) writing -> . WRITELN SEMICOLON
    (60) cycles -> . type_cycle
    (36) callFunctions -> . ID LPAREN params RPAREN
    (18) empty -> .
    (61) type_cycle -> . while
    (62) type_cycle -> . if
    (63) type_cycle -> . for
    (64) type_cycle -> . cycles instruction
    (65) while -> . WHILE internexpression op_cycle DO otherBegin
    (66) if -> . IF internexpression op_cycle THEN otherBegin_if
    (67) if -> . IF internexpression op_cycle THEN instruction_one_line
    (68) if -> . IF internexpression op_cycle THEN otherBegin_if ELSE otherBegin
    (69) if -> . IF internexpression op_cycle THEN otherBegin_if ELSE instruction_one_line
    (70) if -> . IF internexpression op_cycle THEN instruction_one_line ELSE otherBegin
    (71) if -> . IF internexpression op_cycle THEN instruction_one_line ELSE instruction_one_line
    (72) for -> . FOR asignation_for TO id_num DO otherBegin
    (73) for -> . FOR asignation_for DOWNTO id_num DO otherBegin

    ID              shift and go to state 24
    WRITELN         shift and go to state 23
    READLN          shift and go to state 29
    END             reduce using rule 18 (empty -> .)
    WHILE           shift and go to state 17
    IF              shift and go to state 25
    FOR             shift and go to state 22

    instruction                    shift and go to state 213
    if                             shift and go to state 20
    for                            shift and go to state 26
    writing                        shift and go to state 18
    callFunctions                  shift and go to state 19
    asignation                     shift and go to state 28
    type_cycle                     shift and go to state 30
    while                          shift and go to state 31
    empty                          shift and go to state 21
    cycles                         shift and go to state 32

state 184

    (113) function_declaration -> PROCEDURE ID LPAREN fun_param RPAREN . SEMICOLON Begin_function

    SEMICOLON       shift and go to state 214


state 185

    (116) fun_param -> SEMICOLON ID fun_param_2 . COLON type_specifier fun_param

    COLON           shift and go to state 215


state 186

    (112) function_declaration -> FUNCTION ID LPAREN fun_param RPAREN COLON . type_specifier SEMICOLON Begin_function
    (25) type_specifier -> . INTEGER
    (26) type_specifier -> . REAL
    (27) type_specifier -> . CHAR
    (28) type_specifier -> . BOOLEAN
    (29) type_specifier -> . DOUBLE

    INTEGER         shift and go to state 180
    REAL            shift and go to state 175
    CHAR            shift and go to state 178
    BOOLEAN         shift and go to state 179
    DOUBLE          shift and go to state 177

    type_specifier                 shift and go to state 216

state 187

    (115) fun_param -> ID fun_param_2 COLON . type_specifier fun_param
    (25) type_specifier -> . INTEGER
    (26) type_specifier -> . REAL
    (27) type_specifier -> . CHAR
    (28) type_specifier -> . BOOLEAN
    (29) type_specifier -> . DOUBLE

    INTEGER         shift and go to state 180
    REAL            shift and go to state 175
    CHAR            shift and go to state 178
    BOOLEAN         shift and go to state 179
    DOUBLE          shift and go to state 177

    type_specifier                 shift and go to state 217

state 188

    (118) fun_param_2 -> COMMA ID . fun_param_2
    (118) fun_param_2 -> . COMMA ID fun_param_2
    (119) fun_param_2 -> . empty
    (18) empty -> .

    COMMA           shift and go to state 140
    COLON           reduce using rule 18 (empty -> .)

    fun_param_2                    shift and go to state 218
    empty                          shift and go to state 141

state 189

    (74) op_cycle -> op_logic internexpression op_cycle .

    DO              reduce using rule 74 (op_cycle -> op_logic internexpression op_cycle .)
    THEN            reduce using rule 74 (op_cycle -> op_logic internexpression op_cycle .)


state 190

    (108) otherBegin -> BEGIN . instruction END SEMICOLON instruction
    (31) instruction -> . asignation instruction
    (32) instruction -> . writing instruction
    (33) instruction -> . cycles instruction
    (34) instruction -> . callFunctions instruction
    (35) instruction -> . empty
    (55) asignation -> . ID EQUAL callFunctions SEMICOLON
    (56) asignation -> . ID EQUAL math SEMICOLON
    (57) asignation -> . ID EQUAL boolean SEMICOLON
    (58) asignation -> . ID EQUAL TEXT SEMICOLON
    (49) writing -> . WRITELN LPAREN id_text_l TEXT id_text_r RPAREN SEMICOLON
    (50) writing -> . WRITELN LPAREN id_num RPAREN SEMICOLON
    (51) writing -> . READLN LPAREN ID RPAREN SEMICOLON
    (52) writing -> . READLN LPAREN RPAREN SEMICOLON
    (53) writing -> . READLN SEMICOLON
    (54) writing -> . WRITELN SEMICOLON
    (60) cycles -> . type_cycle
    (36) callFunctions -> . ID LPAREN params RPAREN
    (18) empty -> .
    (61) type_cycle -> . while
    (62) type_cycle -> . if
    (63) type_cycle -> . for
    (64) type_cycle -> . cycles instruction
    (65) while -> . WHILE internexpression op_cycle DO otherBegin
    (66) if -> . IF internexpression op_cycle THEN otherBegin_if
    (67) if -> . IF internexpression op_cycle THEN instruction_one_line
    (68) if -> . IF internexpression op_cycle THEN otherBegin_if ELSE otherBegin
    (69) if -> . IF internexpression op_cycle THEN otherBegin_if ELSE instruction_one_line
    (70) if -> . IF internexpression op_cycle THEN instruction_one_line ELSE otherBegin
    (71) if -> . IF internexpression op_cycle THEN instruction_one_line ELSE instruction_one_line
    (72) for -> . FOR asignation_for TO id_num DO otherBegin
    (73) for -> . FOR asignation_for DOWNTO id_num DO otherBegin

    ID              shift and go to state 24
    WRITELN         shift and go to state 23
    READLN          shift and go to state 29
    END             reduce using rule 18 (empty -> .)
    WHILE           shift and go to state 17
    IF              shift and go to state 25
    FOR             shift and go to state 22

    instruction                    shift and go to state 219
    if                             shift and go to state 20
    for                            shift and go to state 26
    writing                        shift and go to state 18
    callFunctions                  shift and go to state 19
    asignation                     shift and go to state 28
    type_cycle                     shift and go to state 30
    while                          shift and go to state 31
    empty                          shift and go to state 21
    cycles                         shift and go to state 32

state 191

    (65) while -> WHILE internexpression op_cycle DO otherBegin .

    END             reduce using rule 65 (while -> WHILE internexpression op_cycle DO otherBegin .)
    ID              reduce using rule 65 (while -> WHILE internexpression op_cycle DO otherBegin .)
    WRITELN         reduce using rule 65 (while -> WHILE internexpression op_cycle DO otherBegin .)
    READLN          reduce using rule 65 (while -> WHILE internexpression op_cycle DO otherBegin .)
    WHILE           reduce using rule 65 (while -> WHILE internexpression op_cycle DO otherBegin .)
    IF              reduce using rule 65 (while -> WHILE internexpression op_cycle DO otherBegin .)
    FOR             reduce using rule 65 (while -> WHILE internexpression op_cycle DO otherBegin .)
    ELSE            reduce using rule 65 (while -> WHILE internexpression op_cycle DO otherBegin .)
    PROGRAM         reduce using rule 65 (while -> WHILE internexpression op_cycle DO otherBegin .)
    USES            reduce using rule 65 (while -> WHILE internexpression op_cycle DO otherBegin .)
    VAR             reduce using rule 65 (while -> WHILE internexpression op_cycle DO otherBegin .)
    FUNCTION        reduce using rule 65 (while -> WHILE internexpression op_cycle DO otherBegin .)
    PROCEDURE       reduce using rule 65 (while -> WHILE internexpression op_cycle DO otherBegin .)
    BEGIN           reduce using rule 65 (while -> WHILE internexpression op_cycle DO otherBegin .)
    $end            reduce using rule 65 (while -> WHILE internexpression op_cycle DO otherBegin .)


state 192

    (20) mathi -> type_op_math factor mathi .

    ISEQUAL         reduce using rule 20 (mathi -> type_op_math factor mathi .)
    LESSEQUAL       reduce using rule 20 (mathi -> type_op_math factor mathi .)
    LESS            reduce using rule 20 (mathi -> type_op_math factor mathi .)
    GREATER         reduce using rule 20 (mathi -> type_op_math factor mathi .)
    GREATEREQUAL    reduce using rule 20 (mathi -> type_op_math factor mathi .)
    DEQUAL          reduce using rule 20 (mathi -> type_op_math factor mathi .)
    RPAREN          reduce using rule 20 (mathi -> type_op_math factor mathi .)
    COMMA           reduce using rule 20 (mathi -> type_op_math factor mathi .)
    SEMICOLON       reduce using rule 20 (mathi -> type_op_math factor mathi .)
    AND             reduce using rule 20 (mathi -> type_op_math factor mathi .)
    OR              reduce using rule 20 (mathi -> type_op_math factor mathi .)
    XOR             reduce using rule 20 (mathi -> type_op_math factor mathi .)
    NOT             reduce using rule 20 (mathi -> type_op_math factor mathi .)
    DO              reduce using rule 20 (mathi -> type_op_math factor mathi .)
    THEN            reduce using rule 20 (mathi -> type_op_math factor mathi .)


state 193

    (73) for -> FOR asignation_for DOWNTO id_num DO . otherBegin
    (108) otherBegin -> . BEGIN instruction END SEMICOLON instruction

    BEGIN           shift and go to state 190

    otherBegin                     shift and go to state 220

state 194

    (72) for -> FOR asignation_for TO id_num DO . otherBegin
    (108) otherBegin -> . BEGIN instruction END SEMICOLON instruction

    BEGIN           shift and go to state 190

    otherBegin                     shift and go to state 221

state 195

    (43) id_text_l -> callFunctions COMMA id_text_l .

    TEXT            reduce using rule 43 (id_text_l -> callFunctions COMMA id_text_l .)


state 196

    (44) id_text_l -> ID . COMMA id_text_l
    (36) callFunctions -> ID . LPAREN params RPAREN

    COMMA           shift and go to state 163
    LPAREN          shift and go to state 62


state 197

    (46) id_text_r -> COMMA . callFunctions id_text_r
    (47) id_text_r -> COMMA . ID id_text_r
    (36) callFunctions -> . ID LPAREN params RPAREN

    ID              shift and go to state 223

    callFunctions                  shift and go to state 222

state 198

    (49) writing -> WRITELN LPAREN id_text_l TEXT id_text_r . RPAREN SEMICOLON

    RPAREN          shift and go to state 224


state 199

    (48) id_text_r -> empty .

    RPAREN          reduce using rule 48 (id_text_r -> empty .)


state 200

    (50) writing -> WRITELN LPAREN id_num RPAREN SEMICOLON .

    ID              reduce using rule 50 (writing -> WRITELN LPAREN id_num RPAREN SEMICOLON .)
    WRITELN         reduce using rule 50 (writing -> WRITELN LPAREN id_num RPAREN SEMICOLON .)
    READLN          reduce using rule 50 (writing -> WRITELN LPAREN id_num RPAREN SEMICOLON .)
    WHILE           reduce using rule 50 (writing -> WRITELN LPAREN id_num RPAREN SEMICOLON .)
    IF              reduce using rule 50 (writing -> WRITELN LPAREN id_num RPAREN SEMICOLON .)
    FOR             reduce using rule 50 (writing -> WRITELN LPAREN id_num RPAREN SEMICOLON .)
    END             reduce using rule 50 (writing -> WRITELN LPAREN id_num RPAREN SEMICOLON .)
    ELSE            reduce using rule 50 (writing -> WRITELN LPAREN id_num RPAREN SEMICOLON .)
    PROGRAM         reduce using rule 50 (writing -> WRITELN LPAREN id_num RPAREN SEMICOLON .)
    USES            reduce using rule 50 (writing -> WRITELN LPAREN id_num RPAREN SEMICOLON .)
    VAR             reduce using rule 50 (writing -> WRITELN LPAREN id_num RPAREN SEMICOLON .)
    FUNCTION        reduce using rule 50 (writing -> WRITELN LPAREN id_num RPAREN SEMICOLON .)
    PROCEDURE       reduce using rule 50 (writing -> WRITELN LPAREN id_num RPAREN SEMICOLON .)
    BEGIN           reduce using rule 50 (writing -> WRITELN LPAREN id_num RPAREN SEMICOLON .)
    $end            reduce using rule 50 (writing -> WRITELN LPAREN id_num RPAREN SEMICOLON .)


state 201

    (44) id_text_l -> ID COMMA id_text_l .

    TEXT            reduce using rule 44 (id_text_l -> ID COMMA id_text_l .)


state 202

    (38) params2 -> COMMA math .

    RPAREN          reduce using rule 38 (params2 -> COMMA math .)


state 203

    (109) otherBegin_if -> BEGIN . instruction END instruction
    (31) instruction -> . asignation instruction
    (32) instruction -> . writing instruction
    (33) instruction -> . cycles instruction
    (34) instruction -> . callFunctions instruction
    (35) instruction -> . empty
    (55) asignation -> . ID EQUAL callFunctions SEMICOLON
    (56) asignation -> . ID EQUAL math SEMICOLON
    (57) asignation -> . ID EQUAL boolean SEMICOLON
    (58) asignation -> . ID EQUAL TEXT SEMICOLON
    (49) writing -> . WRITELN LPAREN id_text_l TEXT id_text_r RPAREN SEMICOLON
    (50) writing -> . WRITELN LPAREN id_num RPAREN SEMICOLON
    (51) writing -> . READLN LPAREN ID RPAREN SEMICOLON
    (52) writing -> . READLN LPAREN RPAREN SEMICOLON
    (53) writing -> . READLN SEMICOLON
    (54) writing -> . WRITELN SEMICOLON
    (60) cycles -> . type_cycle
    (36) callFunctions -> . ID LPAREN params RPAREN
    (18) empty -> .
    (61) type_cycle -> . while
    (62) type_cycle -> . if
    (63) type_cycle -> . for
    (64) type_cycle -> . cycles instruction
    (65) while -> . WHILE internexpression op_cycle DO otherBegin
    (66) if -> . IF internexpression op_cycle THEN otherBegin_if
    (67) if -> . IF internexpression op_cycle THEN instruction_one_line
    (68) if -> . IF internexpression op_cycle THEN otherBegin_if ELSE otherBegin
    (69) if -> . IF internexpression op_cycle THEN otherBegin_if ELSE instruction_one_line
    (70) if -> . IF internexpression op_cycle THEN instruction_one_line ELSE otherBegin
    (71) if -> . IF internexpression op_cycle THEN instruction_one_line ELSE instruction_one_line
    (72) for -> . FOR asignation_for TO id_num DO otherBegin
    (73) for -> . FOR asignation_for DOWNTO id_num DO otherBegin

    ID              shift and go to state 24
    WRITELN         shift and go to state 23
    READLN          shift and go to state 29
    END             reduce using rule 18 (empty -> .)
    WHILE           shift and go to state 17
    IF              shift and go to state 25
    FOR             shift and go to state 22

    instruction                    shift and go to state 225
    if                             shift and go to state 20
    for                            shift and go to state 26
    writing                        shift and go to state 18
    callFunctions                  shift and go to state 19
    asignation                     shift and go to state 28
    type_cycle                     shift and go to state 30
    while                          shift and go to state 31
    empty                          shift and go to state 21
    cycles                         shift and go to state 32

state 204

    (41) instruction_one_line -> writing .

    END             reduce using rule 41 (instruction_one_line -> writing .)
    ID              reduce using rule 41 (instruction_one_line -> writing .)
    WRITELN         reduce using rule 41 (instruction_one_line -> writing .)
    READLN          reduce using rule 41 (instruction_one_line -> writing .)
    WHILE           reduce using rule 41 (instruction_one_line -> writing .)
    IF              reduce using rule 41 (instruction_one_line -> writing .)
    FOR             reduce using rule 41 (instruction_one_line -> writing .)
    ELSE            reduce using rule 41 (instruction_one_line -> writing .)
    PROGRAM         reduce using rule 41 (instruction_one_line -> writing .)
    USES            reduce using rule 41 (instruction_one_line -> writing .)
    VAR             reduce using rule 41 (instruction_one_line -> writing .)
    FUNCTION        reduce using rule 41 (instruction_one_line -> writing .)
    PROCEDURE       reduce using rule 41 (instruction_one_line -> writing .)
    BEGIN           reduce using rule 41 (instruction_one_line -> writing .)
    $end            reduce using rule 41 (instruction_one_line -> writing .)


state 205

    (67) if -> IF internexpression op_cycle THEN instruction_one_line .
    (70) if -> IF internexpression op_cycle THEN instruction_one_line . ELSE otherBegin
    (71) if -> IF internexpression op_cycle THEN instruction_one_line . ELSE instruction_one_line

  ! shift/reduce conflict for ELSE resolved as shift
    ID              reduce using rule 67 (if -> IF internexpression op_cycle THEN instruction_one_line .)
    WRITELN         reduce using rule 67 (if -> IF internexpression op_cycle THEN instruction_one_line .)
    READLN          reduce using rule 67 (if -> IF internexpression op_cycle THEN instruction_one_line .)
    WHILE           reduce using rule 67 (if -> IF internexpression op_cycle THEN instruction_one_line .)
    IF              reduce using rule 67 (if -> IF internexpression op_cycle THEN instruction_one_line .)
    FOR             reduce using rule 67 (if -> IF internexpression op_cycle THEN instruction_one_line .)
    END             reduce using rule 67 (if -> IF internexpression op_cycle THEN instruction_one_line .)
    PROGRAM         reduce using rule 67 (if -> IF internexpression op_cycle THEN instruction_one_line .)
    USES            reduce using rule 67 (if -> IF internexpression op_cycle THEN instruction_one_line .)
    VAR             reduce using rule 67 (if -> IF internexpression op_cycle THEN instruction_one_line .)
    FUNCTION        reduce using rule 67 (if -> IF internexpression op_cycle THEN instruction_one_line .)
    PROCEDURE       reduce using rule 67 (if -> IF internexpression op_cycle THEN instruction_one_line .)
    BEGIN           reduce using rule 67 (if -> IF internexpression op_cycle THEN instruction_one_line .)
    $end            reduce using rule 67 (if -> IF internexpression op_cycle THEN instruction_one_line .)
    ELSE            shift and go to state 226

  ! ELSE            [ reduce using rule 67 (if -> IF internexpression op_cycle THEN instruction_one_line .) ]


state 206

    (55) asignation -> ID . EQUAL callFunctions SEMICOLON
    (56) asignation -> ID . EQUAL math SEMICOLON
    (57) asignation -> ID . EQUAL boolean SEMICOLON
    (58) asignation -> ID . EQUAL TEXT SEMICOLON

    EQUAL           shift and go to state 63


state 207

    (40) instruction_one_line -> asignation .

    END             reduce using rule 40 (instruction_one_line -> asignation .)
    ID              reduce using rule 40 (instruction_one_line -> asignation .)
    WRITELN         reduce using rule 40 (instruction_one_line -> asignation .)
    READLN          reduce using rule 40 (instruction_one_line -> asignation .)
    WHILE           reduce using rule 40 (instruction_one_line -> asignation .)
    IF              reduce using rule 40 (instruction_one_line -> asignation .)
    FOR             reduce using rule 40 (instruction_one_line -> asignation .)
    ELSE            reduce using rule 40 (instruction_one_line -> asignation .)
    PROGRAM         reduce using rule 40 (instruction_one_line -> asignation .)
    USES            reduce using rule 40 (instruction_one_line -> asignation .)
    VAR             reduce using rule 40 (instruction_one_line -> asignation .)
    FUNCTION        reduce using rule 40 (instruction_one_line -> asignation .)
    PROCEDURE       reduce using rule 40 (instruction_one_line -> asignation .)
    BEGIN           reduce using rule 40 (instruction_one_line -> asignation .)
    $end            reduce using rule 40 (instruction_one_line -> asignation .)


state 208

    (66) if -> IF internexpression op_cycle THEN otherBegin_if .
    (68) if -> IF internexpression op_cycle THEN otherBegin_if . ELSE otherBegin
    (69) if -> IF internexpression op_cycle THEN otherBegin_if . ELSE instruction_one_line

  ! shift/reduce conflict for ELSE resolved as shift
    ID              reduce using rule 66 (if -> IF internexpression op_cycle THEN otherBegin_if .)
    WRITELN         reduce using rule 66 (if -> IF internexpression op_cycle THEN otherBegin_if .)
    READLN          reduce using rule 66 (if -> IF internexpression op_cycle THEN otherBegin_if .)
    WHILE           reduce using rule 66 (if -> IF internexpression op_cycle THEN otherBegin_if .)
    IF              reduce using rule 66 (if -> IF internexpression op_cycle THEN otherBegin_if .)
    FOR             reduce using rule 66 (if -> IF internexpression op_cycle THEN otherBegin_if .)
    END             reduce using rule 66 (if -> IF internexpression op_cycle THEN otherBegin_if .)
    PROGRAM         reduce using rule 66 (if -> IF internexpression op_cycle THEN otherBegin_if .)
    USES            reduce using rule 66 (if -> IF internexpression op_cycle THEN otherBegin_if .)
    VAR             reduce using rule 66 (if -> IF internexpression op_cycle THEN otherBegin_if .)
    FUNCTION        reduce using rule 66 (if -> IF internexpression op_cycle THEN otherBegin_if .)
    PROCEDURE       reduce using rule 66 (if -> IF internexpression op_cycle THEN otherBegin_if .)
    BEGIN           reduce using rule 66 (if -> IF internexpression op_cycle THEN otherBegin_if .)
    $end            reduce using rule 66 (if -> IF internexpression op_cycle THEN otherBegin_if .)
    ELSE            shift and go to state 227

  ! ELSE            [ reduce using rule 66 (if -> IF internexpression op_cycle THEN otherBegin_if .) ]


state 209

    (42) instruction_one_line -> cycles .
    (64) type_cycle -> cycles . instruction
    (31) instruction -> . asignation instruction
    (32) instruction -> . writing instruction
    (33) instruction -> . cycles instruction
    (34) instruction -> . callFunctions instruction
    (35) instruction -> . empty
    (55) asignation -> . ID EQUAL callFunctions SEMICOLON
    (56) asignation -> . ID EQUAL math SEMICOLON
    (57) asignation -> . ID EQUAL boolean SEMICOLON
    (58) asignation -> . ID EQUAL TEXT SEMICOLON
    (49) writing -> . WRITELN LPAREN id_text_l TEXT id_text_r RPAREN SEMICOLON
    (50) writing -> . WRITELN LPAREN id_num RPAREN SEMICOLON
    (51) writing -> . READLN LPAREN ID RPAREN SEMICOLON
    (52) writing -> . READLN LPAREN RPAREN SEMICOLON
    (53) writing -> . READLN SEMICOLON
    (54) writing -> . WRITELN SEMICOLON
    (60) cycles -> . type_cycle
    (36) callFunctions -> . ID LPAREN params RPAREN
    (18) empty -> .
    (61) type_cycle -> . while
    (62) type_cycle -> . if
    (63) type_cycle -> . for
    (64) type_cycle -> . cycles instruction
    (65) while -> . WHILE internexpression op_cycle DO otherBegin
    (66) if -> . IF internexpression op_cycle THEN otherBegin_if
    (67) if -> . IF internexpression op_cycle THEN instruction_one_line
    (68) if -> . IF internexpression op_cycle THEN otherBegin_if ELSE otherBegin
    (69) if -> . IF internexpression op_cycle THEN otherBegin_if ELSE instruction_one_line
    (70) if -> . IF internexpression op_cycle THEN instruction_one_line ELSE otherBegin
    (71) if -> . IF internexpression op_cycle THEN instruction_one_line ELSE instruction_one_line
    (72) for -> . FOR asignation_for TO id_num DO otherBegin
    (73) for -> . FOR asignation_for DOWNTO id_num DO otherBegin

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WRITELN resolved as shift
  ! shift/reduce conflict for READLN resolved as shift
  ! reduce/reduce conflict for END resolved using rule 18 (empty -> .)
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WRITELN resolved as shift
  ! shift/reduce conflict for READLN resolved as shift
  ! reduce/reduce conflict for WHILE resolved using rule 18 (empty -> .)
  ! reduce/reduce conflict for IF resolved using rule 18 (empty -> .)
  ! reduce/reduce conflict for FOR resolved using rule 18 (empty -> .)
  ! reduce/reduce conflict for ELSE resolved using rule 18 (empty -> .)
  ! reduce/reduce conflict for PROGRAM resolved using rule 18 (empty -> .)
  ! reduce/reduce conflict for USES resolved using rule 18 (empty -> .)
  ! reduce/reduce conflict for VAR resolved using rule 18 (empty -> .)
  ! reduce/reduce conflict for FUNCTION resolved using rule 18 (empty -> .)
  ! reduce/reduce conflict for PROCEDURE resolved using rule 18 (empty -> .)
  ! reduce/reduce conflict for BEGIN resolved using rule 18 (empty -> .)
  ! reduce/reduce conflict for $end resolved using rule 18 (empty -> .)
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
    ID              shift and go to state 24
    WRITELN         shift and go to state 23
    READLN          shift and go to state 29
    END             reduce using rule 18 (empty -> .)
    ELSE            reduce using rule 18 (empty -> .)
    PROGRAM         reduce using rule 18 (empty -> .)
    USES            reduce using rule 18 (empty -> .)
    VAR             reduce using rule 18 (empty -> .)
    FUNCTION        reduce using rule 18 (empty -> .)
    PROCEDURE       reduce using rule 18 (empty -> .)
    BEGIN           reduce using rule 18 (empty -> .)
    $end            reduce using rule 18 (empty -> .)
    WHILE           shift and go to state 17
    IF              shift and go to state 25
    FOR             shift and go to state 22

  ! END             [ reduce using rule 42 (instruction_one_line -> cycles .) ]
  ! ID              [ reduce using rule 42 (instruction_one_line -> cycles .) ]
  ! WRITELN         [ reduce using rule 42 (instruction_one_line -> cycles .) ]
  ! READLN          [ reduce using rule 42 (instruction_one_line -> cycles .) ]
  ! WHILE           [ reduce using rule 42 (instruction_one_line -> cycles .) ]
  ! IF              [ reduce using rule 42 (instruction_one_line -> cycles .) ]
  ! FOR             [ reduce using rule 42 (instruction_one_line -> cycles .) ]
  ! ELSE            [ reduce using rule 42 (instruction_one_line -> cycles .) ]
  ! PROGRAM         [ reduce using rule 42 (instruction_one_line -> cycles .) ]
  ! USES            [ reduce using rule 42 (instruction_one_line -> cycles .) ]
  ! VAR             [ reduce using rule 42 (instruction_one_line -> cycles .) ]
  ! FUNCTION        [ reduce using rule 42 (instruction_one_line -> cycles .) ]
  ! PROCEDURE       [ reduce using rule 42 (instruction_one_line -> cycles .) ]
  ! BEGIN           [ reduce using rule 42 (instruction_one_line -> cycles .) ]
  ! $end            [ reduce using rule 42 (instruction_one_line -> cycles .) ]
  ! ID              [ reduce using rule 18 (empty -> .) ]
  ! WRITELN         [ reduce using rule 18 (empty -> .) ]
  ! READLN          [ reduce using rule 18 (empty -> .) ]
  ! WHILE           [ reduce using rule 18 (empty -> .) ]
  ! IF              [ reduce using rule 18 (empty -> .) ]
  ! FOR             [ reduce using rule 18 (empty -> .) ]

    instruction                    shift and go to state 228
    if                             shift and go to state 20
    for                            shift and go to state 26
    writing                        shift and go to state 18
    callFunctions                  shift and go to state 19
    asignation                     shift and go to state 28
    type_cycle                     shift and go to state 30
    while                          shift and go to state 31
    empty                          shift and go to state 21
    cycles                         shift and go to state 32

state 210

    (51) writing -> READLN LPAREN ID RPAREN SEMICOLON .

    ID              reduce using rule 51 (writing -> READLN LPAREN ID RPAREN SEMICOLON .)
    WRITELN         reduce using rule 51 (writing -> READLN LPAREN ID RPAREN SEMICOLON .)
    READLN          reduce using rule 51 (writing -> READLN LPAREN ID RPAREN SEMICOLON .)
    WHILE           reduce using rule 51 (writing -> READLN LPAREN ID RPAREN SEMICOLON .)
    IF              reduce using rule 51 (writing -> READLN LPAREN ID RPAREN SEMICOLON .)
    FOR             reduce using rule 51 (writing -> READLN LPAREN ID RPAREN SEMICOLON .)
    END             reduce using rule 51 (writing -> READLN LPAREN ID RPAREN SEMICOLON .)
    ELSE            reduce using rule 51 (writing -> READLN LPAREN ID RPAREN SEMICOLON .)
    PROGRAM         reduce using rule 51 (writing -> READLN LPAREN ID RPAREN SEMICOLON .)
    USES            reduce using rule 51 (writing -> READLN LPAREN ID RPAREN SEMICOLON .)
    VAR             reduce using rule 51 (writing -> READLN LPAREN ID RPAREN SEMICOLON .)
    FUNCTION        reduce using rule 51 (writing -> READLN LPAREN ID RPAREN SEMICOLON .)
    PROCEDURE       reduce using rule 51 (writing -> READLN LPAREN ID RPAREN SEMICOLON .)
    BEGIN           reduce using rule 51 (writing -> READLN LPAREN ID RPAREN SEMICOLON .)
    $end            reduce using rule 51 (writing -> READLN LPAREN ID RPAREN SEMICOLON .)


state 211

    (13) var_declaration_2 -> ID var_declaration_3 COLON type_specifier SEMICOLON . var_declaration_4
    (16) var_declaration_4 -> . var_declaration_2
    (17) var_declaration_4 -> . empty
    (13) var_declaration_2 -> . ID var_declaration_3 COLON type_specifier SEMICOLON var_declaration_4
    (18) empty -> .

    ID              shift and go to state 34
    PROGRAM         reduce using rule 18 (empty -> .)
    USES            reduce using rule 18 (empty -> .)
    VAR             reduce using rule 18 (empty -> .)
    FUNCTION        reduce using rule 18 (empty -> .)
    PROCEDURE       reduce using rule 18 (empty -> .)
    BEGIN           reduce using rule 18 (empty -> .)
    $end            reduce using rule 18 (empty -> .)

    var_declaration_4              shift and go to state 229
    var_declaration_2              shift and go to state 230
    empty                          shift and go to state 231

state 212

    (111) Begin_function -> BEGIN instruction END . SEMICOLON instruction

    SEMICOLON       shift and go to state 232


state 213

    (110) Begin_function -> var_declaration BEGIN instruction . END SEMICOLON instruction

    END             shift and go to state 233


state 214

    (113) function_declaration -> PROCEDURE ID LPAREN fun_param RPAREN SEMICOLON . Begin_function
    (110) Begin_function -> . var_declaration BEGIN instruction END SEMICOLON instruction
    (111) Begin_function -> . BEGIN instruction END SEMICOLON instruction
    (12) var_declaration -> . VAR var_declaration_2

    BEGIN           shift and go to state 133
    VAR             shift and go to state 9

    Begin_function                 shift and go to state 234
    var_declaration                shift and go to state 134

state 215

    (116) fun_param -> SEMICOLON ID fun_param_2 COLON . type_specifier fun_param
    (25) type_specifier -> . INTEGER
    (26) type_specifier -> . REAL
    (27) type_specifier -> . CHAR
    (28) type_specifier -> . BOOLEAN
    (29) type_specifier -> . DOUBLE

    INTEGER         shift and go to state 180
    REAL            shift and go to state 175
    CHAR            shift and go to state 178
    BOOLEAN         shift and go to state 179
    DOUBLE          shift and go to state 177

    type_specifier                 shift and go to state 235

state 216

    (112) function_declaration -> FUNCTION ID LPAREN fun_param RPAREN COLON type_specifier . SEMICOLON Begin_function

    SEMICOLON       shift and go to state 236


state 217

    (115) fun_param -> ID fun_param_2 COLON type_specifier . fun_param
    (115) fun_param -> . ID fun_param_2 COLON type_specifier fun_param
    (116) fun_param -> . SEMICOLON ID fun_param_2 COLON type_specifier fun_param
    (117) fun_param -> . empty
    (18) empty -> .

    ID              shift and go to state 77
    SEMICOLON       shift and go to state 75
    RPAREN          reduce using rule 18 (empty -> .)

    fun_param                      shift and go to state 237
    empty                          shift and go to state 78

state 218

    (118) fun_param_2 -> COMMA ID fun_param_2 .

    COLON           reduce using rule 118 (fun_param_2 -> COMMA ID fun_param_2 .)


state 219

    (108) otherBegin -> BEGIN instruction . END SEMICOLON instruction

    END             shift and go to state 238


state 220

    (73) for -> FOR asignation_for DOWNTO id_num DO otherBegin .

    END             reduce using rule 73 (for -> FOR asignation_for DOWNTO id_num DO otherBegin .)
    ID              reduce using rule 73 (for -> FOR asignation_for DOWNTO id_num DO otherBegin .)
    WRITELN         reduce using rule 73 (for -> FOR asignation_for DOWNTO id_num DO otherBegin .)
    READLN          reduce using rule 73 (for -> FOR asignation_for DOWNTO id_num DO otherBegin .)
    WHILE           reduce using rule 73 (for -> FOR asignation_for DOWNTO id_num DO otherBegin .)
    IF              reduce using rule 73 (for -> FOR asignation_for DOWNTO id_num DO otherBegin .)
    FOR             reduce using rule 73 (for -> FOR asignation_for DOWNTO id_num DO otherBegin .)
    ELSE            reduce using rule 73 (for -> FOR asignation_for DOWNTO id_num DO otherBegin .)
    PROGRAM         reduce using rule 73 (for -> FOR asignation_for DOWNTO id_num DO otherBegin .)
    USES            reduce using rule 73 (for -> FOR asignation_for DOWNTO id_num DO otherBegin .)
    VAR             reduce using rule 73 (for -> FOR asignation_for DOWNTO id_num DO otherBegin .)
    FUNCTION        reduce using rule 73 (for -> FOR asignation_for DOWNTO id_num DO otherBegin .)
    PROCEDURE       reduce using rule 73 (for -> FOR asignation_for DOWNTO id_num DO otherBegin .)
    BEGIN           reduce using rule 73 (for -> FOR asignation_for DOWNTO id_num DO otherBegin .)
    $end            reduce using rule 73 (for -> FOR asignation_for DOWNTO id_num DO otherBegin .)


state 221

    (72) for -> FOR asignation_for TO id_num DO otherBegin .

    END             reduce using rule 72 (for -> FOR asignation_for TO id_num DO otherBegin .)
    ID              reduce using rule 72 (for -> FOR asignation_for TO id_num DO otherBegin .)
    WRITELN         reduce using rule 72 (for -> FOR asignation_for TO id_num DO otherBegin .)
    READLN          reduce using rule 72 (for -> FOR asignation_for TO id_num DO otherBegin .)
    WHILE           reduce using rule 72 (for -> FOR asignation_for TO id_num DO otherBegin .)
    IF              reduce using rule 72 (for -> FOR asignation_for TO id_num DO otherBegin .)
    FOR             reduce using rule 72 (for -> FOR asignation_for TO id_num DO otherBegin .)
    ELSE            reduce using rule 72 (for -> FOR asignation_for TO id_num DO otherBegin .)
    PROGRAM         reduce using rule 72 (for -> FOR asignation_for TO id_num DO otherBegin .)
    USES            reduce using rule 72 (for -> FOR asignation_for TO id_num DO otherBegin .)
    VAR             reduce using rule 72 (for -> FOR asignation_for TO id_num DO otherBegin .)
    FUNCTION        reduce using rule 72 (for -> FOR asignation_for TO id_num DO otherBegin .)
    PROCEDURE       reduce using rule 72 (for -> FOR asignation_for TO id_num DO otherBegin .)
    BEGIN           reduce using rule 72 (for -> FOR asignation_for TO id_num DO otherBegin .)
    $end            reduce using rule 72 (for -> FOR asignation_for TO id_num DO otherBegin .)


state 222

    (46) id_text_r -> COMMA callFunctions . id_text_r
    (46) id_text_r -> . COMMA callFunctions id_text_r
    (47) id_text_r -> . COMMA ID id_text_r
    (48) id_text_r -> . empty
    (18) empty -> .

    COMMA           shift and go to state 197
    RPAREN          reduce using rule 18 (empty -> .)

    empty                          shift and go to state 199
    id_text_r                      shift and go to state 239

state 223

    (47) id_text_r -> COMMA ID . id_text_r
    (36) callFunctions -> ID . LPAREN params RPAREN
    (46) id_text_r -> . COMMA callFunctions id_text_r
    (47) id_text_r -> . COMMA ID id_text_r
    (48) id_text_r -> . empty
    (18) empty -> .

    LPAREN          shift and go to state 62
    COMMA           shift and go to state 197
    RPAREN          reduce using rule 18 (empty -> .)

    empty                          shift and go to state 199
    id_text_r                      shift and go to state 240

state 224

    (49) writing -> WRITELN LPAREN id_text_l TEXT id_text_r RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 241


state 225

    (109) otherBegin_if -> BEGIN instruction . END instruction

    END             shift and go to state 242


state 226

    (70) if -> IF internexpression op_cycle THEN instruction_one_line ELSE . otherBegin
    (71) if -> IF internexpression op_cycle THEN instruction_one_line ELSE . instruction_one_line
    (108) otherBegin -> . BEGIN instruction END SEMICOLON instruction
    (40) instruction_one_line -> . asignation
    (41) instruction_one_line -> . writing
    (42) instruction_one_line -> . cycles
    (55) asignation -> . ID EQUAL callFunctions SEMICOLON
    (56) asignation -> . ID EQUAL math SEMICOLON
    (57) asignation -> . ID EQUAL boolean SEMICOLON
    (58) asignation -> . ID EQUAL TEXT SEMICOLON
    (49) writing -> . WRITELN LPAREN id_text_l TEXT id_text_r RPAREN SEMICOLON
    (50) writing -> . WRITELN LPAREN id_num RPAREN SEMICOLON
    (51) writing -> . READLN LPAREN ID RPAREN SEMICOLON
    (52) writing -> . READLN LPAREN RPAREN SEMICOLON
    (53) writing -> . READLN SEMICOLON
    (54) writing -> . WRITELN SEMICOLON
    (60) cycles -> . type_cycle
    (61) type_cycle -> . while
    (62) type_cycle -> . if
    (63) type_cycle -> . for
    (64) type_cycle -> . cycles instruction
    (65) while -> . WHILE internexpression op_cycle DO otherBegin
    (66) if -> . IF internexpression op_cycle THEN otherBegin_if
    (67) if -> . IF internexpression op_cycle THEN instruction_one_line
    (68) if -> . IF internexpression op_cycle THEN otherBegin_if ELSE otherBegin
    (69) if -> . IF internexpression op_cycle THEN otherBegin_if ELSE instruction_one_line
    (70) if -> . IF internexpression op_cycle THEN instruction_one_line ELSE otherBegin
    (71) if -> . IF internexpression op_cycle THEN instruction_one_line ELSE instruction_one_line
    (72) for -> . FOR asignation_for TO id_num DO otherBegin
    (73) for -> . FOR asignation_for DOWNTO id_num DO otherBegin

    BEGIN           shift and go to state 190
    ID              shift and go to state 206
    WRITELN         shift and go to state 23
    READLN          shift and go to state 29
    WHILE           shift and go to state 17
    IF              shift and go to state 25
    FOR             shift and go to state 22

    cycles                         shift and go to state 209
    for                            shift and go to state 26
    while                          shift and go to state 31
    asignation                     shift and go to state 207
    type_cycle                     shift and go to state 30
    instruction_one_line           shift and go to state 243
    otherBegin                     shift and go to state 244
    writing                        shift and go to state 204
    if                             shift and go to state 20

state 227

    (68) if -> IF internexpression op_cycle THEN otherBegin_if ELSE . otherBegin
    (69) if -> IF internexpression op_cycle THEN otherBegin_if ELSE . instruction_one_line
    (108) otherBegin -> . BEGIN instruction END SEMICOLON instruction
    (40) instruction_one_line -> . asignation
    (41) instruction_one_line -> . writing
    (42) instruction_one_line -> . cycles
    (55) asignation -> . ID EQUAL callFunctions SEMICOLON
    (56) asignation -> . ID EQUAL math SEMICOLON
    (57) asignation -> . ID EQUAL boolean SEMICOLON
    (58) asignation -> . ID EQUAL TEXT SEMICOLON
    (49) writing -> . WRITELN LPAREN id_text_l TEXT id_text_r RPAREN SEMICOLON
    (50) writing -> . WRITELN LPAREN id_num RPAREN SEMICOLON
    (51) writing -> . READLN LPAREN ID RPAREN SEMICOLON
    (52) writing -> . READLN LPAREN RPAREN SEMICOLON
    (53) writing -> . READLN SEMICOLON
    (54) writing -> . WRITELN SEMICOLON
    (60) cycles -> . type_cycle
    (61) type_cycle -> . while
    (62) type_cycle -> . if
    (63) type_cycle -> . for
    (64) type_cycle -> . cycles instruction
    (65) while -> . WHILE internexpression op_cycle DO otherBegin
    (66) if -> . IF internexpression op_cycle THEN otherBegin_if
    (67) if -> . IF internexpression op_cycle THEN instruction_one_line
    (68) if -> . IF internexpression op_cycle THEN otherBegin_if ELSE otherBegin
    (69) if -> . IF internexpression op_cycle THEN otherBegin_if ELSE instruction_one_line
    (70) if -> . IF internexpression op_cycle THEN instruction_one_line ELSE otherBegin
    (71) if -> . IF internexpression op_cycle THEN instruction_one_line ELSE instruction_one_line
    (72) for -> . FOR asignation_for TO id_num DO otherBegin
    (73) for -> . FOR asignation_for DOWNTO id_num DO otherBegin

    BEGIN           shift and go to state 190
    ID              shift and go to state 206
    WRITELN         shift and go to state 23
    READLN          shift and go to state 29
    WHILE           shift and go to state 17
    IF              shift and go to state 25
    FOR             shift and go to state 22

    cycles                         shift and go to state 209
    for                            shift and go to state 26
    while                          shift and go to state 31
    asignation                     shift and go to state 207
    type_cycle                     shift and go to state 30
    instruction_one_line           shift and go to state 245
    otherBegin                     shift and go to state 246
    writing                        shift and go to state 204
    if                             shift and go to state 20

state 228

    (64) type_cycle -> cycles instruction .

    END             reduce using rule 64 (type_cycle -> cycles instruction .)
    ID              reduce using rule 64 (type_cycle -> cycles instruction .)
    WRITELN         reduce using rule 64 (type_cycle -> cycles instruction .)
    READLN          reduce using rule 64 (type_cycle -> cycles instruction .)
    WHILE           reduce using rule 64 (type_cycle -> cycles instruction .)
    IF              reduce using rule 64 (type_cycle -> cycles instruction .)
    FOR             reduce using rule 64 (type_cycle -> cycles instruction .)
    ELSE            reduce using rule 64 (type_cycle -> cycles instruction .)
    PROGRAM         reduce using rule 64 (type_cycle -> cycles instruction .)
    USES            reduce using rule 64 (type_cycle -> cycles instruction .)
    VAR             reduce using rule 64 (type_cycle -> cycles instruction .)
    FUNCTION        reduce using rule 64 (type_cycle -> cycles instruction .)
    PROCEDURE       reduce using rule 64 (type_cycle -> cycles instruction .)
    BEGIN           reduce using rule 64 (type_cycle -> cycles instruction .)
    $end            reduce using rule 64 (type_cycle -> cycles instruction .)


state 229

    (13) var_declaration_2 -> ID var_declaration_3 COLON type_specifier SEMICOLON var_declaration_4 .

    PROGRAM         reduce using rule 13 (var_declaration_2 -> ID var_declaration_3 COLON type_specifier SEMICOLON var_declaration_4 .)
    USES            reduce using rule 13 (var_declaration_2 -> ID var_declaration_3 COLON type_specifier SEMICOLON var_declaration_4 .)
    VAR             reduce using rule 13 (var_declaration_2 -> ID var_declaration_3 COLON type_specifier SEMICOLON var_declaration_4 .)
    FUNCTION        reduce using rule 13 (var_declaration_2 -> ID var_declaration_3 COLON type_specifier SEMICOLON var_declaration_4 .)
    PROCEDURE       reduce using rule 13 (var_declaration_2 -> ID var_declaration_3 COLON type_specifier SEMICOLON var_declaration_4 .)
    BEGIN           reduce using rule 13 (var_declaration_2 -> ID var_declaration_3 COLON type_specifier SEMICOLON var_declaration_4 .)
    $end            reduce using rule 13 (var_declaration_2 -> ID var_declaration_3 COLON type_specifier SEMICOLON var_declaration_4 .)


state 230

    (16) var_declaration_4 -> var_declaration_2 .

    PROGRAM         reduce using rule 16 (var_declaration_4 -> var_declaration_2 .)
    USES            reduce using rule 16 (var_declaration_4 -> var_declaration_2 .)
    VAR             reduce using rule 16 (var_declaration_4 -> var_declaration_2 .)
    FUNCTION        reduce using rule 16 (var_declaration_4 -> var_declaration_2 .)
    PROCEDURE       reduce using rule 16 (var_declaration_4 -> var_declaration_2 .)
    BEGIN           reduce using rule 16 (var_declaration_4 -> var_declaration_2 .)
    $end            reduce using rule 16 (var_declaration_4 -> var_declaration_2 .)


state 231

    (17) var_declaration_4 -> empty .

    PROGRAM         reduce using rule 17 (var_declaration_4 -> empty .)
    USES            reduce using rule 17 (var_declaration_4 -> empty .)
    VAR             reduce using rule 17 (var_declaration_4 -> empty .)
    FUNCTION        reduce using rule 17 (var_declaration_4 -> empty .)
    PROCEDURE       reduce using rule 17 (var_declaration_4 -> empty .)
    BEGIN           reduce using rule 17 (var_declaration_4 -> empty .)
    $end            reduce using rule 17 (var_declaration_4 -> empty .)


state 232

    (111) Begin_function -> BEGIN instruction END SEMICOLON . instruction
    (31) instruction -> . asignation instruction
    (32) instruction -> . writing instruction
    (33) instruction -> . cycles instruction
    (34) instruction -> . callFunctions instruction
    (35) instruction -> . empty
    (55) asignation -> . ID EQUAL callFunctions SEMICOLON
    (56) asignation -> . ID EQUAL math SEMICOLON
    (57) asignation -> . ID EQUAL boolean SEMICOLON
    (58) asignation -> . ID EQUAL TEXT SEMICOLON
    (49) writing -> . WRITELN LPAREN id_text_l TEXT id_text_r RPAREN SEMICOLON
    (50) writing -> . WRITELN LPAREN id_num RPAREN SEMICOLON
    (51) writing -> . READLN LPAREN ID RPAREN SEMICOLON
    (52) writing -> . READLN LPAREN RPAREN SEMICOLON
    (53) writing -> . READLN SEMICOLON
    (54) writing -> . WRITELN SEMICOLON
    (60) cycles -> . type_cycle
    (36) callFunctions -> . ID LPAREN params RPAREN
    (18) empty -> .
    (61) type_cycle -> . while
    (62) type_cycle -> . if
    (63) type_cycle -> . for
    (64) type_cycle -> . cycles instruction
    (65) while -> . WHILE internexpression op_cycle DO otherBegin
    (66) if -> . IF internexpression op_cycle THEN otherBegin_if
    (67) if -> . IF internexpression op_cycle THEN instruction_one_line
    (68) if -> . IF internexpression op_cycle THEN otherBegin_if ELSE otherBegin
    (69) if -> . IF internexpression op_cycle THEN otherBegin_if ELSE instruction_one_line
    (70) if -> . IF internexpression op_cycle THEN instruction_one_line ELSE otherBegin
    (71) if -> . IF internexpression op_cycle THEN instruction_one_line ELSE instruction_one_line
    (72) for -> . FOR asignation_for TO id_num DO otherBegin
    (73) for -> . FOR asignation_for DOWNTO id_num DO otherBegin

    ID              shift and go to state 24
    WRITELN         shift and go to state 23
    READLN          shift and go to state 29
    PROGRAM         reduce using rule 18 (empty -> .)
    USES            reduce using rule 18 (empty -> .)
    VAR             reduce using rule 18 (empty -> .)
    FUNCTION        reduce using rule 18 (empty -> .)
    PROCEDURE       reduce using rule 18 (empty -> .)
    BEGIN           reduce using rule 18 (empty -> .)
    $end            reduce using rule 18 (empty -> .)
    WHILE           shift and go to state 17
    IF              shift and go to state 25
    FOR             shift and go to state 22

    instruction                    shift and go to state 247
    if                             shift and go to state 20
    for                            shift and go to state 26
    writing                        shift and go to state 18
    callFunctions                  shift and go to state 19
    asignation                     shift and go to state 28
    type_cycle                     shift and go to state 30
    while                          shift and go to state 31
    empty                          shift and go to state 21
    cycles                         shift and go to state 32

state 233

    (110) Begin_function -> var_declaration BEGIN instruction END . SEMICOLON instruction

    SEMICOLON       shift and go to state 248


state 234

    (113) function_declaration -> PROCEDURE ID LPAREN fun_param RPAREN SEMICOLON Begin_function .

    PROGRAM         reduce using rule 113 (function_declaration -> PROCEDURE ID LPAREN fun_param RPAREN SEMICOLON Begin_function .)
    USES            reduce using rule 113 (function_declaration -> PROCEDURE ID LPAREN fun_param RPAREN SEMICOLON Begin_function .)
    VAR             reduce using rule 113 (function_declaration -> PROCEDURE ID LPAREN fun_param RPAREN SEMICOLON Begin_function .)
    FUNCTION        reduce using rule 113 (function_declaration -> PROCEDURE ID LPAREN fun_param RPAREN SEMICOLON Begin_function .)
    PROCEDURE       reduce using rule 113 (function_declaration -> PROCEDURE ID LPAREN fun_param RPAREN SEMICOLON Begin_function .)
    BEGIN           reduce using rule 113 (function_declaration -> PROCEDURE ID LPAREN fun_param RPAREN SEMICOLON Begin_function .)
    $end            reduce using rule 113 (function_declaration -> PROCEDURE ID LPAREN fun_param RPAREN SEMICOLON Begin_function .)


state 235

    (116) fun_param -> SEMICOLON ID fun_param_2 COLON type_specifier . fun_param
    (115) fun_param -> . ID fun_param_2 COLON type_specifier fun_param
    (116) fun_param -> . SEMICOLON ID fun_param_2 COLON type_specifier fun_param
    (117) fun_param -> . empty
    (18) empty -> .

    ID              shift and go to state 77
    SEMICOLON       shift and go to state 75
    RPAREN          reduce using rule 18 (empty -> .)

    fun_param                      shift and go to state 249
    empty                          shift and go to state 78

state 236

    (112) function_declaration -> FUNCTION ID LPAREN fun_param RPAREN COLON type_specifier SEMICOLON . Begin_function
    (110) Begin_function -> . var_declaration BEGIN instruction END SEMICOLON instruction
    (111) Begin_function -> . BEGIN instruction END SEMICOLON instruction
    (12) var_declaration -> . VAR var_declaration_2

    BEGIN           shift and go to state 133
    VAR             shift and go to state 9

    var_declaration                shift and go to state 134
    Begin_function                 shift and go to state 250

state 237

    (115) fun_param -> ID fun_param_2 COLON type_specifier fun_param .

    RPAREN          reduce using rule 115 (fun_param -> ID fun_param_2 COLON type_specifier fun_param .)


state 238

    (108) otherBegin -> BEGIN instruction END . SEMICOLON instruction

    SEMICOLON       shift and go to state 251


state 239

    (46) id_text_r -> COMMA callFunctions id_text_r .

    RPAREN          reduce using rule 46 (id_text_r -> COMMA callFunctions id_text_r .)


state 240

    (47) id_text_r -> COMMA ID id_text_r .

    RPAREN          reduce using rule 47 (id_text_r -> COMMA ID id_text_r .)


state 241

    (49) writing -> WRITELN LPAREN id_text_l TEXT id_text_r RPAREN SEMICOLON .

    ID              reduce using rule 49 (writing -> WRITELN LPAREN id_text_l TEXT id_text_r RPAREN SEMICOLON .)
    WRITELN         reduce using rule 49 (writing -> WRITELN LPAREN id_text_l TEXT id_text_r RPAREN SEMICOLON .)
    READLN          reduce using rule 49 (writing -> WRITELN LPAREN id_text_l TEXT id_text_r RPAREN SEMICOLON .)
    WHILE           reduce using rule 49 (writing -> WRITELN LPAREN id_text_l TEXT id_text_r RPAREN SEMICOLON .)
    IF              reduce using rule 49 (writing -> WRITELN LPAREN id_text_l TEXT id_text_r RPAREN SEMICOLON .)
    FOR             reduce using rule 49 (writing -> WRITELN LPAREN id_text_l TEXT id_text_r RPAREN SEMICOLON .)
    END             reduce using rule 49 (writing -> WRITELN LPAREN id_text_l TEXT id_text_r RPAREN SEMICOLON .)
    ELSE            reduce using rule 49 (writing -> WRITELN LPAREN id_text_l TEXT id_text_r RPAREN SEMICOLON .)
    PROGRAM         reduce using rule 49 (writing -> WRITELN LPAREN id_text_l TEXT id_text_r RPAREN SEMICOLON .)
    USES            reduce using rule 49 (writing -> WRITELN LPAREN id_text_l TEXT id_text_r RPAREN SEMICOLON .)
    VAR             reduce using rule 49 (writing -> WRITELN LPAREN id_text_l TEXT id_text_r RPAREN SEMICOLON .)
    FUNCTION        reduce using rule 49 (writing -> WRITELN LPAREN id_text_l TEXT id_text_r RPAREN SEMICOLON .)
    PROCEDURE       reduce using rule 49 (writing -> WRITELN LPAREN id_text_l TEXT id_text_r RPAREN SEMICOLON .)
    BEGIN           reduce using rule 49 (writing -> WRITELN LPAREN id_text_l TEXT id_text_r RPAREN SEMICOLON .)
    $end            reduce using rule 49 (writing -> WRITELN LPAREN id_text_l TEXT id_text_r RPAREN SEMICOLON .)


state 242

    (109) otherBegin_if -> BEGIN instruction END . instruction
    (31) instruction -> . asignation instruction
    (32) instruction -> . writing instruction
    (33) instruction -> . cycles instruction
    (34) instruction -> . callFunctions instruction
    (35) instruction -> . empty
    (55) asignation -> . ID EQUAL callFunctions SEMICOLON
    (56) asignation -> . ID EQUAL math SEMICOLON
    (57) asignation -> . ID EQUAL boolean SEMICOLON
    (58) asignation -> . ID EQUAL TEXT SEMICOLON
    (49) writing -> . WRITELN LPAREN id_text_l TEXT id_text_r RPAREN SEMICOLON
    (50) writing -> . WRITELN LPAREN id_num RPAREN SEMICOLON
    (51) writing -> . READLN LPAREN ID RPAREN SEMICOLON
    (52) writing -> . READLN LPAREN RPAREN SEMICOLON
    (53) writing -> . READLN SEMICOLON
    (54) writing -> . WRITELN SEMICOLON
    (60) cycles -> . type_cycle
    (36) callFunctions -> . ID LPAREN params RPAREN
    (18) empty -> .
    (61) type_cycle -> . while
    (62) type_cycle -> . if
    (63) type_cycle -> . for
    (64) type_cycle -> . cycles instruction
    (65) while -> . WHILE internexpression op_cycle DO otherBegin
    (66) if -> . IF internexpression op_cycle THEN otherBegin_if
    (67) if -> . IF internexpression op_cycle THEN instruction_one_line
    (68) if -> . IF internexpression op_cycle THEN otherBegin_if ELSE otherBegin
    (69) if -> . IF internexpression op_cycle THEN otherBegin_if ELSE instruction_one_line
    (70) if -> . IF internexpression op_cycle THEN instruction_one_line ELSE otherBegin
    (71) if -> . IF internexpression op_cycle THEN instruction_one_line ELSE instruction_one_line
    (72) for -> . FOR asignation_for TO id_num DO otherBegin
    (73) for -> . FOR asignation_for DOWNTO id_num DO otherBegin

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WRITELN resolved as shift
  ! shift/reduce conflict for READLN resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
    ID              shift and go to state 24
    WRITELN         shift and go to state 23
    READLN          shift and go to state 29
    END             reduce using rule 18 (empty -> .)
    ELSE            reduce using rule 18 (empty -> .)
    PROGRAM         reduce using rule 18 (empty -> .)
    USES            reduce using rule 18 (empty -> .)
    VAR             reduce using rule 18 (empty -> .)
    FUNCTION        reduce using rule 18 (empty -> .)
    PROCEDURE       reduce using rule 18 (empty -> .)
    BEGIN           reduce using rule 18 (empty -> .)
    $end            reduce using rule 18 (empty -> .)
    WHILE           shift and go to state 17
    IF              shift and go to state 25
    FOR             shift and go to state 22

  ! ID              [ reduce using rule 18 (empty -> .) ]
  ! WRITELN         [ reduce using rule 18 (empty -> .) ]
  ! READLN          [ reduce using rule 18 (empty -> .) ]
  ! WHILE           [ reduce using rule 18 (empty -> .) ]
  ! IF              [ reduce using rule 18 (empty -> .) ]
  ! FOR             [ reduce using rule 18 (empty -> .) ]

    instruction                    shift and go to state 252
    if                             shift and go to state 20
    for                            shift and go to state 26
    writing                        shift and go to state 18
    callFunctions                  shift and go to state 19
    asignation                     shift and go to state 28
    type_cycle                     shift and go to state 30
    while                          shift and go to state 31
    empty                          shift and go to state 21
    cycles                         shift and go to state 32

state 243

    (71) if -> IF internexpression op_cycle THEN instruction_one_line ELSE instruction_one_line .

    ID              reduce using rule 71 (if -> IF internexpression op_cycle THEN instruction_one_line ELSE instruction_one_line .)
    WRITELN         reduce using rule 71 (if -> IF internexpression op_cycle THEN instruction_one_line ELSE instruction_one_line .)
    READLN          reduce using rule 71 (if -> IF internexpression op_cycle THEN instruction_one_line ELSE instruction_one_line .)
    WHILE           reduce using rule 71 (if -> IF internexpression op_cycle THEN instruction_one_line ELSE instruction_one_line .)
    IF              reduce using rule 71 (if -> IF internexpression op_cycle THEN instruction_one_line ELSE instruction_one_line .)
    FOR             reduce using rule 71 (if -> IF internexpression op_cycle THEN instruction_one_line ELSE instruction_one_line .)
    END             reduce using rule 71 (if -> IF internexpression op_cycle THEN instruction_one_line ELSE instruction_one_line .)
    ELSE            reduce using rule 71 (if -> IF internexpression op_cycle THEN instruction_one_line ELSE instruction_one_line .)
    PROGRAM         reduce using rule 71 (if -> IF internexpression op_cycle THEN instruction_one_line ELSE instruction_one_line .)
    USES            reduce using rule 71 (if -> IF internexpression op_cycle THEN instruction_one_line ELSE instruction_one_line .)
    VAR             reduce using rule 71 (if -> IF internexpression op_cycle THEN instruction_one_line ELSE instruction_one_line .)
    FUNCTION        reduce using rule 71 (if -> IF internexpression op_cycle THEN instruction_one_line ELSE instruction_one_line .)
    PROCEDURE       reduce using rule 71 (if -> IF internexpression op_cycle THEN instruction_one_line ELSE instruction_one_line .)
    BEGIN           reduce using rule 71 (if -> IF internexpression op_cycle THEN instruction_one_line ELSE instruction_one_line .)
    $end            reduce using rule 71 (if -> IF internexpression op_cycle THEN instruction_one_line ELSE instruction_one_line .)


state 244

    (70) if -> IF internexpression op_cycle THEN instruction_one_line ELSE otherBegin .

    ID              reduce using rule 70 (if -> IF internexpression op_cycle THEN instruction_one_line ELSE otherBegin .)
    WRITELN         reduce using rule 70 (if -> IF internexpression op_cycle THEN instruction_one_line ELSE otherBegin .)
    READLN          reduce using rule 70 (if -> IF internexpression op_cycle THEN instruction_one_line ELSE otherBegin .)
    WHILE           reduce using rule 70 (if -> IF internexpression op_cycle THEN instruction_one_line ELSE otherBegin .)
    IF              reduce using rule 70 (if -> IF internexpression op_cycle THEN instruction_one_line ELSE otherBegin .)
    FOR             reduce using rule 70 (if -> IF internexpression op_cycle THEN instruction_one_line ELSE otherBegin .)
    END             reduce using rule 70 (if -> IF internexpression op_cycle THEN instruction_one_line ELSE otherBegin .)
    ELSE            reduce using rule 70 (if -> IF internexpression op_cycle THEN instruction_one_line ELSE otherBegin .)
    PROGRAM         reduce using rule 70 (if -> IF internexpression op_cycle THEN instruction_one_line ELSE otherBegin .)
    USES            reduce using rule 70 (if -> IF internexpression op_cycle THEN instruction_one_line ELSE otherBegin .)
    VAR             reduce using rule 70 (if -> IF internexpression op_cycle THEN instruction_one_line ELSE otherBegin .)
    FUNCTION        reduce using rule 70 (if -> IF internexpression op_cycle THEN instruction_one_line ELSE otherBegin .)
    PROCEDURE       reduce using rule 70 (if -> IF internexpression op_cycle THEN instruction_one_line ELSE otherBegin .)
    BEGIN           reduce using rule 70 (if -> IF internexpression op_cycle THEN instruction_one_line ELSE otherBegin .)
    $end            reduce using rule 70 (if -> IF internexpression op_cycle THEN instruction_one_line ELSE otherBegin .)


state 245

    (69) if -> IF internexpression op_cycle THEN otherBegin_if ELSE instruction_one_line .

    ID              reduce using rule 69 (if -> IF internexpression op_cycle THEN otherBegin_if ELSE instruction_one_line .)
    WRITELN         reduce using rule 69 (if -> IF internexpression op_cycle THEN otherBegin_if ELSE instruction_one_line .)
    READLN          reduce using rule 69 (if -> IF internexpression op_cycle THEN otherBegin_if ELSE instruction_one_line .)
    WHILE           reduce using rule 69 (if -> IF internexpression op_cycle THEN otherBegin_if ELSE instruction_one_line .)
    IF              reduce using rule 69 (if -> IF internexpression op_cycle THEN otherBegin_if ELSE instruction_one_line .)
    FOR             reduce using rule 69 (if -> IF internexpression op_cycle THEN otherBegin_if ELSE instruction_one_line .)
    END             reduce using rule 69 (if -> IF internexpression op_cycle THEN otherBegin_if ELSE instruction_one_line .)
    ELSE            reduce using rule 69 (if -> IF internexpression op_cycle THEN otherBegin_if ELSE instruction_one_line .)
    PROGRAM         reduce using rule 69 (if -> IF internexpression op_cycle THEN otherBegin_if ELSE instruction_one_line .)
    USES            reduce using rule 69 (if -> IF internexpression op_cycle THEN otherBegin_if ELSE instruction_one_line .)
    VAR             reduce using rule 69 (if -> IF internexpression op_cycle THEN otherBegin_if ELSE instruction_one_line .)
    FUNCTION        reduce using rule 69 (if -> IF internexpression op_cycle THEN otherBegin_if ELSE instruction_one_line .)
    PROCEDURE       reduce using rule 69 (if -> IF internexpression op_cycle THEN otherBegin_if ELSE instruction_one_line .)
    BEGIN           reduce using rule 69 (if -> IF internexpression op_cycle THEN otherBegin_if ELSE instruction_one_line .)
    $end            reduce using rule 69 (if -> IF internexpression op_cycle THEN otherBegin_if ELSE instruction_one_line .)


state 246

    (68) if -> IF internexpression op_cycle THEN otherBegin_if ELSE otherBegin .

    ID              reduce using rule 68 (if -> IF internexpression op_cycle THEN otherBegin_if ELSE otherBegin .)
    WRITELN         reduce using rule 68 (if -> IF internexpression op_cycle THEN otherBegin_if ELSE otherBegin .)
    READLN          reduce using rule 68 (if -> IF internexpression op_cycle THEN otherBegin_if ELSE otherBegin .)
    WHILE           reduce using rule 68 (if -> IF internexpression op_cycle THEN otherBegin_if ELSE otherBegin .)
    IF              reduce using rule 68 (if -> IF internexpression op_cycle THEN otherBegin_if ELSE otherBegin .)
    FOR             reduce using rule 68 (if -> IF internexpression op_cycle THEN otherBegin_if ELSE otherBegin .)
    END             reduce using rule 68 (if -> IF internexpression op_cycle THEN otherBegin_if ELSE otherBegin .)
    ELSE            reduce using rule 68 (if -> IF internexpression op_cycle THEN otherBegin_if ELSE otherBegin .)
    PROGRAM         reduce using rule 68 (if -> IF internexpression op_cycle THEN otherBegin_if ELSE otherBegin .)
    USES            reduce using rule 68 (if -> IF internexpression op_cycle THEN otherBegin_if ELSE otherBegin .)
    VAR             reduce using rule 68 (if -> IF internexpression op_cycle THEN otherBegin_if ELSE otherBegin .)
    FUNCTION        reduce using rule 68 (if -> IF internexpression op_cycle THEN otherBegin_if ELSE otherBegin .)
    PROCEDURE       reduce using rule 68 (if -> IF internexpression op_cycle THEN otherBegin_if ELSE otherBegin .)
    BEGIN           reduce using rule 68 (if -> IF internexpression op_cycle THEN otherBegin_if ELSE otherBegin .)
    $end            reduce using rule 68 (if -> IF internexpression op_cycle THEN otherBegin_if ELSE otherBegin .)


state 247

    (111) Begin_function -> BEGIN instruction END SEMICOLON instruction .

    PROGRAM         reduce using rule 111 (Begin_function -> BEGIN instruction END SEMICOLON instruction .)
    USES            reduce using rule 111 (Begin_function -> BEGIN instruction END SEMICOLON instruction .)
    VAR             reduce using rule 111 (Begin_function -> BEGIN instruction END SEMICOLON instruction .)
    FUNCTION        reduce using rule 111 (Begin_function -> BEGIN instruction END SEMICOLON instruction .)
    PROCEDURE       reduce using rule 111 (Begin_function -> BEGIN instruction END SEMICOLON instruction .)
    BEGIN           reduce using rule 111 (Begin_function -> BEGIN instruction END SEMICOLON instruction .)
    $end            reduce using rule 111 (Begin_function -> BEGIN instruction END SEMICOLON instruction .)


state 248

    (110) Begin_function -> var_declaration BEGIN instruction END SEMICOLON . instruction
    (31) instruction -> . asignation instruction
    (32) instruction -> . writing instruction
    (33) instruction -> . cycles instruction
    (34) instruction -> . callFunctions instruction
    (35) instruction -> . empty
    (55) asignation -> . ID EQUAL callFunctions SEMICOLON
    (56) asignation -> . ID EQUAL math SEMICOLON
    (57) asignation -> . ID EQUAL boolean SEMICOLON
    (58) asignation -> . ID EQUAL TEXT SEMICOLON
    (49) writing -> . WRITELN LPAREN id_text_l TEXT id_text_r RPAREN SEMICOLON
    (50) writing -> . WRITELN LPAREN id_num RPAREN SEMICOLON
    (51) writing -> . READLN LPAREN ID RPAREN SEMICOLON
    (52) writing -> . READLN LPAREN RPAREN SEMICOLON
    (53) writing -> . READLN SEMICOLON
    (54) writing -> . WRITELN SEMICOLON
    (60) cycles -> . type_cycle
    (36) callFunctions -> . ID LPAREN params RPAREN
    (18) empty -> .
    (61) type_cycle -> . while
    (62) type_cycle -> . if
    (63) type_cycle -> . for
    (64) type_cycle -> . cycles instruction
    (65) while -> . WHILE internexpression op_cycle DO otherBegin
    (66) if -> . IF internexpression op_cycle THEN otherBegin_if
    (67) if -> . IF internexpression op_cycle THEN instruction_one_line
    (68) if -> . IF internexpression op_cycle THEN otherBegin_if ELSE otherBegin
    (69) if -> . IF internexpression op_cycle THEN otherBegin_if ELSE instruction_one_line
    (70) if -> . IF internexpression op_cycle THEN instruction_one_line ELSE otherBegin
    (71) if -> . IF internexpression op_cycle THEN instruction_one_line ELSE instruction_one_line
    (72) for -> . FOR asignation_for TO id_num DO otherBegin
    (73) for -> . FOR asignation_for DOWNTO id_num DO otherBegin

    ID              shift and go to state 24
    WRITELN         shift and go to state 23
    READLN          shift and go to state 29
    PROGRAM         reduce using rule 18 (empty -> .)
    USES            reduce using rule 18 (empty -> .)
    VAR             reduce using rule 18 (empty -> .)
    FUNCTION        reduce using rule 18 (empty -> .)
    PROCEDURE       reduce using rule 18 (empty -> .)
    BEGIN           reduce using rule 18 (empty -> .)
    $end            reduce using rule 18 (empty -> .)
    WHILE           shift and go to state 17
    IF              shift and go to state 25
    FOR             shift and go to state 22

    instruction                    shift and go to state 253
    if                             shift and go to state 20
    for                            shift and go to state 26
    writing                        shift and go to state 18
    callFunctions                  shift and go to state 19
    asignation                     shift and go to state 28
    type_cycle                     shift and go to state 30
    while                          shift and go to state 31
    empty                          shift and go to state 21
    cycles                         shift and go to state 32

state 249

    (116) fun_param -> SEMICOLON ID fun_param_2 COLON type_specifier fun_param .

    RPAREN          reduce using rule 116 (fun_param -> SEMICOLON ID fun_param_2 COLON type_specifier fun_param .)


state 250

    (112) function_declaration -> FUNCTION ID LPAREN fun_param RPAREN COLON type_specifier SEMICOLON Begin_function .

    PROGRAM         reduce using rule 112 (function_declaration -> FUNCTION ID LPAREN fun_param RPAREN COLON type_specifier SEMICOLON Begin_function .)
    USES            reduce using rule 112 (function_declaration -> FUNCTION ID LPAREN fun_param RPAREN COLON type_specifier SEMICOLON Begin_function .)
    VAR             reduce using rule 112 (function_declaration -> FUNCTION ID LPAREN fun_param RPAREN COLON type_specifier SEMICOLON Begin_function .)
    FUNCTION        reduce using rule 112 (function_declaration -> FUNCTION ID LPAREN fun_param RPAREN COLON type_specifier SEMICOLON Begin_function .)
    PROCEDURE       reduce using rule 112 (function_declaration -> FUNCTION ID LPAREN fun_param RPAREN COLON type_specifier SEMICOLON Begin_function .)
    BEGIN           reduce using rule 112 (function_declaration -> FUNCTION ID LPAREN fun_param RPAREN COLON type_specifier SEMICOLON Begin_function .)
    $end            reduce using rule 112 (function_declaration -> FUNCTION ID LPAREN fun_param RPAREN COLON type_specifier SEMICOLON Begin_function .)


state 251

    (108) otherBegin -> BEGIN instruction END SEMICOLON . instruction
    (31) instruction -> . asignation instruction
    (32) instruction -> . writing instruction
    (33) instruction -> . cycles instruction
    (34) instruction -> . callFunctions instruction
    (35) instruction -> . empty
    (55) asignation -> . ID EQUAL callFunctions SEMICOLON
    (56) asignation -> . ID EQUAL math SEMICOLON
    (57) asignation -> . ID EQUAL boolean SEMICOLON
    (58) asignation -> . ID EQUAL TEXT SEMICOLON
    (49) writing -> . WRITELN LPAREN id_text_l TEXT id_text_r RPAREN SEMICOLON
    (50) writing -> . WRITELN LPAREN id_num RPAREN SEMICOLON
    (51) writing -> . READLN LPAREN ID RPAREN SEMICOLON
    (52) writing -> . READLN LPAREN RPAREN SEMICOLON
    (53) writing -> . READLN SEMICOLON
    (54) writing -> . WRITELN SEMICOLON
    (60) cycles -> . type_cycle
    (36) callFunctions -> . ID LPAREN params RPAREN
    (18) empty -> .
    (61) type_cycle -> . while
    (62) type_cycle -> . if
    (63) type_cycle -> . for
    (64) type_cycle -> . cycles instruction
    (65) while -> . WHILE internexpression op_cycle DO otherBegin
    (66) if -> . IF internexpression op_cycle THEN otherBegin_if
    (67) if -> . IF internexpression op_cycle THEN instruction_one_line
    (68) if -> . IF internexpression op_cycle THEN otherBegin_if ELSE otherBegin
    (69) if -> . IF internexpression op_cycle THEN otherBegin_if ELSE instruction_one_line
    (70) if -> . IF internexpression op_cycle THEN instruction_one_line ELSE otherBegin
    (71) if -> . IF internexpression op_cycle THEN instruction_one_line ELSE instruction_one_line
    (72) for -> . FOR asignation_for TO id_num DO otherBegin
    (73) for -> . FOR asignation_for DOWNTO id_num DO otherBegin

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WRITELN resolved as shift
  ! shift/reduce conflict for READLN resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
    ID              shift and go to state 24
    WRITELN         shift and go to state 23
    READLN          shift and go to state 29
    END             reduce using rule 18 (empty -> .)
    ELSE            reduce using rule 18 (empty -> .)
    PROGRAM         reduce using rule 18 (empty -> .)
    USES            reduce using rule 18 (empty -> .)
    VAR             reduce using rule 18 (empty -> .)
    FUNCTION        reduce using rule 18 (empty -> .)
    PROCEDURE       reduce using rule 18 (empty -> .)
    BEGIN           reduce using rule 18 (empty -> .)
    $end            reduce using rule 18 (empty -> .)
    WHILE           shift and go to state 17
    IF              shift and go to state 25
    FOR             shift and go to state 22

  ! ID              [ reduce using rule 18 (empty -> .) ]
  ! WRITELN         [ reduce using rule 18 (empty -> .) ]
  ! READLN          [ reduce using rule 18 (empty -> .) ]
  ! WHILE           [ reduce using rule 18 (empty -> .) ]
  ! IF              [ reduce using rule 18 (empty -> .) ]
  ! FOR             [ reduce using rule 18 (empty -> .) ]

    instruction                    shift and go to state 254
    if                             shift and go to state 20
    for                            shift and go to state 26
    writing                        shift and go to state 18
    callFunctions                  shift and go to state 19
    asignation                     shift and go to state 28
    type_cycle                     shift and go to state 30
    while                          shift and go to state 31
    empty                          shift and go to state 21
    cycles                         shift and go to state 32

state 252

    (109) otherBegin_if -> BEGIN instruction END instruction .

    END             reduce using rule 109 (otherBegin_if -> BEGIN instruction END instruction .)
    ID              reduce using rule 109 (otherBegin_if -> BEGIN instruction END instruction .)
    WRITELN         reduce using rule 109 (otherBegin_if -> BEGIN instruction END instruction .)
    READLN          reduce using rule 109 (otherBegin_if -> BEGIN instruction END instruction .)
    WHILE           reduce using rule 109 (otherBegin_if -> BEGIN instruction END instruction .)
    IF              reduce using rule 109 (otherBegin_if -> BEGIN instruction END instruction .)
    FOR             reduce using rule 109 (otherBegin_if -> BEGIN instruction END instruction .)
    ELSE            reduce using rule 109 (otherBegin_if -> BEGIN instruction END instruction .)
    PROGRAM         reduce using rule 109 (otherBegin_if -> BEGIN instruction END instruction .)
    USES            reduce using rule 109 (otherBegin_if -> BEGIN instruction END instruction .)
    VAR             reduce using rule 109 (otherBegin_if -> BEGIN instruction END instruction .)
    FUNCTION        reduce using rule 109 (otherBegin_if -> BEGIN instruction END instruction .)
    PROCEDURE       reduce using rule 109 (otherBegin_if -> BEGIN instruction END instruction .)
    BEGIN           reduce using rule 109 (otherBegin_if -> BEGIN instruction END instruction .)
    $end            reduce using rule 109 (otherBegin_if -> BEGIN instruction END instruction .)


state 253

    (110) Begin_function -> var_declaration BEGIN instruction END SEMICOLON instruction .

    PROGRAM         reduce using rule 110 (Begin_function -> var_declaration BEGIN instruction END SEMICOLON instruction .)
    USES            reduce using rule 110 (Begin_function -> var_declaration BEGIN instruction END SEMICOLON instruction .)
    VAR             reduce using rule 110 (Begin_function -> var_declaration BEGIN instruction END SEMICOLON instruction .)
    FUNCTION        reduce using rule 110 (Begin_function -> var_declaration BEGIN instruction END SEMICOLON instruction .)
    PROCEDURE       reduce using rule 110 (Begin_function -> var_declaration BEGIN instruction END SEMICOLON instruction .)
    BEGIN           reduce using rule 110 (Begin_function -> var_declaration BEGIN instruction END SEMICOLON instruction .)
    $end            reduce using rule 110 (Begin_function -> var_declaration BEGIN instruction END SEMICOLON instruction .)


state 254

    (108) otherBegin -> BEGIN instruction END SEMICOLON instruction .

    END             reduce using rule 108 (otherBegin -> BEGIN instruction END SEMICOLON instruction .)
    ID              reduce using rule 108 (otherBegin -> BEGIN instruction END SEMICOLON instruction .)
    WRITELN         reduce using rule 108 (otherBegin -> BEGIN instruction END SEMICOLON instruction .)
    READLN          reduce using rule 108 (otherBegin -> BEGIN instruction END SEMICOLON instruction .)
    WHILE           reduce using rule 108 (otherBegin -> BEGIN instruction END SEMICOLON instruction .)
    IF              reduce using rule 108 (otherBegin -> BEGIN instruction END SEMICOLON instruction .)
    FOR             reduce using rule 108 (otherBegin -> BEGIN instruction END SEMICOLON instruction .)
    ELSE            reduce using rule 108 (otherBegin -> BEGIN instruction END SEMICOLON instruction .)
    PROGRAM         reduce using rule 108 (otherBegin -> BEGIN instruction END SEMICOLON instruction .)
    USES            reduce using rule 108 (otherBegin -> BEGIN instruction END SEMICOLON instruction .)
    VAR             reduce using rule 108 (otherBegin -> BEGIN instruction END SEMICOLON instruction .)
    FUNCTION        reduce using rule 108 (otherBegin -> BEGIN instruction END SEMICOLON instruction .)
    PROCEDURE       reduce using rule 108 (otherBegin -> BEGIN instruction END SEMICOLON instruction .)
    BEGIN           reduce using rule 108 (otherBegin -> BEGIN instruction END SEMICOLON instruction .)
    $end            reduce using rule 108 (otherBegin -> BEGIN instruction END SEMICOLON instruction .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ID in state 18 resolved as shift
WARNING: shift/reduce conflict for WRITELN in state 18 resolved as shift
WARNING: shift/reduce conflict for READLN in state 18 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 18 resolved as shift
WARNING: shift/reduce conflict for IF in state 18 resolved as shift
WARNING: shift/reduce conflict for FOR in state 18 resolved as shift
WARNING: shift/reduce conflict for ID in state 19 resolved as shift
WARNING: shift/reduce conflict for WRITELN in state 19 resolved as shift
WARNING: shift/reduce conflict for READLN in state 19 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 19 resolved as shift
WARNING: shift/reduce conflict for IF in state 19 resolved as shift
WARNING: shift/reduce conflict for FOR in state 19 resolved as shift
WARNING: shift/reduce conflict for ID in state 28 resolved as shift
WARNING: shift/reduce conflict for WRITELN in state 28 resolved as shift
WARNING: shift/reduce conflict for READLN in state 28 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 28 resolved as shift
WARNING: shift/reduce conflict for IF in state 28 resolved as shift
WARNING: shift/reduce conflict for FOR in state 28 resolved as shift
WARNING: shift/reduce conflict for ID in state 32 resolved as shift
WARNING: shift/reduce conflict for WRITELN in state 32 resolved as shift
WARNING: shift/reduce conflict for READLN in state 32 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 32 resolved as shift
WARNING: shift/reduce conflict for IF in state 32 resolved as shift
WARNING: shift/reduce conflict for FOR in state 32 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 205 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 208 resolved as shift
WARNING: shift/reduce conflict for ID in state 209 resolved as shift
WARNING: shift/reduce conflict for WRITELN in state 209 resolved as shift
WARNING: shift/reduce conflict for READLN in state 209 resolved as shift
WARNING: shift/reduce conflict for ID in state 209 resolved as shift
WARNING: shift/reduce conflict for WRITELN in state 209 resolved as shift
WARNING: shift/reduce conflict for READLN in state 209 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 209 resolved as shift
WARNING: shift/reduce conflict for IF in state 209 resolved as shift
WARNING: shift/reduce conflict for FOR in state 209 resolved as shift
WARNING: shift/reduce conflict for ID in state 242 resolved as shift
WARNING: shift/reduce conflict for WRITELN in state 242 resolved as shift
WARNING: shift/reduce conflict for READLN in state 242 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 242 resolved as shift
WARNING: shift/reduce conflict for IF in state 242 resolved as shift
WARNING: shift/reduce conflict for FOR in state 242 resolved as shift
WARNING: shift/reduce conflict for ID in state 251 resolved as shift
WARNING: shift/reduce conflict for WRITELN in state 251 resolved as shift
WARNING: shift/reduce conflict for READLN in state 251 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 251 resolved as shift
WARNING: shift/reduce conflict for IF in state 251 resolved as shift
WARNING: shift/reduce conflict for FOR in state 251 resolved as shift
WARNING: reduce/reduce conflict in state 52 resolved using rule (factor -> ID)
WARNING: rejected rule (expression -> ID) in state 52
WARNING: reduce/reduce conflict in state 69 resolved using rule (instruction -> cycles instruction)
WARNING: rejected rule (type_cycle -> cycles instruction) in state 69
WARNING: reduce/reduce conflict in state 209 resolved using rule (empty -> <empty>)
WARNING: rejected rule (instruction_one_line -> cycles) in state 209
WARNING: Rule (instruction_one_line -> cycles) is never reduced
